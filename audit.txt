==== ./parse_commit_date.rb ====
# frozen_string_literal: true

module ParseCommitDate
  extend ActiveSupport::Concern

  def convert_date_to_epoch(date)
    Date.strptime(date, "%Y-%m-%d")&.to_time&.to_i if date
  rescue Date::Error, TypeError
  end
end
==== ./incident_management_feature_flag.rb ====
# frozen_string_literal: true

module IncidentManagementFeatureFlag
  extend ActiveSupport::Concern

  private

  def check_incidents_feature_flag
    return unless Feature.enabled?(:hide_incident_management_features, project)

    handle_feature_flag_enabled_response
  end

  def handle_feature_flag_enabled_response
    render_404
  end
end
==== ./ci/auth_build_trace.rb ====
# frozen_string_literal: true

module Ci
  module AuthBuildTrace
    extend ActiveSupport::Concern

    def authorize_read_build_trace!
      return if can?(current_user, :read_build_trace, build)

      if build.debug_mode?
        access_denied!(
          _('You must have developer or higher permissions in the associated project to view job logs when debug ' \
            "trace is enabled. To disable debug trace, set the 'CI_DEBUG_TRACE' and 'CI_DEBUG_SERVICES' variables to " \
            "'false' in your pipeline configuration or CI/CD settings. If you must view this job log, " \
            'a project maintainer or owner must add you to the project with developer permissions or higher.')
        )
      else
        access_denied!(_('The current user is not authorized to access the job log.'))
      end
    end
  end
end
==== ./rapid_diffs/streaming_resource.rb ====
# frozen_string_literal: true

module RapidDiffs
  module StreamingResource
    extend ActiveSupport::Concern
    include ActionController::Live
    include DiffHelper

    def diffs
      streaming_start_time = Process.clock_gettime(Process::CLOCK_MONOTONIC)

      stream_headers

      offset = { offset_index: params.permit(:offset)[:offset].to_i }

      context = view_context

      # view_context calls are not memoized, with explicit passing we are able to reuse it across renders
      stream_diff_files(streaming_diff_options.merge(offset), context)

      streaming_time = (Process.clock_gettime(Process::CLOCK_MONOTONIC) - streaming_start_time).round(2)
      response.stream.write "<server-timings streaming=\"#{streaming_time}\"></server-timings>"
    rescue ActionController::Live::ClientDisconnected
      # Ignored
    rescue StandardError => e
      Gitlab::AppLogger.error("Error streaming diffs: #{e.message}")
      error_component = ::RapidDiffs::StreamingErrorComponent.new(message: e.message)
      response.stream.write error_component.render_in(context)
    ensure
      response.stream.close
    end

    def request
      # We only need to do this in rapid diffs streaming endpoints
      # as calling `request.format` (which can happen when rendering view components
      # but can possibly happen in other places as well) can raise an exception
      # while streaming diffs.
      Request.new(super)
    end

    private

    def resource
      raise NotImplementedError
    end

    def streaming_diff_options
      diff_options
    end

    def view
      helpers.diff_view
    end

    def stream_diff_files(options, view_context)
      return unless resource

      # NOTE: This is a temporary flag to test out the new diff_blobs
      if !!ActiveModel::Type::Boolean.new.cast(params.permit(:diff_blobs)[:diff_blobs])
        stream_diff_blobs(options, view_context)
      else
        stream_diff_collection(options, view_context)
      end
    end

    def stream_diff_collection(options, view_context)
      diff_files = resource.diffs_for_streaming(options).diff_files(sorted: sorted?)

      return render_empty_state if diff_files.empty?

      skipped = []
      diff_files.each do |diff_file|
        if diff_file.no_preview?
          skipped << diff_file
        else
          unless skipped.empty?
            response.stream.write(diff_files_collection(skipped).render_in(view_context))
            skipped = []
          end

          response.stream.write(diff_file_component(diff_file).render_in(view_context))
        end
      end

      response.stream.write(diff_files_collection(skipped).render_in(view_context)) unless skipped.empty?
    end

    def diff_file_component(diff_file)
      ::RapidDiffs::DiffFileComponent.new(diff_file: diff_file, parallel_view: view == :parallel)
    end

    def diff_files_collection(diff_files)
      ::RapidDiffs::DiffFileComponent.with_collection(diff_files, parallel_view: view == :parallel)
    end

    def stream_diff_blobs(options, view_context)
      return render_empty_state if resource.diffs_for_streaming(options).count == 0

      resource.diffs_for_streaming(options) do |diff_files_batch|
        response.stream.write(diff_files_collection(diff_files_batch).render_in(view_context))
      end
    end

    def render_empty_state
      response.stream.write render ::RapidDiffs::EmptyStateComponent.new
    end

    def sorted?
      false
    end

    class Request < SimpleDelegator
      def format
        Mime::Type.lookup("text/html")
      end
    end
  end
end
==== ./rapid_diffs/resource.rb ====
# frozen_string_literal: true

module RapidDiffs
  module Resource
    extend ActiveSupport::Concern

    def diff_files_metadata
      return render_404 unless diffs_resource.present?

      render json: {
        diff_files: DiffFileMetadataEntity.represent(diffs_resource.raw_diff_files)
      }
    end

    def diffs_stats
      return render_404 unless diffs_resource.present?

      render json: RapidDiffs::DiffsStatsEntity.represent(
        diffs_resource,
        {
          email_path: email_format_path,
          diff_path: complete_diff_path
        }
      )
    end

    def diff_file
      return render_404 unless diffs_resource.present?

      old_path = diff_file_params[:old_path]
      new_path = diff_file_params[:new_path]
      ignore_whitespace_changes = Gitlab::Utils.to_boolean(diff_file_params[:ignore_whitespace_changes])

      options = {
        expanded: true,
        ignore_whitespace_change: ignore_whitespace_changes
      }

      diff_file = find_diff_file(options, old_path, new_path)
      return render_404 unless diff_file

      if diff_file.whitespace_only? && ignore_whitespace_changes
        options[:ignore_whitespace_change] = false
        diff_file = find_diff_file(options, old_path, new_path)
      end

      render diff_file_component(diff_file: diff_file, parallel_view: diff_view == :parallel), layout: false
    end

    private

    def diffs_resource(options = {})
      raise NotImplementedError
    end

    def diff_file_component(base_args)
      ::RapidDiffs::DiffFileComponent.new(**base_args)
    end

    def find_diff_file(extra_options, old_path, new_path)
      with_custom_diff_options do |options|
        options[:paths] = [old_path, new_path].compact
        diffs_resource(**options.merge(extra_options)).diff_files.first
      end
    end

    # When overridden this mthod should return a path to view diffs in an email-friendly format.
    def email_format_path
      nil
    end

    # When overridden this method should return a path to view the complete diffs in the UI.
    def complete_diff_path
      nil
    end

    def diff_file_params
      params.permit(:old_path, :new_path, :ignore_whitespace_changes, :view)
    end
  end
end
==== ./issues_calendar.rb ====
# frozen_string_literal: true

module IssuesCalendar
  extend ActiveSupport::Concern

  # rubocop:disable Gitlab/ModuleWithInstanceVariables
  def render_issues_calendar(issuables)
    @issues = issuables
                  .non_archived
                  .with_due_date
                  .limit(100)

    respond_to do |format|
      format.ics do
        # NOTE: with text/calendar as Content-Type, the browser always downloads
        #       the content as a file (even ignoring the Content-Disposition
        #       header). We want to display the content inline when accessed
        #       from GitLab, similarly to the RSS feed.
        response.headers['Content-Type'] = 'text/plain' if request.referer&.start_with?(::Settings.gitlab.base_url)
      end
    end
  end
  # rubocop:enable Gitlab/ModuleWithInstanceVariables
end
==== ./issuable_actions.rb ====
# frozen_string_literal: true

module IssuableActions
  extend ActiveSupport::Concern
  include Gitlab::Utils::StrongMemoize
  include Gitlab::Cache::Helpers
  include SpammableActions::AkismetMarkAsSpamAction
  include SpammableActions::CaptchaCheck::HtmlFormatActionsSupport
  include SpammableActions::CaptchaCheck::JsonFormatActionsSupport

  included do
    before_action :authorize_destroy_issuable!, only: :destroy
    before_action :check_destroy_confirmation!, only: :destroy
    before_action :authorize_admin_issuable!, only: :bulk_update
    before_action :set_application_context!, only: :show
  end

  def show
    respond_to do |format|
      format.html do
        @issuable_sidebar = serializer.represent(issuable, serializer: 'sidebar') # rubocop:disable Gitlab/ModuleWithInstanceVariables
        render 'show'
      end

      format.json do
        render json: serializer.represent(issuable, serializer: params[:serializer])
      end
    end
  end

  def update
    updated_issuable = update_service.execute(issuable)
    # NOTE: We only assign the instance variable on this line, and use the local variable
    # everywhere else in the method, to avoid having to add multiple `rubocop:disable` comments.
    @issuable = updated_issuable # rubocop:disable Gitlab/ModuleWithInstanceVariables

    # NOTE: This check for `is_a?(Spammable)` is necessary because not all
    # possible `issuable` types implement Spammable. Once they all implement Spammable,
    # this check can be removed.
    if updated_issuable.is_a?(Spammable)
      respond_to do |format|
        format.html do
          if updated_issuable.valid?
            # NOTE: This redirect is intentionally only performed in the case where the valid updated
            # issuable is a spammable, and intentionally is not performed below in the
            # valid non-spammable case. This preserves the legacy behavior of this action.
            redirect_to spammable_path
          else
            with_captcha_check_html_format(spammable: spammable) { render :edit }
          end
        end

        format.json do
          with_captcha_check_json_format(spammable: spammable) { render_entity_json }
        end
      end
    else
      respond_to do |format|
        format.html do
          render :edit
        end

        format.json do
          render_entity_json
        end
      end
    end
  rescue ActiveRecord::StaleObjectError
    render_conflict_response
  end

  def realtime_changes
    Gitlab::PollingInterval.set_header(response, interval: 3_000)

    response = {
      title: view_context.markdown_field(issuable, :title),
      title_text: issuable.title,
      description: view_context.markdown_field(issuable, :description),
      description_text: issuable.description,
      task_completion_status: issuable.task_completion_status,
      lock_version: issuable.lock_version
    }

    if issuable.edited?
      response[:updated_at] = issuable.last_edited_at.to_time.iso8601
      response[:updated_by_name] = issuable.last_edited_by.name
      response[:updated_by_path] = user_path(issuable.last_edited_by)
    end

    render json: response
  end

  def destroy
    destroy_service.execute(issuable)

    name = issuable.human_class_name
    flash[:notice] = "The #{name} was successfully deleted."
    index_path = polymorphic_path([parent, issuable.class])

    respond_to do |format|
      format.html { redirect_to index_path, status: :see_other }
      format.json do
        render json: {
          web_url: index_path
        }
      end
    end
  end

  def check_destroy_confirmation!
    return true if params[:destroy_confirm]

    error_message = "Destroy confirmation not provided for #{issuable.human_class_name}"
    exception = RuntimeError.new(error_message)
    Gitlab::ErrorTracking.track_exception(
      exception,
      project_path: issuable.project.full_path,
      issuable_type: issuable.class.name,
      issuable_id: issuable.id
    )

    index_path = polymorphic_path([parent, issuable.class])

    respond_to do |format|
      format.html do
        flash[:notice] = error_message
        redirect_to index_path
      end
      format.json do
        render json: { errors: error_message }, status: :unprocessable_entity
      end
    end
  end

  def bulk_update
    result = Issuable::BulkUpdateService.new(parent, current_user, bulk_update_params).execute(resource_name)

    if result.success?
      quantity = result.payload[:count]
      render json: { notice: "#{quantity} #{resource_name.pluralize(quantity)} updated" }
    elsif result.error?
      render json: { errors: result.message }, status: result.http_status
    end
  end

  def discussions
    finder = Issuable::DiscussionsListService.new(current_user, issuable, finder_params_for_issuable)
    discussion_notes = finder.execute

    yield discussion_notes if block_given?

    if finder.paginator.present? && finder.paginator.has_next_page?
      response.headers['X-Next-Page-Cursor'] = finder.paginator.cursor_for_next_page
    end

    case issuable
    when MergeRequest, Issue
      if stale?(etag: [discussion_cache_context, discussion_notes])
        render json: discussion_serializer.represent(discussion_notes, context: self)
      end
    else
      render json: discussion_serializer.represent(discussion_notes, context: self)
    end
  end

  private

  def notes_filter
    notes_filter_param = params[:notes_filter]&.to_i

    # GitLab Geo does not expect database UPDATE or INSERT statements to happen
    # on GET requests.
    # This is just a fail-safe in case notes_filter is sent via GET request in GitLab Geo.
    # In some cases, we also force the filter to not be persisted with the `persist_filter` param
    if Gitlab::Database.read_only? || params[:persist_filter] == 'false'
      notes_filter_param || current_user&.notes_filter_for(issuable)
    else
      current_user&.set_notes_filter(notes_filter_param, issuable) || notes_filter_param
    end
  end
  strong_memoize_attr :notes_filter

  def discussion_cache_context
    [current_user&.cache_key, project.team.human_max_access(current_user&.id), 'v2'].join(':')
  end

  def discussion_serializer
    DiscussionSerializer.new(project: project, noteable: issuable, current_user: current_user,
      note_entity: ProjectNoteEntity)
  end

  def render_conflict_response
    respond_to do |format|
      format.html do
        @conflict = true # rubocop:disable Gitlab/ModuleWithInstanceVariables
        render :edit
      end

      format.json do
        render json: {
          errors: [
            <<~HEREDOC.squish
            Someone edited this #{issuable.human_class_name} at the same time you did.
            Please refresh your browser and make sure your changes will not unintentionally remove theirs.
            HEREDOC
          ]
        }, status: :conflict
      end
    end
  end

  def authorize_destroy_issuable!
    access_denied! unless can?(current_user, :"destroy_#{issuable.to_ability_name}", issuable)
  end

  def authorize_admin_issuable!
    access_denied! unless can?(current_user, :"admin_#{resource_name}", parent)
  end

  def authorize_update_issuable!
    render_404 unless can?(current_user, :"update_#{resource_name}", issuable)
  end

  def set_application_context!
    # no-op. The logic is defined in EE module.
  end

  def bulk_update_params
    clean_bulk_update_params(
      params.require(:update).permit(bulk_update_permitted_keys)
    )
  end

  def clean_bulk_update_params(permitted_params)
    permitted_params.delete_if do |k, v|
      next if k == :issuable_ids

      if v.is_a?(Array)
        v.compact.empty?
      else
        v.blank?
      end
    end
  end

  def bulk_update_permitted_keys
    [
      :issuable_ids,
      :assignee_id,
      :milestone_id,
      :state_event,
      :subscription_event,
      :confidential,
      :status,
      { assignee_ids: [],
        add_label_ids: [],
        remove_label_ids: [] }
    ]
  end

  def resource_name
    @resource_name ||= controller_name.singularize
  end

  # rubocop:disable Gitlab/ModuleWithInstanceVariables
  def render_entity_json
    if @issuable.valid?
      render json: serializer.represent(@issuable)
    else
      render json: { errors: @issuable.errors.full_messages }, status: :unprocessable_entity
    end
  end
  # rubocop:enable Gitlab/ModuleWithInstanceVariables

  def serializer
    raise NotImplementedError
  end

  def update_service
    raise NotImplementedError
  end

  def destroy_service
    Issuable::DestroyService.new(container: issuable.project, current_user: current_user)
  end

  def parent
    @project || @group # rubocop:disable Gitlab/ModuleWithInstanceVariables
  end

  def finder_params_for_issuable
    {
      notes_filter: notes_filter,
      cursor: params[:cursor],
      per_page: params[:per_page]
    }
  end
end

IssuableActions.prepend_mod_with('IssuableActions')
==== ./enforces_admin_authentication.rb ====
# frozen_string_literal: true

# == EnforcesAdminAuthentication
#
# Controller concern to enforce that users are authenticated as admins
#
# Upon inclusion, adds `authenticate_admin!` as a before_action
#
module EnforcesAdminAuthentication
  extend ActiveSupport::Concern

  included do
    before_action :authenticate_admin!

    def self.authorize!(ability, only:)
      actions = Array(only)

      skip_before_action :authenticate_admin!, only: actions
      before_action -> { authorize_ability!(ability) }, only: actions
    end
  end

  def authenticate_admin!
    return render_404 unless user_is_admin?
    return unless Gitlab::CurrentSettings.admin_mode

    unless current_user_mode.admin_mode?
      current_user_mode.request_admin_mode!
      store_location_for(:redirect, request.fullpath) if storable_location?
      redirect_to(new_admin_session_path, notice: _('Re-authentication required'))
    end
  end

  def storable_location?
    request.path != new_admin_session_path
  end

  private

  def user_is_admin?
    current_user.admin?
  end

  def authorize_ability!(ability)
    return authenticate_admin! if current_user.admin?

    render_404 unless current_user.can?(ability)
  end
end
==== ./issuable_collections.rb ====
# frozen_string_literal: true

module IssuableCollections
  extend ActiveSupport::Concern
  include PaginatedCollection
  include SearchRateLimitable
  include SortingHelper
  include SortingPreference
  include Gitlab::Utils::StrongMemoize

  included do
    helper_method :finder
  end

  private

  # rubocop:disable Gitlab/ModuleWithInstanceVariables
  def set_issuables_index
    @issuables = issuables_collection
    set_pagination

    nil if redirect_out_of_range(@issuables, @total_pages)
  end

  def set_pagination
    row_count = request.format.atom? ? -1 : finder.row_count

    @issuables          = @issuables.page(params[:page])
    @issuables          = per_page_for_relative_position if params[:sort] == 'relative_position'
    @issuables          = @issuables.without_count if row_count == -1
    @issuable_meta_data = Gitlab::IssuableMetadata.new(current_user, @issuables).data
    @total_pages        = page_count_for_relation(@issuables, row_count)
  end
  # rubocop:enable Gitlab/ModuleWithInstanceVariables

  # rubocop: disable CodeReuse/ActiveRecord
  def issuables_collection
    finder.execute.preload(preload_for_collection)
  end
  # rubocop: enable CodeReuse/ActiveRecord

  def page_count_for_relation(relation, row_count)
    limit = relation.limit_value.to_f

    return 1 if limit == 0
    return (params[:page] || 1).to_i + 1 if row_count == -1

    (row_count.to_f / limit).ceil
  end

  # manual / relative_position sorting allows for 100 items on the page
  def per_page_for_relative_position
    @issuables.per(100) # rubocop:disable Gitlab/ModuleWithInstanceVariables
  end

  def issuable_finder_for(finder_class)
    finder_class.new(current_user, finder_options)
  end

  # rubocop:disable Gitlab/ModuleWithInstanceVariables
  def finder_options
    params[:state] = default_state if params[:state].blank?

    options = {
      scope: params[:scope],
      state: params[:state],
      confidential: Gitlab::Utils.to_boolean(params[:confidential]),
      sort: set_sort_order
    }

    # Used by view to highlight active option
    @sort = options[:sort]

    # When a user looks for an exact iid, we do not filter by search but only by iid
    if params[:search] =~ /^#(?<iid>\d+)\z/
      options[:iids] = Regexp.last_match[:iid]
      params[:search] = nil
    end

    if @project
      options[:project_id] = @project.id
      options[:attempt_project_search_optimizations] = true
    elsif @group
      options[:group_id] = @group.id
      options[:include_subgroups] = true
      options[:attempt_group_search_optimizations] = true
    end

    params.permit(finder_type.valid_params).merge(options)
  end
  strong_memoize_attr :finder_options
  # rubocop:enable Gitlab/ModuleWithInstanceVariables

  def default_state
    'opened'
  end

  def legacy_sort_cookie_name
    'issuable_sort'
  end

  def default_sort_order
    if %w[merged closed].include?(params[:state])
      sort_value_recently_updated
    else
      sort_value_created_date
    end
  end

  def finder
    @finder ||= issuable_finder_for(finder_type)
  end

  def collection_type
    @collection_type ||= if finder_type <= IssuesFinder
                           'Issue'
                         elsif finder_type <= MergeRequestsFinder
                           'MergeRequest'
                         end
  end

  # rubocop:disable Gitlab/ModuleWithInstanceVariables
  def preload_for_collection
    common_attributes = [:author, :assignees, :labels, :milestone]
    @preload_for_collection ||= case collection_type
                                when 'Issue'
                                  common_attributes + [
                                    :work_item_type,
                                    :project, { project: :namespace }
                                  ]
                                when 'MergeRequest'
                                  common_attributes + [
                                    :target_project, :latest_merge_request_diff, :approvals,
                                    :approved_by_users, :reviewers,
                                    { source_project: :route, head_pipeline: :project, target_project: :namespace }
                                  ]
                                end
  end
  # rubocop:enable Gitlab/ModuleWithInstanceVariables
end

IssuableCollections.prepend_mod_with('IssuableCollections')
==== ./bizible_csp.rb ====
# frozen_string_literal: true

module BizibleCSP
  extend ActiveSupport::Concern

  included do
    content_security_policy do |policy|
      next unless helpers.bizible_enabled?
      next unless policy.directives.present?

      default_script_src = policy.directives['script-src'] || policy.directives['default-src']
      script_src_values = Array.wrap(default_script_src) | ["'unsafe-eval'", 'https://cdn.bizible.com/scripts/bizible.js']
      policy.script_src(*script_src_values)
    end
  end
end
==== ./renders_member_access.rb ====
# frozen_string_literal: true

module RendersMemberAccess
  def prepare_groups_for_rendering(groups)
    preload_max_member_access_for_collection(Group, groups)

    groups
  end

  private

  # rubocop: disable CodeReuse/ActiveRecord
  def preload_max_member_access_for_collection(klass, collection)
    return if !current_user || collection.blank?

    method_name = "max_member_access_for_#{klass.name.underscore}_ids"

    collection_ids = collection.try(:map, &:id) || collection.ids
    current_user.public_send(method_name, collection_ids) # rubocop:disable GitlabSecurity/PublicSend
  end
  # rubocop: enable CodeReuse/ActiveRecord
end
==== ./web_hooks/hook_actions.rb ====
# frozen_string_literal: true

module WebHooks
  module HookActions
    extend ActiveSupport::Concern
    include HookExecutionNotice

    included do
      attr_writer :hooks, :hook

      before_action :hook_logs, only: :edit
      feature_category :webhooks
    end

    def index
      self.hooks = relation.select(&:persisted?)
      self.hook = relation.new
    end

    def create
      result = WebHooks::CreateService.new(current_user).execute(hook_params, relation)

      if result.success?
        flash[:notice] = _('Webhook created')
      else
        self.hooks = relation.select(&:persisted?)
        flash[:alert] = result.message
      end

      redirect_to action: :index
    end

    def update
      if hook.update(hook_params)
        flash[:notice] = _('Webhook updated')
        redirect_to action: :edit
      else
        render 'edit'
      end
    end

    def destroy
      destroy_hook(hook)

      redirect_to action: :index, status: :found
    end

    def edit
      redirect_to(action: :index) unless hook
    end

    private

    def hook_params
      permitted = hook_param_names + trigger_values
      permitted << { url_variables: [:key, :value], custom_headers: [:key, :value] }

      ps = params.require(:hook).permit(*permitted).to_h

      ps.delete(:token) if action_name == 'update' && ps[:token] == WebHook::SECRET_MASK

      ps[:url_variables] = ps[:url_variables].to_h { [_1[:key], _1[:value].presence] } if ps.key?(:url_variables)
      ps[:custom_headers] = ps[:custom_headers].to_h { [_1[:key], hook_value_from_param_or_db(_1[:key], _1[:value])] }

      if action_name == 'update' && ps.key?(:url_variables)
        supplied = ps[:url_variables]
        ps[:url_variables] = hook.url_variables.merge(supplied).compact
      end

      ps
    end

    def hook_param_names
      %i[enable_ssl_verification name description token url push_events_branch_filter branch_filter_strategy
        custom_webhook_template]
    end

    def destroy_hook(hook)
      result = WebHooks::DestroyService.new(current_user).execute(hook)

      if result[:status] == :success
        flash[:notice] = result[:async] ? _('Webhook scheduled for deletion') : _('Webhook deleted')
      else
        flash[:alert] = result[:message]
      end
    end

    def hook_logs
      @hook_logs ||= hook.web_hook_logs.recent.page(pagination_params[:page]).without_count
    end

    def hook_value_from_param_or_db(key, value)
      if value == WebHook::SECRET_MASK && hook.custom_headers.key?(key)
        hook.custom_headers[key]
      else
        value
      end
    end
  end
end
==== ./web_hooks/hook_log_actions.rb ====
# frozen_string_literal: true

module WebHooks
  module HookLogActions
    extend ActiveSupport::Concern
    include HookExecutionNotice

    included do
      before_action :hook, only: [:show, :retry]
      before_action :hook_log, only: [:show, :retry]

      respond_to :html

      feature_category :webhooks
      urgency :low, [:retry]
    end

    def show
      hide_search_settings
    end

    def retry
      result = execute_hook
      if result.success?
        redirect_to after_retry_redirect_path
      else
        flash[:warning] = result.message
        redirect_back(fallback_location: after_retry_redirect_path)
      end
    end

    private

    def hook_log
      @hook_log ||= hook.web_hook_logs.find(params[:id])
    end

    def execute_hook
      result = WebHooks::Events::ResendService.new(hook_log, current_user: current_user).execute
      set_hook_execution_notice(result)
      result
    end

    def hide_search_settings
      @hide_search_settings ||= true
    end
  end
end
==== ./web_hooks/hook_execution_notice.rb ====
# frozen_string_literal: true

module WebHooks
  module HookExecutionNotice
    private

    def set_hook_execution_notice(result)
      http_status = result.payload[:http_status]
      message = result[:message]

      if http_status && http_status >= 200 && http_status < 400
        flash[:notice] = "Hook executed successfully: HTTP #{http_status}"
      elsif http_status
        flash[:alert] = "Hook executed successfully but returned HTTP #{http_status} #{message}"
      else
        flash[:alert] = "Hook execution failed: #{message}"
      end
    end
  end
end
==== ./sends_blob.rb ====
# frozen_string_literal: true

module SendsBlob
  extend ActiveSupport::Concern

  included do
    include BlobHelper
    include SendFileUpload
  end

  def send_blob(repository, blob, inline: true, allow_caching: false)
    if blob
      headers['X-Content-Type-Options'] = 'nosniff'

      return if cached_blob?(blob, allow_caching: allow_caching)

      if blob.stored_externally?
        send_lfs_object(blob, repository.project)
      else
        send_git_blob(repository, blob, inline: inline)
      end
    else
      render_404
    end
  end

  private

  def cached_blob?(blob, allow_caching: false)
    stale = stale?(strong_etag: blob.id)

    max_age =
      if @ref && @commit && @ref == @commit.id # rubocop:disable Gitlab/ModuleWithInstanceVariables
        # This is a link to a commit by its commit SHA. That means that the blob
        # is immutable. The only reason to invalidate the cache is if the commit
        # was deleted or if the user lost access to the repository.
        Blob::CACHE_TIME_IMMUTABLE
      else
        # A branch or tag points at this blob. That means that the expected blob
        # value may change over time.
        Blob::CACHE_TIME
      end

    # Because we are opinionated we set the cache headers ourselves.
    expires_in(max_age,
      public: allow_caching, must_revalidate: true, stale_if_error: 5.minutes,
      stale_while_revalidate: 1.minute, 's-maxage': 1.minute)

    !stale
  end

  def send_lfs_object(blob, project)
    lfs_object = find_lfs_object(blob)

    if lfs_object && lfs_object.project_allowed_access?(project)
      send_upload(lfs_object.file, attachment: blob.name)
    else
      render_404
    end
  end

  def find_lfs_object(blob)
    lfs_object = LfsObject.find_by_oid(blob.lfs_oid)
    if lfs_object && lfs_object.file.exists?
      lfs_object
    else
      nil
    end
  end
end
==== ./access_tokens_actions.rb ====
# frozen_string_literal: true

module AccessTokensActions
  extend ActiveSupport::Concern

  included do
    before_action -> { check_permission(:read_resource_access_tokens) }, only: [:index, :inactive]
    before_action -> { check_permission(:destroy_resource_access_tokens) }, only: [:revoke]
    before_action -> { check_permission(:manage_resource_access_tokens) }, only: [:rotate]
    before_action -> { check_permission(:create_resource_access_tokens) }, only: [:create]
  end

  # rubocop:disable Gitlab/ModuleWithInstanceVariables
  def index
    @resource_access_token = PersonalAccessToken.new
    set_index_vars

    respond_to do |format|
      format.html
      format.json do
        render json: @active_access_tokens
      end
    end
  end
  # rubocop:enable Gitlab/ModuleWithInstanceVariables

  # rubocop:disable Gitlab/ModuleWithInstanceVariables
  def create
    token_response = ResourceAccessTokens::CreateService.new(current_user, resource, create_params).execute

    if token_response.success?
      @resource_access_token = token_response.payload[:access_token]
      tokens, size = active_access_tokens
      render json: { new_token: @resource_access_token.token,
                     active_access_tokens: tokens, total: size }, status: :ok
    else
      render json: { errors: token_response.errors }, status: :unprocessable_entity
    end
  end
  # rubocop:enable Gitlab/ModuleWithInstanceVariables

  # rubocop:disable Gitlab/ModuleWithInstanceVariables
  def revoke
    @resource_access_token = finder.find(params[:id])
    revoked_response = ResourceAccessTokens::RevokeService.new(current_user, resource, @resource_access_token).execute

    if revoked_response.success?
      flash[:notice] =
        format(_("Revoked access token %{access_token_name}!"), access_token_name: @resource_access_token.name)
    else
      flash[:alert] =
        format(_("Could not revoke access token %{access_token_name}."), access_token_name: @resource_access_token.name)
    end

    redirect_to resource_access_tokens_path
  end
  # rubocop:enable Gitlab/ModuleWithInstanceVariables

  def rotate
    token = finder.find(rotate_params[:id])
    result = rotate_service.new(current_user, token, resource, keep_token_lifetime: true).execute
    resource_access_token = result.payload[:personal_access_token]

    if result.success?
      tokens, size = active_access_tokens
      render json: { new_token: resource_access_token.token,
                     active_access_tokens: tokens, total: size }, status: :ok
    else
      render json: { message: result.message }, status: :unprocessable_entity
    end
  end

  def inactive
    tokens = inactive_access_tokens.page(page)
    add_pagination_headers(tokens)

    render json: represent(tokens)
  end

  private

  def check_permission(action)
    render_404 unless can?(current_user, action, resource)
  end

  def create_params
    params.require(:resource_access_token).permit(:name, :expires_at, :description, :access_level, scopes: [])
  end

  def rotate_params
    params.permit(:id)
  end

  # rubocop:disable Gitlab/ModuleWithInstanceVariables
  def set_index_vars
    # Loading resource members so that we can fetch access level of the bot
    # user in the resource without multiple queries.
    resource.members.load

    @scopes = Gitlab::Auth.available_scopes_for(resource)

    @active_access_tokens, @active_access_tokens_size = active_access_tokens
    @inactive_access_tokens_size = inactive_access_tokens.size
  end
  # rubocop:enable Gitlab/ModuleWithInstanceVariables

  def finder(options = {})
    PersonalAccessTokensFinder.new({ user: bot_users, impersonation: false }.merge(options))
  end

  def bot_users
    resource.bots
  end

  def key_identity
    "#{current_user.id}:#{resource.id}"
  end
end
==== ./runner_setup_scripts.rb ====
# frozen_string_literal: true

module RunnerSetupScripts
  extend ActiveSupport::Concern

  private

  def private_runner_setup_scripts
    instructions = Gitlab::Ci::RunnerInstructions.new(os: script_params[:os], arch: script_params[:arch])
    output = {
      install: instructions.install_script,
      register: instructions.register_command
    }

    if instructions.errors.any?
      render json: { errors: instructions.errors }, status: :bad_request
    else
      render json: output
    end
  end

  def script_params
    params.permit(:os, :arch)
  end
end
==== ./notes_actions.rb ====
# frozen_string_literal: true

module NotesActions
  include RendersNotes
  include Gitlab::Utils::StrongMemoize
  extend ActiveSupport::Concern

  # last_fetched_at is an integer number of microseconds, which is the same
  # precision as PostgreSQL "timestamp" fields.
  MICROSECOND = 1_000_000

  included do
    before_action :set_polling_interval_header, only: [:index]
    before_action :require_last_fetched_at_header!, only: [:index]
    before_action :require_noteable!, only: [:index, :create]
    before_action :authorize_admin_note!, only: [:update, :destroy]
    before_action :note_project, only: [:create]
    before_action -> {
      check_rate_limit!(:notes_create,
        scope: current_user,
        users_allowlist: Gitlab::CurrentSettings.current_application_settings.notes_create_limit_allowlist)
    }, only: [:create]
  end

  def index
    notes, meta = gather_all_notes
    notes = prepare_notes_for_rendering(notes)
    notes = notes.select { |n| n.readable_by?(current_user) }
    notes =
      if use_note_serializer?
        note_serializer.represent(notes)
      else
        notes.map { |note| note_json(note) }
      end

    render json: meta.merge(notes: notes)
  end

  # rubocop:disable Gitlab/ModuleWithInstanceVariables
  def create
    @note = Notes::CreateService.new(note_project, current_user, create_note_params).execute

    respond_to do |format|
      format.json do
        json = {
          commands_changes: @note.commands_changes&.slice(:emoji_award, :time_estimate, :spend_time)
        }

        if @note.persisted? && return_discussion?
          json[:valid] = true

          discussion = @note.discussion
          prepare_notes_for_rendering(discussion.notes)
          json[:discussion] = discussion_serializer.represent(discussion, context: self)
        else
          prepare_notes_for_rendering([@note])

          json.merge!(note_json(@note))
        end

        quick_actions = @note.quick_actions_status
        json[:quick_actions_status] = quick_actions.to_h if quick_actions

        if @note.errors.present?
          render json: { errors: errors_on_create(@note) }, status: :unprocessable_entity
        elsif quick_actions&.error?
          render json: { quick_actions_status: quick_actions.to_h }, status: :unprocessable_entity
        else
          render json: json
        end
      end
      format.html { redirect_back_or_default }
    end
  end
  # rubocop:enable Gitlab/ModuleWithInstanceVariables

  # rubocop:disable Gitlab/ModuleWithInstanceVariables
  def update
    @note = Notes::UpdateService.new(project, current_user, update_note_params).execute(note)
    if @note.destroyed?
      head :gone
      return
    end

    respond_to do |format|
      format.json do
        if @note.errors.present?
          render json: { errors: @note.errors.full_messages.to_sentence }, status: :unprocessable_entity
        else
          prepare_notes_for_rendering([@note])
          render json: note_json(@note)
        end
      end

      format.html { redirect_back_or_default }
    end
  end
  # rubocop:enable Gitlab/ModuleWithInstanceVariables

  def destroy
    Notes::DestroyService.new(project, current_user).execute(note) if note.editable?

    respond_to do |format|
      format.js { head :ok }
    end
  end

  private

  def gather_all_notes
    now = Time.current
    notes = merge_resource_events(notes_finder.execute.inc_relations_for_view(noteable))

    [notes, { last_fetched_at: (now.to_i * MICROSECOND) + now.usec }]
  end

  def merge_resource_events(notes)
    return notes if notes_filter == UserPreference::NOTES_FILTERS[:only_comments]

    ResourceEvents::MergeIntoNotesService
      .new(noteable, current_user, last_fetched_at: last_fetched_at)
      .execute(notes)
  end

  def note_html(note)
    render_to_string(
      "shared/notes/_note",
      layout: false,
      formats: [:html],
      locals: { note: note }
    )
  end

  def note_json(note)
    attrs = {}

    if note.persisted?
      attrs[:valid] = true

      if return_discussion?
        discussion = note.discussion
        prepare_notes_for_rendering(discussion.notes)

        attrs[:discussion] = discussion_serializer.represent(discussion, context: self)
      elsif use_note_serializer?
        attrs.merge!(note_serializer.represent(note))
      else
        attrs.merge!(
          id: note.id,
          discussion_id: note.discussion_id(noteable),
          html: note_html(note),
          note: note.note,
          on_image: note.try(:on_image?)
        )

        discussion = note.to_discussion(noteable)
        unless discussion.individual_note?
          attrs.merge!(
            discussion_resolvable: discussion.resolvable?,

            diff_discussion_html: diff_discussion_html(discussion),
            discussion_html: discussion_html(discussion)
          )

          attrs[:discussion_line_code] = discussion.line_code if discussion.diff_discussion?
        end
      end
    else
      attrs.merge!(
        valid: false,
        errors: note.errors
      )
    end

    attrs
  end

  def diff_discussion_html(discussion)
    return unless discussion.diff_discussion?

    on_image = discussion.on_image?

    if params[:view] == 'parallel' && !on_image
      template = "discussions/_parallel_diff_discussion"
      locals =
        if params[:line_type] == 'old'
          { discussions_left: [discussion], discussions_right: nil }
        else
          { discussions_left: nil, discussions_right: [discussion] }
        end
    else
      template = "discussions/_diff_discussion"
      @fresh_discussion = true # rubocop:disable Gitlab/ModuleWithInstanceVariables

      locals = { discussions: [discussion], on_image: on_image }
    end

    render_to_string(
      template,
      layout: false,
      formats: [:html],
      locals: locals
    )
  end

  def discussion_html(discussion)
    return if discussion.individual_note?

    render_to_string(
      "discussions/_discussion",
      layout: false,
      formats: [:html],
      locals: { discussion: discussion }
    )
  end

  def authorize_admin_note!
    access_denied! unless can?(current_user, :admin_note, note)
  end

  def create_note_params
    params.require(:note).permit(
      :type,
      :note,
      :line_code, # LegacyDiffNote
      :position, # DiffNote
      :confidential,
      :internal
    ).tap do |create_params|
      create_params.merge!(
        params.permit(:merge_request_diff_head_sha, :in_reply_to_discussion_id)
      )

      # These params are also sent by the client but we need to set these based on
      # target_type and target_id because we're checking permissions based on that
      create_params[:noteable_type] = noteable.class.name

      case noteable
      when Commit
        create_params[:commit_id] = noteable.id
      when MergeRequest
        create_params[:noteable_id] = noteable.id
        # Notes on MergeRequest can have an extra `commit_id` context
        create_params[:commit_id] = params.dig(:note, :commit_id)
      else
        create_params[:noteable_id] = noteable.id
      end
    end
  end

  def update_note_params
    params.require(:note).permit(:note, :position)
  end

  def set_polling_interval_header(interval: 6000)
    Gitlab::PollingInterval.set_header(response, interval: interval)
  end

  def noteable
    @noteable ||= notes_finder.target || @note&.noteable # rubocop:disable Gitlab/ModuleWithInstanceVariables
  end

  def require_noteable!
    render_404 unless noteable
  end

  def require_last_fetched_at_header!
    return if request.headers['X-Last-Fetched-At'].present?

    render json: { message: 'X-Last-Fetched-At header is required' }, status: :bad_request
  end

  def last_fetched_at
    microseconds = request.headers['X-Last-Fetched-At'].to_i

    seconds = microseconds / MICROSECOND
    frac = microseconds % MICROSECOND

    Time.zone.at(seconds, frac)
  end
  strong_memoize_attr :last_fetched_at

  def notes_filter
    current_user&.notes_filter_for(params[:target_type])
  end

  def notes_finder
    @notes_finder ||= NotesFinder.new(current_user, finder_params)
  end

  def note_serializer
    ProjectNoteSerializer.new(project: project, noteable: noteable, current_user: current_user)
  end
  strong_memoize_attr :note_serializer

  def discussion_serializer
    DiscussionSerializer.new(
      project: project,
      noteable: noteable,
      current_user: current_user,
      note_entity: ProjectNoteEntity
    )
  end

  def note_project
    return unless project

    note_project_id = params[:note_project_id]

    the_project =
      if note_project_id.present?
        Project.find(note_project_id)
      else
        project
      end

    return access_denied! unless can?(current_user, :create_note, the_project)

    the_project
  end
  strong_memoize_attr :note_project

  def return_discussion?
    Gitlab::Utils.to_boolean(params[:return_discussion])
  end

  def use_note_serializer?
    return false if params['html']

    noteable.discussions_rendered_on_frontend?
  end

  def errors_on_create(note)
    note.errors.full_messages.to_sentence
  end
end

NotesActions.prepend_mod_with('NotesActions')
==== ./impersonation.rb ====
# frozen_string_literal: true

module Impersonation
  include Gitlab::Utils::StrongMemoize

  SESSION_KEYS_TO_DELETE = %w[
    github_access_token gitea_access_token gitlab_access_token
    bitbucket_token bitbucket_refresh_token bitbucket_server_personal_access_token
    bulk_import_gitlab_access_token fogbugz_token cloud_platform_access_token
  ].freeze

  def current_user
    user = super

    user.impersonator = impersonator if impersonator

    user
  end

  protected

  def check_impersonation_availability
    return unless impersonation_in_progress?

    unless Gitlab.config.gitlab.impersonation_enabled
      stop_impersonation
      access_denied! _('Impersonation has been disabled')
    end
  end

  def stop_impersonation
    log_impersonation_event

    warden.set_user(impersonator, scope: :user)
    session[:impersonator_id] = nil
    clear_access_token_session_keys!

    current_user
  end

  def impersonation_in_progress?
    session[:impersonator_id].present?
  end

  def log_impersonation_event
    Gitlab::AppLogger.info("User #{impersonator.username} has stopped impersonating #{current_user.username}")
  end

  def clear_access_token_session_keys!
    access_tokens_keys = session.keys & SESSION_KEYS_TO_DELETE

    access_tokens_keys.each { |key| session.delete(key) }
  end

  def impersonator
    User.find(session[:impersonator_id]) if session[:impersonator_id]
  end
  strong_memoize_attr :impersonator
end
==== ./accepts_pending_invitations.rb ====
# frozen_string_literal: true

module AcceptsPendingInvitations
  extend ActiveSupport::Concern

  def accept_pending_invitations(user: resource)
    return unless user.active_for_authentication?

    if user.pending_invitations.load.any?
      user.accept_pending_invitations!
      after_pending_invitations_hook
    end
  end

  def after_pending_invitations_hook
    # no-op
  end
end
==== ./labels_as_hash.rb ====
# frozen_string_literal: true

module LabelsAsHash
  extend ActiveSupport::Concern

  def labels_as_hash(target = nil, params = {})
    available_labels = LabelsFinder.new(
      current_user,
      params
    ).execute

    label_hashes = available_labels.as_json(only: [:title, :color])

    if target.respond_to?(:labels)
      already_set_labels = available_labels & target.labels
      if already_set_labels.present?
        titles = already_set_labels.map(&:title)
        label_hashes.each do |hash|
          hash[:set] = true if titles.include?(hash['title'])
        end
      end
    end

    label_hashes
  end
end
==== ./import_url_params.rb ====
# frozen_string_literal: true

module ImportUrlParams
  def import_url_params
    return {} unless params.dig(:project, :import_url).present?

    {
      import_url: import_params_to_full_url(params[:project]),
      # We need to set import_type because attempting to retry an import by URL
      # could leave a stale value around. This would erroneously cause an importer
      # (e.g. import/export) to run.
      import_type: 'git'
    }
  end

  def import_params_to_full_url(params)
    Gitlab::UrlSanitizer.new(
      params[:import_url],
      credentials: {
        user: params[:import_url_user],
        password: params[:import_url_password]
      }
    ).full_url
  end
end
==== ./snippets_sort.rb ====
# frozen_string_literal: true

module SnippetsSort
  extend ActiveSupport::Concern

  def sort_param
    pagination_params[:sort].presence || 'updated_desc'
  end
end
==== ./renders_commits.rb ====
# frozen_string_literal: true

module RendersCommits
  def limited_commits(commits, commits_count)
    if commits_count > MergeRequestDiff::COMMITS_SAFE_SIZE
      [
        commits.first(MergeRequestDiff::COMMITS_SAFE_SIZE),
        commits_count - MergeRequestDiff::COMMITS_SAFE_SIZE
      ]
    else
      [commits, 0]
    end
  end

  # This is used as a helper method in a controller.
  # rubocop: disable Gitlab/ModuleWithInstanceVariables
  def set_commits_for_rendering(commits, commits_count: nil)
    @total_commit_count = commits_count || commits.size
    limited, @hidden_commit_count = limited_commits(commits, @total_commit_count)
    prepare_commits_for_rendering(limited)
  end
  # rubocop: enable Gitlab/ModuleWithInstanceVariables

  def prepare_commits_for_rendering(commits)
    commits.each(&:lazy_author) # preload commits' authors
    commits.each(&:lazy_latest_pipeline)

    Banzai::CommitRenderer.render(commits, @project, current_user) # rubocop:disable Gitlab/ModuleWithInstanceVariables

    commits
  end

  def valid_ref?(ref_name)
    return true unless ref_name.present?

    Gitlab::GitRefValidator.validate(ref_name, skip_head_ref_check: true)
  end
end
==== ./params_backward_compatibility.rb ====
# frozen_string_literal: true

module ParamsBackwardCompatibility
  private

  def set_non_archived_param
    params[:non_archived] = params[:archived].blank?
  end
end
==== ./invisible_captcha_on_signup.rb ====
# frozen_string_literal: true

module InvisibleCaptchaOnSignup
  extend ActiveSupport::Concern

  included do
    invisible_captcha only: :create, on_spam: :on_honeypot_spam_callback, on_timestamp_spam: :on_timestamp_spam_callback
  end

  def on_honeypot_spam_callback
    return unless Gitlab::CurrentSettings.invisible_captcha_enabled

    invisible_captcha_honeypot_counter.increment
    log_request('Invisible_Captcha_Honeypot_Request')

    head(:ok)
  end

  def on_timestamp_spam_callback
    return unless Gitlab::CurrentSettings.invisible_captcha_enabled

    invisible_captcha_timestamp_counter.increment
    log_request('Invisible_Captcha_Timestamp_Request')

    redirect_to new_user_session_path, alert: InvisibleCaptcha.timestamp_error_message
  end

  def invisible_captcha_honeypot_counter
    @invisible_captcha_honeypot_counter ||= Gitlab::Metrics.counter(
      :bot_blocked_by_invisible_captcha_honeypot,
      'Counter of blocked sign up attempts with filled honeypot'
    )
  end

  def invisible_captcha_timestamp_counter
    @invisible_captcha_timestamp_counter ||= Gitlab::Metrics.counter(
      :bot_blocked_by_invisible_captcha_timestamp,
      'Counter of blocked sign up attempts with invalid timestamp'
    )
  end

  def log_request(message)
    request_information = {
      message: message,
      env: :invisible_captcha_signup_bot_detected,
      remote_ip: request.ip,
      request_method: request.request_method,
      path: request.filtered_path
    }

    Gitlab::AuthLogger.error(request_information)
  end
end
==== ./issuable_links.rb ====
# frozen_string_literal: true

module IssuableLinks
  def index
    render json: issuables
  end

  def create
    result = create_service.execute

    render json: { message: result[:message], issuables: issuables }, status: result[:http_status]
  end

  def destroy
    result = destroy_service.execute

    render json: { issuables: issuables }, status: result[:http_status]
  end

  private

  def issuables
    list_service.execute
  end

  def list_service
    raise NotImplementedError
  end

  def create_params
    params.permit(issuable_references: [])
  end

  def create_service
    raise NotImplementedError
  end

  def destroy_service
    raise NotImplementedError
  end
end
==== ./page_limiter.rb ====
# frozen_string_literal: true

# Include this in your controller and call `limit_pages` in order
# to configure the limiter.
#
#   Examples:
#     class MyController < ApplicationController
#       include PageLimiter
#
#       before_action only: [:index] do
#         limit_pages(500)
#       end
#
#       # You can override the default response
#       rescue_from PageOutOfBoundsError, with: :page_out_of_bounds
#
#       def page_out_of_bounds(error)
#         # Page limit number is available as error.message
#         head :ok
#       end
#

module PageLimiter
  extend ActiveSupport::Concern

  PageLimiterError          = Class.new(StandardError)
  PageLimitNotANumberError  = Class.new(PageLimiterError)
  PageLimitNotSensibleError = Class.new(PageLimiterError)
  PageOutOfBoundsError      = Class.new(PageLimiterError)

  included do
    rescue_from PageOutOfBoundsError, with: :default_page_out_of_bounds_response
  end

  def limit_pages(max_page_number)
    check_page_number!(max_page_number)
  end

  private

  # If the page exceeds the defined maximum, raise a PageOutOfBoundsError
  # If the page doesn't exceed the limit, it does nothing.
  def check_page_number!(max_page_number)
    raise PageLimitNotANumberError unless max_page_number.is_a?(Integer)
    raise PageLimitNotSensibleError unless max_page_number > 0

    return if params[:page].blank?
    return if params[:page].to_i <= max_page_number

    record_page_limit_interception
    raise PageOutOfBoundsError, max_page_number
  end

  # By default just return a HTTP status code and an empty response
  def default_page_out_of_bounds_response
    head :bad_request
  end

  # Record the page limit being hit in Prometheus
  def record_page_limit_interception
    dd = Gitlab::SafeDeviceDetector.new(request.user_agent)

    Gitlab::Metrics.counter(:gitlab_page_out_of_bounds,
      controller: params[:controller],
      action: params[:action],
      bot: dd.bot?
    ).increment
  end
end
==== ./controller_with_cross_project_access_check.rb ====
# frozen_string_literal: true

module ControllerWithCrossProjectAccessCheck
  extend ActiveSupport::Concern

  included do
    extend Gitlab::CrossProjectAccess::ClassMethods
    before_action :cross_project_check
  end

  def cross_project_check
    authorize_cross_project_page! if Gitlab::CrossProjectAccess.find_check(self)&.should_run?(self)
  end

  def authorize_cross_project_page!
    return if can?(current_user, :read_cross_project)

    rejection_message = _(
      "This page is unavailable because you are not allowed to read information " \
        "across multiple projects."
    )
    access_denied!(rejection_message)
  end
end
==== ./membership_actions.rb ====
# frozen_string_literal: true

module MembershipActions
  include MembersPresentation
  extend ActiveSupport::Concern

  included do
    before_action :authenticate_user!, only: :request_access
    before_action :already_a_member!, only: :request_access
  end

  def update
    member = members_and_requesters.find(params[:id])
    result = Members::UpdateService
      .new(current_user, update_params)
      .execute(member)

    if result[:status] == :success
      render json: update_success_response(result)
    else
      render json: { message: result[:message] }, status: :unprocessable_entity
    end
  end

  def destroy
    member = members_and_requesters.find(params[:id])
    skip_subresources = !ActiveRecord::Type::Boolean.new.cast(params.delete(:remove_sub_memberships))
    # !! is used in case unassign_issuables contains empty string which would result in nil
    unassign_issuables = !!ActiveRecord::Type::Boolean.new.cast(params.delete(:unassign_issuables))

    Members::DestroyService.new(current_user).execute(
      member,
      skip_subresources: skip_subresources,
      unassign_issuables: unassign_issuables
    )

    respond_to do |format|
      format.html do
        message =
          case membershipable
          when Namespace
            if skip_subresources
              _("User was successfully removed from group.")
            else
              _("User was successfully removed from group and any subgroups and projects.")
            end
          else
            _("User was successfully removed from project.")
          end

        redirect_to members_page_url, notice: message, status: :see_other
      end

      format.js { head :ok }
    end
  end

  def request_access
    access_requester = membershipable.request_access(current_user)

    if access_requester.persisted?
      redirect_to polymorphic_path(membershipable),
        notice: _('Your request for access has been queued for review.')
    else
      redirect_to polymorphic_path(membershipable),
        alert: format(
          _("Your request for access could not be processed: %{error_message}"),
          error_message: access_requester.errors.full_messages.to_sentence
        )
    end
  end

  def approve_access_request
    access_requester = requesters.find(params[:id])
    result = Members::ApproveAccessRequestService
      .new(current_user, params)
      .execute(access_requester)

    if result[:status] == :success
      redirect_to members_page_url
    else
      redirect_to members_page_url, alert: result[:message]
    end
  end

  # rubocop: disable CodeReuse/ActiveRecord
  def leave
    member = members_and_requesters.find_by!(user_id: current_user.id)
    Members::DestroyService.new(current_user).execute(member)

    notice =
      if member.request?
        format(_("Your access request to the %{source_type} has been withdrawn."), source_type: source_type)
      else
        format(
          _("You left the \"%{membershipable_human_name}\" %{source_type}."),
          membershipable_human_name: membershipable.human_name,
          source_type: source_type
        )
      end

    respond_to do |format|
      format.html do
        redirect_path = member.request? ? member.source : [:dashboard, membershipable.class.to_s.tableize.to_sym]
        redirect_to redirect_path, notice: notice
      end

      format.json { render json: { notice: notice } }
    end
  end
  # rubocop: enable CodeReuse/ActiveRecord

  def resend_invite
    member = membershipable_members.find(params[:id])

    if member.invite?
      member.resend_invite

      redirect_to members_page_url, notice: _('The invitation was successfully resent.')
    else
      redirect_to members_page_url, alert: _('The invitation has already been accepted.')
    end
  end

  protected

  def membershipable
    raise NotImplementedError
  end

  def membershipable_members
    raise NotImplementedError
  end

  def root_params_key
    raise NotImplementedError
  end

  def members_page_url
    raise NotImplementedError
  end

  def source_type
    raise NotImplementedError
  end

  def plain_source_type
    raise NotImplementedError
  end

  def source
    raise NotImplementedError
  end

  def members_and_requesters
    membershipable.members_and_requesters
  end

  def requesters
    membershipable.requesters
  end

  def update_params
    params.require(root_params_key).permit(:access_level, :expires_at).merge({ source: source })
  end

  def requested_relations(inherited_permissions = :with_inherited_permissions)
    case params[inherited_permissions].presence
    when 'exclude'
      [:direct]
    when 'only'
      [:inherited].concat(shared_members_relations)
    else
      [:inherited, :direct].concat(shared_members_relations)
    end
  end

  def authenticate_user!
    return if current_user

    store_location_for :user, request.fullpath
    redirect_to new_user_session_path
  end

  def already_a_member!
    member = members.with_user(current_user)
    if member.present?
      redirect_to polymorphic_path(membershipable), notice: _('You already have access.')
    else
      requester = requesters.with_user(current_user)
      return unless requester.present?

      redirect_to polymorphic_path(membershipable), notice: _('You have already requested access.')
    end
  end

  private

  def update_success_response(result)
    member = result[:members].first
    if member.expires?
      {
        expires_soon: member.expires_soon?,
        expires_at_formatted: member.expires_at.to_time.in_time_zone.to_fs(:medium)
      }
    else
      {}
    end
  end

  def shared_members_relations
    project_relations = [:invited_groups, :shared_into_ancestors]
    [:shared_from_groups, *(project_relations if params[:project_id])]
  end
end

MembershipActions.prepend_mod_with('MembershipActions')
==== ./filters_events.rb ====
# frozen_string_literal: true

module FiltersEvents
  def event_filter
    @event_filter ||= new_event_filter.tap { |ef| cookies[:event_filter] = ef.filter }
  end

  private

  def new_event_filter
    active_filter = params[:event_filter].presence || cookies[:event_filter]
    EventFilter.new(active_filter)
  end
end
==== ./paginated_collection.rb ====
# frozen_string_literal: true

module PaginatedCollection
  extend ActiveSupport::Concern

  private

  def redirect_out_of_range(collection, total_pages = collection.total_pages)
    return false if total_pages == 0

    out_of_range = collection.current_page > total_pages

    redirect_to(url_for(safe_params.merge(page: total_pages, only_path: true))) if out_of_range

    out_of_range
  end
end
==== ./renders_notes.rb ====
# frozen_string_literal: true

module RendersNotes
  # rubocop:disable Gitlab/ModuleWithInstanceVariables
  def prepare_notes_for_rendering(notes)
    preload_noteable_for_regular_notes(notes)
    preload_note_namespace(notes)
    preload_max_access_for_authors(notes, @project)
    preload_author_status(notes)
    Notes::RenderService.new(current_user).execute(notes)

    notes
  end
  # rubocop:enable Gitlab/ModuleWithInstanceVariables

  private

  def preload_note_namespace(notes)
    ActiveRecord::Associations::Preloader.new(records: notes, associations: :namespace).call
  end

  def preload_max_access_for_authors(notes, project)
    return unless project

    user_ids = notes.map(&:author_id)
    access = project.team.max_member_access_for_user_ids(user_ids).select { |k, v| v == Gitlab::Access::NO_ACCESS }.keys
    project.team.contribution_check_for_user_ids(access)
  end

  def preload_noteable_for_regular_notes(notes)
    ActiveRecord::Associations::Preloader.new(records: notes.reject(&:for_commit?), associations: :noteable).call
  end

  def preload_author_status(notes)
    ActiveRecord::Associations::Preloader.new(records: notes, associations: { author: :status }).call
  end
end
==== ./autocomplete_sources/expires_in.rb ====
# frozen_string_literal: true

module AutocompleteSources
  module ExpiresIn
    extend ActiveSupport::Concern

    AUTOCOMPLETE_EXPIRES_IN = 3.minutes
    AUTOCOMPLETE_CACHED_ACTIONS = [:members, :labels].freeze

    included do
      before_action :set_expires_in, only: AUTOCOMPLETE_CACHED_ACTIONS
    end

    private

    def set_expires_in
      expires_in AUTOCOMPLETE_EXPIRES_IN
    end
  end
end
==== ./default_branch_protection.rb ====
# frozen_string_literal: true

module DefaultBranchProtection
  extend ActiveSupport::Concern

  def normalize_default_branch_params!(form_key)
    # The entity being configured will either be the instance or the group
    entity_settings_params = params[form_key]

    if Gitlab::Utils.to_boolean(entity_settings_params[:default_branch_protected]) == false
      entity_settings_params[:default_branch_protection_defaults] =
        ::Gitlab::Access::BranchProtection.protection_none

      return entity_settings_params
    end

    return entity_settings_params unless entity_settings_params.key?(:default_branch_protection_defaults)

    entity_settings_params.delete(:default_branch_protection_level)

    entity_settings_params[:default_branch_protection_defaults][:allowed_to_push].each do |entry|
      entry[:access_level] = entry[:access_level].to_i
    end

    entity_settings_params[:default_branch_protection_defaults][:allowed_to_merge].each do |entry|
      entry[:access_level] = entry[:access_level].to_i
    end

    [:allow_force_push, :code_owner_approval_required, :developer_can_initial_push].each do |key|
      next unless entity_settings_params[:default_branch_protection_defaults].key?(key)

      entity_settings_params[:default_branch_protection_defaults][key] =
        Gitlab::Utils.to_boolean(
          entity_settings_params[:default_branch_protection_defaults][key],
          default: ::Gitlab::Access::BranchProtection.protected_fully[key])
    end
  end
end
==== ./kas_cookie.rb ====
# frozen_string_literal: true

module KasCookie
  extend ActiveSupport::Concern

  included do
    content_security_policy_with_context do |p|
      next unless ::Gitlab::Kas::UserAccess.enabled?
      next unless Settings.gitlab.content_security_policy['enabled']

      next if URI(kas_url).host == ::Gitlab.config.gitlab.host # already allowed, no need for exception

      p.connect_src(*Array.wrap(p.directives['connect-src']), kas_ws_url.sub(%r{/?$}, '/'))
      p.connect_src(*Array.wrap(p.directives['connect-src']), kas_url.sub(%r{/?$}, '/'))
    end
  end

  def set_kas_cookie
    return unless ::Gitlab::Kas::UserAccess.enabled?

    public_session_id = Gitlab::Session.current&.id&.public_id
    return unless public_session_id

    cookie_data = ::Gitlab::Kas::UserAccess.cookie_data(public_session_id)

    cookies[::Gitlab::Kas::COOKIE_KEY] = cookie_data
  end

  private

  def kas_url
    ::Gitlab::Kas.tunnel_url
  end

  def kas_ws_url
    ::Gitlab::Kas.tunnel_ws_url
  end
end
==== ./project_stats_refresh_conflicts_guard.rb ====
# frozen_string_literal: true

module ProjectStatsRefreshConflictsGuard
  extend ActiveSupport::Concern

  def reject_if_build_artifacts_size_refreshing!
    return unless project.refreshing_build_artifacts_size?

    Gitlab::ProjectStatsRefreshConflictsLogger.warn_request_rejected_during_stats_refresh(project.id)

    render_409('Action temporarily disabled. The project this pipeline belongs to is undergoing stats refresh.')
  end
end
==== ./group_tree.rb ====
# frozen_string_literal: true

module GroupTree
  include Gitlab::Utils::StrongMemoize

  # rubocop:disable Gitlab/ModuleWithInstanceVariables
  # rubocop: disable CodeReuse/ActiveRecord
  def render_group_tree(groups)
    groups = groups.sort_by_attribute(@sort = safe_params[:sort])

    groups = if search_descendants?
               filtered_groups_with_ancestors(groups)
             elsif safe_params[:parent_id].present?
               groups.where(parent_id: safe_params[:parent_id]).page(safe_params[:page])
             else
               # If `safe_params[:parent_id]` is `nil`, we will only show root-groups
               groups.by_parent(nil).page(safe_params[:page])
             end

    @groups = groups.with_selects_for_list(archived: safe_params[:archived], active: safe_params[:active])

    respond_to do |format|
      format.html
      format.json do
        serializer = GroupChildSerializer.new(current_user: current_user)
                       .with_pagination(request, response)

        serializer.expand_hierarchy if search_descendants?

        render json: serializer.represent(@groups, {
          upto_preloaded_ancestors_only: inactive?
        })
      end
    end
    # rubocop:enable Gitlab/ModuleWithInstanceVariables
  end
  # rubocop: enable CodeReuse/ActiveRecord

  private

  # rubocop: disable CodeReuse/ActiveRecord
  def filtered_groups_with_ancestors(groups)
    filtered_groups = groups.search(safe_params[:filter]).page(safe_params[:page])

    # We find the ancestors by ID of the search results here.
    # Otherwise the ancestors would also have filters applied,
    # which would cause them not to be preloaded.
    #
    # Pagination needs to be applied before loading the ancestors to
    # make sure ancestors are not cut off by pagination.
    ancestors = Group.where(id: filtered_groups.select(:id)).self_and_ancestors
    ancestors = ancestors.self_or_ancestors_inactive if inactive?
    ancestors
  end
  # rubocop: enable CodeReuse/ActiveRecord

  def inactive?
    safe_params[:active] == false
  end

  def search_descendants?
    safe_params[:filter].present? || inactive?
  end

  def safe_params
    params.merge(
      active: Gitlab::Utils.to_boolean(params[:active]),
      archived: Gitlab::Utils.to_boolean(params[:archived], default: params[:archived])
    ).permit(:sort, :filter, :parent_id, :page, :archived, :active)
  end
  strong_memoize_attr :safe_params
end
==== ./requires_allowlisted_monitoring_client.rb ====
# frozen_string_literal: true

module RequiresAllowlistedMonitoringClient
  extend ActiveSupport::Concern

  included do
    before_action :validate_ip_allowlisted_or_valid_token!
  end

  private

  def validate_ip_allowlisted_or_valid_token!
    render_404 unless client_ip_allowlisted? || valid_token?
  end

  def client_ip_allowlisted?
    # Always allow developers to access http://localhost:3000/-/metrics for
    # debugging purposes
    return true if Rails.env.development? && request.local?

    ip_allowlist.any? { |e| e.include?(Gitlab::RequestContext.instance.client_ip) }
  end

  def ip_allowlist
    @ip_allowlist ||= compat_ip_allowlist
  end

  def valid_token?
    token = params[:token].presence || request.headers['TOKEN']
    token.present? &&
      ActiveSupport::SecurityUtils.secure_compare(
        token,
        Gitlab::CurrentSettings.health_check_access_token
      )
  end

  def render_404
    render "errors/not_found", layout: "errors", status: :not_found
  end

  def compat_ip_allowlist
    base = Settings.monitoring.ip_whitelist.map { |ip| IPAddr.new(ip) }

    # Add compatible addresses to match IPv4 allow list entries against IPv4 request IPs
    # that were mapped to IPv6 addresses on the kernel level.
    # https://docs.kernel.org/networking/ip-sysctl.html#proc-sys-net-ipv6-variables
    compats = base.select(&:ipv4?).map(&:ipv4_mapped)

    base + compats
  end
end
==== ./analytics/cycle_analytics/stage_actions.rb ====
# frozen_string_literal: true

module Analytics
  module CycleAnalytics
    module StageActions
      include Gitlab::Utils::StrongMemoize
      extend ActiveSupport::Concern

      included do
        extend ::Gitlab::Utils::Override
        include CycleAnalyticsParams

        before_action :validate_params, except: %i[index]
        before_action :authorize_stage, except: %i[index]
      end

      def index
        result = list_service.execute

        if result.success?
          render json: cycle_analytics_configuration(result.payload[:stages])
        else
          render json: { message: result.message }, status: result.http_status
        end
      end

      def median
        render json: { value: data_collector.median.seconds }
      end

      def average
        render json: { value: data_collector.average.seconds }
      end

      def records
        serialized_records = data_collector.serialized_records do |relation|
          add_pagination_headers(relation)
        end

        render json: serialized_records
      end

      def count
        render json: { count: data_collector.count }
      end

      private

      def namespace
        raise NotImplementedError
      end

      def authorize_stage
        raise NotImplementedError
      end

      def add_pagination_headers(relation)
        Gitlab::Pagination::OffsetHeaderBuilder.new(
          request_context: self,
          per_page: relation.limit_value,
          page: relation.current_page,
          next_page: relation.next_page,
          prev_page: relation.prev_page,
          params: permitted_cycle_analytics_params
        ).execute(exclude_total_headers: true, data_without_counts: true)
      end

      def stage
        @stage ||= ::Analytics::CycleAnalytics::StageFinder.new(parent: namespace, stage_id: params[:id]).execute
      end

      def data_collector
        @data_collector ||= Gitlab::Analytics::CycleAnalytics::DataCollector.new(
          stage: stage,
          params: request_params.to_data_collector_params
        )
      end

      def value_stream
        @value_stream ||= Analytics::CycleAnalytics::ValueStream.build_default_value_stream(namespace)
      end

      def list_params
        { value_stream: value_stream }
      end

      def list_service
        Analytics::CycleAnalytics::Stages::ListService.new(
          parent: namespace,
          current_user: current_user,
          params: list_params
        )
      end

      def cycle_analytics_configuration(stages)
        stage_presenters = stages.map { |s| ::Analytics::CycleAnalytics::StagePresenter.new(s) }

        Analytics::CycleAnalytics::ConfigurationEntity.new(stages: stage_presenters)
      end
    end
  end
end

Analytics::CycleAnalytics::StageActions.prepend_mod_with('Analytics::CycleAnalytics::StageActions')
==== ./analytics/cycle_analytics/value_stream_actions.rb ====
# frozen_string_literal: true

module Analytics
  module CycleAnalytics
    module ValueStreamActions
      extend ActiveSupport::Concern

      included do
        before_action :authorize
        # Defining the before action here, because in the EE module we cannot define a before_action.
        # Reason: this is a module which is being included into a controller. This module is extended in EE.
        before_action :authorize_modification, only: %i[create destroy update] # rubocop:disable Rails/LexicallyScopedActionFilter
      end

      def index
        # FOSS users can only see the default value stream
        value_streams = [Analytics::CycleAnalytics::ValueStream.build_default_value_stream(namespace)]

        render json: Analytics::CycleAnalytics::ValueStreamSerializer.new.represent(value_streams)
      end

      private

      def namespace
        raise NotImplementedError
      end

      def authorize
        authorize_read_cycle_analytics!
      end

      def authorize_modification
        # no-op, overridden in EE
      end
    end
  end
end

Analytics::CycleAnalytics::ValueStreamActions.prepend_mod_with('Analytics::CycleAnalytics::ValueStreamActions')
==== ./lfs_request.rb ====
# frozen_string_literal: true

# This concern assumes:
# - a `#container` accessor
# - a `#project` accessor
# - a `#user` accessor
# - a `#deploy_token` accessor
# - a `#authentication_result` accessor
# - a `#can?(object, action, subject)` method
# - a `#ci?` method
# - a `#download_request?` method
# - a `#upload_request?` method
# - a `#has_authentication_ability?(ability)` method
module LfsRequest
  extend ActiveSupport::Concern
  include Gitlab::Utils::StrongMemoize

  CONTENT_TYPE = 'application/vnd.git-lfs+json'

  included do
    before_action :require_lfs_enabled!
    before_action :lfs_check_access!
  end

  private

  def require_lfs_enabled!
    return if Gitlab.config.lfs.enabled

    render(
      json: {
        message: _('Git LFS is not enabled on this GitLab server, contact your admin.'),
        documentation_url: help_url
      },
      content_type: CONTENT_TYPE,
      status: :not_implemented
    )
  end

  def lfs_check_access!
    return render_lfs_not_found unless container&.lfs_enabled?
    return if download_request? && lfs_download_access?
    return if upload_request? && lfs_upload_access?

    # Only return a 403 response if the user has download access permission,
    # otherwise return a 404 to avoid exposing the existence of the container.
    if lfs_download_access?
      lfs_forbidden!
    else
      render_lfs_not_found
    end
  end

  def lfs_forbidden!
    render_lfs_forbidden
  end

  def render_lfs_forbidden
    render(
      json: {
        message: _('Access forbidden. Check your access level.'),
        documentation_url: help_url
      },
      content_type: CONTENT_TYPE,
      status: :forbidden
    )
  end

  def render_lfs_not_found
    render(
      json: {
        message: _('Not found.'),
        documentation_url: help_url
      },
      content_type: CONTENT_TYPE,
      status: :not_found
    )
  end

  def lfs_download_access?
    ci? || lfs_deploy_token? || user_can_download_code? || build_can_download_code? || deploy_token_can_download_code?
  end
  strong_memoize_attr :lfs_download_access?

  def deploy_token_can_download_code?
    deploy_token.present? &&
      deploy_token.has_access_to?(project) &&
      deploy_token.read_repository?
  end

  def lfs_upload_access?
    return false unless has_authentication_ability?(:push_code)
    return false if limit_exceeded?

    lfs_deploy_token? ||
      can?(user, :push_code, project) ||
      can?(deploy_token, :push_code, project) ||
      any_branch_allows_collaboration?
  end
  strong_memoize_attr :lfs_upload_access?

  def any_branch_allows_collaboration?
    project.merge_requests_allowing_push_to_user(user).any?
  end

  def lfs_deploy_token?
    authentication_result.lfs_deploy_token?(project)
  end

  def user_can_download_code?
    has_authentication_ability?(:download_code) && can?(user, :download_code, project)
  end

  def build_can_download_code?
    has_authentication_ability?(:build_download_code) && can?(user, :build_download_code, project)
  end

  def objects
    @objects ||= (params[:objects] || []).to_a
  end

  def objects_oids
    objects.map { |o| o['oid'].to_s }
  end

  def has_authentication_ability?(capability)
    (authentication_abilities || []).include?(capability)
  end

  # Overridden in EE
  def limit_exceeded?
    false
  end
end

LfsRequest.prepend_mod_with('LfsRequest')
==== ./uploads_actions.rb ====
# frozen_string_literal: true

module UploadsActions
  extend ActiveSupport::Concern
  include Gitlab::Utils::StrongMemoize
  include SendFileUpload

  # Starting with version 2, Markdown upload URLs use project / group IDs instead of paths
  ID_BASED_UPLOAD_PATH_VERSION = 2

  UPLOAD_MOUNTS = %w[avatar attachment file logo pwa_icon header_logo favicon screenshot].freeze

  # We need to avoid setting certain formats. For example, using the :js format
  # would trigger Rails' cross-origin JavaScript protection. To avoid this, we use
  # the :text format for JS files instead.
  CUSTOM_REQUEST_FORMAT_MAPPING = {
    js: :text
  }.freeze

  included do
    prepend_before_action :set_request_format_from_path_extension
    rescue_from FileUploader::InvalidSecret, with: :render_404

    rescue_from ::Gitlab::PathTraversal::PathTraversalAttackError do
      head :bad_request
    end
  end

  def create
    uploader = UploadService.new(model, params[:file], uploader_class, uploaded_by_user_id: current_user&.id).execute

    respond_to do |format|
      if uploader
        format.json do
          render json: { link: uploader.to_h }
        end
      else
        format.json do
          render json: _('Invalid file.'), status: :unprocessable_entity
        end
      end
    end
  end

  # This should either
  #   - send the file directly
  #   - or redirect to its URL
  #
  def show
    Gitlab::PathTraversal.check_path_traversal!(params[:filename])

    return render_404 unless uploader&.exists?

    ttl, directives = *cache_settings
    ttl ||= 0
    directives ||= { private: true, must_revalidate: true }

    expires_in ttl, directives

    file_uploader = [uploader, *uploader.versions.values].find do |version|
      version.filename == params[:filename]
    end

    return render_404 unless file_uploader

    workhorse_set_content_type!
    send_upload(file_uploader, attachment: file_uploader.filename, disposition: content_disposition)
  end

  def authorize
    set_workhorse_internal_api_content_type

    authorized = uploader_class.workhorse_authorize(
      has_length: false,
      maximum_size: Gitlab::CurrentSettings.max_attachment_size.megabytes.to_i)

    render json: authorized
  rescue SocketError
    render json: _("Error uploading file"), status: :internal_server_error
  end

  private

  # Based on ActionDispatch::Http::MimeNegotiation. We have an
  # initializer that monkey-patches this method out (so that repository
  # paths don't guess a format based on extension), but we do want this
  # behavior when serving uploads.
  def set_request_format_from_path_extension
    path = request.headers['action_dispatch.original_path'] || request.headers['PATH_INFO']
    match = path&.match(/\.(\w+)\z/)
    return unless match

    format = Mime[match.captures.first]

    return if format.blank?

    request.format = CUSTOM_REQUEST_FORMAT_MAPPING[format.symbol] || format.symbol
  end

  def content_disposition
    if uploader.embeddable? || uploader.pdf?
      'inline'
    else
      'attachment'
    end
  end

  def uploader_class
    raise NotImplementedError
  end

  def upload_mount
    mounted_as = params[:mounted_as]
    mounted_as if UPLOAD_MOUNTS.include?(mounted_as)
  end

  def uploader_mounted?
    upload_model_class < CarrierWave::Mount::Extension && !upload_mount.nil?
  end

  def uploader
    if uploader_mounted?
      model.public_send(upload_mount) # rubocop:disable GitlabSecurity/PublicSend
    else
      build_uploader_from_upload
    end
  end
  strong_memoize_attr :uploader

  # rubocop: disable CodeReuse/ActiveRecord
  def build_uploader_from_upload
    uploader = build_uploader
    return unless uploader

    upload_paths = uploader.upload_paths(params[:filename])
    upload = Upload.find_by(model: model, uploader: uploader_class.to_s, path: upload_paths)
    upload&.retrieve_uploader
  end
  # rubocop: enable CodeReuse/ActiveRecord

  def build_uploader
    return unless params[:secret] && params[:filename]

    uploader = uploader_class.new(model, secret: params[:secret])

    return unless uploader.model_valid?

    uploader
  end

  def embeddable?
    uploader && uploader.exists? && uploader.embeddable?
  end

  def bypass_auth_checks_on_uploads?
    return false if target_project && !target_project.public? && target_project.enforce_auth_checks_on_uploads?

    action_name == 'show' && embeddable?
  end

  def upload_version_at_least?(version)
    return unless uploader && uploader.upload

    uploader.upload.version >= version
  end

  def target_project
    nil
  end

  def find_model
    nil
  end

  def cache_settings
    []
  end

  def model
    find_model
  end
  strong_memoize_attr :model

  def workhorse_authorize_request?
    action_name == 'authorize'
  end
end
==== ./with_performance_bar.rb ====
# frozen_string_literal: true

module WithPerformanceBar
  extend ActiveSupport::Concern

  included do
    before_action :set_peek_enabled_for_current_request
  end

  private

  def set_peek_enabled_for_current_request
    Gitlab::SafeRequestStore.fetch(:peek_enabled) { cookie_or_default_value }
  end

  # Needed for Peek's routing to work;
  # Peek::ResultsController#restrict_non_access calls this method.
  def peek_enabled?
    Gitlab::PerformanceBar.enabled_for_request?
  end

  def cookie_or_default_value
    cookies[:perf_bar_enabled] = 'true' if cookies[:perf_bar_enabled].blank? && Rails.env.development?

    cookie_enabled = cookies[:perf_bar_enabled] == 'true'
    cookie_enabled && Gitlab::PerformanceBar.allowed_for_user?(current_user)
  end
end
==== ./known_sign_in.rb ====
# frozen_string_literal: true

module KnownSignIn
  include Gitlab::Utils::StrongMemoize
  include CookiesHelper

  KNOWN_SIGN_IN_COOKIE = :known_sign_in
  KNOWN_SIGN_IN_COOKIE_EXPIRY = 14.days

  private

  def verify_known_sign_in
    return unless Gitlab::CurrentSettings.notify_on_unknown_sign_in? && current_user

    notify_user unless known_device? || known_remote_ip?

    update_cookie
  end

  def known_remote_ip?
    known_ip_addresses.include?(request.remote_ip)
  end

  def known_device?
    cookies.encrypted[KNOWN_SIGN_IN_COOKIE] == current_user.id
  end

  def update_cookie
    set_secure_cookie(
      KNOWN_SIGN_IN_COOKIE,
      current_user.id,
      type: COOKIE_TYPE_ENCRYPTED,
      httponly: true,
      expires: KNOWN_SIGN_IN_COOKIE_EXPIRY
    )
  end

  def sessions
    ActiveSession.list(current_user).reject(&:is_impersonated)
  end
  strong_memoize_attr :sessions

  def known_ip_addresses
    [current_user.last_sign_in_ip, sessions.map(&:ip_address)].flatten
  end

  def notify_user
    request_info = Gitlab::Auth::VisitorLocation.new(request)
    current_user.notification_service.unknown_sign_in(
      current_user,
      request.remote_ip,
      current_user.current_sign_in_at,
      request_info
    )
  end
end
==== ./harbor/tag.rb ====
# frozen_string_literal: true

module Harbor
  module Tag
    def index
      respond_to do |format|
        format.json do
          tags
        end
      end
    end

    private

    def query_params
      params.permit(:repository_id, :artifact_id, :sort, :page, :limit)
    end

    def query
      Gitlab::Harbor::Query.new(container.harbor_integration, query_params)
    end

    def tags
      unless query.valid?
        return render(
          json: { message: 'Invalid parameters', errors: query.errors },
          status: :unprocessable_entity
        )
      end

      tags_json = ::Integrations::HarborSerializers::TagSerializer.new
                                  .with_pagination(request, response)
                                  .represent(query.tags)
      render json: tags_json
    end

    def container
      raise NotImplementedError
    end
  end
end
==== ./harbor/artifact.rb ====
# frozen_string_literal: true

module Harbor
  module Artifact
    def index
      respond_to do |format|
        format.json do
          artifacts
        end
      end
    end

    private

    def query_params
      params.permit(:repository_id, :search, :sort, :page, :limit)
    end

    def query
      Gitlab::Harbor::Query.new(container.harbor_integration, query_params)
    end

    def artifacts
      unless query.valid?
        return render(
          json: { message: 'Invalid parameters', errors: query.errors },
          status: :unprocessable_entity
        )
      end

      artifacts_json = ::Integrations::HarborSerializers::ArtifactSerializer.new
                                        .with_pagination(request, response)
                                        .represent(query.artifacts)
      render json: artifacts_json
    end

    def container
      raise NotImplementedError
    end
  end
end
==== ./harbor/access.rb ====
# frozen_string_literal: true

module Harbor
  module Access
    extend ActiveSupport::Concern

    included do
      before_action :authorize_read_harbor_registry!

      feature_category :integrations
    end

    private

    def authorize_read_harbor_registry!
      raise NotImplementedError
    end
  end
end
==== ./harbor/repository.rb ====
# frozen_string_literal: true

module Harbor
  module Repository
    def index
      respond_to do |format|
        format.html
        format.json do
          repositories
        end
      end
    end

    # The show action renders index to allow frontend routing to work on page refresh
    def show
      render :index
    end

    private

    def query_params
      params.permit(:search, :sort, :page, :limit)
    end

    def query
      Gitlab::Harbor::Query.new(container.harbor_integration, query_params)
    end

    def repositories
      unless query.valid?
        return render(
          json: { message: 'Invalid parameters', errors: query.errors },
          status: :unprocessable_entity
        )
      end

      repositories_json = ::Integrations::HarborSerializers::RepositorySerializer.new
                                        .with_pagination(request, response)
                                        .represent(
                                          query.repositories,
                                          url: container.harbor_integration.url,
                                          project_name: container.harbor_integration.project_name
                                        )
      render json: repositories_json
    end

    def container
      raise NotImplementedError
    end
  end
end
==== ./one_trust_csp.rb ====
# frozen_string_literal: true

module OneTrustCSP
  extend ActiveSupport::Concern

  included do
    content_security_policy do |policy|
      next unless helpers.one_trust_enabled?
      next unless policy.directives.present?

      default_script_src = policy.directives['script-src'] || policy.directives['default-src']
      script_src_values = Array.wrap(default_script_src) | ["'unsafe-eval'", 'https://cdn.cookielaw.org', 'https://*.onetrust.com']
      policy.script_src(*script_src_values)

      default_connect_src = policy.directives['connect-src'] || policy.directives['default-src']
      connect_src_values = Array.wrap(default_connect_src) | ['https://cdn.cookielaw.org', 'https://*.onetrust.com']
      policy.connect_src(*connect_src_values)
    end
  end
end
==== ./snippet_authorizations.rb ====
# frozen_string_literal: true

module SnippetAuthorizations
  extend ActiveSupport::Concern

  private

  def authorize_read_snippet!
    render_404 unless can?(current_user, :read_snippet, snippet)
  end

  def authorize_update_snippet!
    render_404 unless can?(current_user, :update_snippet, snippet)
  end

  def authorize_admin_snippet!
    render_404 unless can?(current_user, :admin_snippet, snippet)
  end

  def authorize_create_snippet!
    render_404 unless can?(current_user, :create_snippet)
  end
end
==== ./static_object_external_storage.rb ====
# frozen_string_literal: true

module StaticObjectExternalStorage
  extend ActiveSupport::Concern

  included do
    include ApplicationHelper
  end

  def redirect_to_external_storage
    return if external_storage_request?

    redirect_to external_storage_url_or_path(request.fullpath, project)
  end

  def external_storage_request?
    header_token = request.headers['X-Gitlab-External-Storage-Token']
    return false unless header_token.present?

    external_storage_token = Gitlab::CurrentSettings.static_objects_external_storage_auth_token
    ActiveSupport::SecurityUtils.secure_compare(header_token, external_storage_token) ||
      raise(Gitlab::Access::AccessDeniedError)
  end
end
==== ./oauth_applications.rb ====
# frozen_string_literal: true

module OauthApplications
  extend ActiveSupport::Concern

  CREATED_SESSION_KEY = :oauth_applications_created

  included do
    before_action :prepare_scopes, only: [:create, :update]
  end

  def prepare_scopes
    scopes = params.fetch(:doorkeeper_application, {}).fetch(:scopes, nil)

    params[:doorkeeper_application][:scopes] = scopes.join(' ') if scopes
  end

  def set_created_session
    session[CREATED_SESSION_KEY] = true
  end

  def get_created_session
    session.delete(CREATED_SESSION_KEY) || false
  end

  def load_scopes
    @scopes ||= Doorkeeper::OAuth::Scopes.from_array(
      Doorkeeper.configuration.scopes.to_a - [
        ::Gitlab::Auth::AI_WORKFLOW.to_s,
        ::Gitlab::Auth::DYNAMIC_USER.to_s,
        ::Gitlab::Auth::SELF_ROTATE_SCOPE.to_s,
        ::Gitlab::Auth::MCP_SCOPE.to_s
      ]
    )
  end

  def permitted_params
    %i[name redirect_uri scopes confidential]
  end

  def application_params
    params
      .require(:doorkeeper_application)
      .permit(*permitted_params)
  end
end
==== ./groups/params.rb ====
# frozen_string_literal: true

module Groups
  module Params
    extend ActiveSupport::Concern
    include DefaultBranchProtection

    private

    def group_params
      normalize_default_branch_params!(:group)
      params.require(:group).permit(group_params_attributes)
    end

    def group_params_attributes
      [
        :avatar,
        :description,
        :emails_disabled,
        :emails_enabled,
        :show_diff_preview_in_email,
        :mentions_disabled,
        :lfs_enabled,
        :name,
        :path,
        :public,
        :request_access_enabled,
        :share_with_group_lock,
        :visibility_level,
        :parent_id,
        :create_chat_team,
        :chat_team_name,
        :require_two_factor_authentication,
        :two_factor_grace_period,
        :enabled_git_access_protocol,
        :project_creation_level,
        :subgroup_creation_level,
        :default_branch_protection,
        { default_branch_protection_defaults: [
          :allow_force_push,
          :developer_can_initial_push,
          :code_owner_approval_required,
          {
            allowed_to_merge: [:access_level],
            allowed_to_push: [:access_level]
          }
        ] },
        :default_branch_name,
        :allow_mfa_for_subgroups,
        :resource_access_token_creation_allowed,
        :resource_access_token_notify_inherited,
        :lock_resource_access_token_notify_inherited,
        :prevent_sharing_groups_outside_hierarchy,
        :setup_for_company,
        :jobs_to_be_done,
        :crm_enabled,
        :crm_source_group_id,
        :force_pages_access_control,
        :enable_namespace_descendants_cache
      ] + [group_feature_attributes: group_feature_attributes]
    end

    def group_feature_attributes
      []
    end
  end
end

Groups::Params.prepend_mod
==== ./internal_redirect.rb ====
# frozen_string_literal: true

module InternalRedirect
  extend ActiveSupport::Concern

  def safe_redirect_path(path)
    return unless path
    # Verify that the string starts with a `/` and a known route character.
    return unless %r{\A/[-\w].*\z}.match?(path)

    uri = URI(path)
    # Ignore anything path of the redirect except for the path, querystring and,
    # fragment, forcing the redirect within the same host.
    full_path_for_uri(uri)
  rescue URI::InvalidURIError
    nil
  end

  def safe_redirect_path_for_url(url)
    return unless url

    uri = URI(url)
    safe_redirect_path(full_path_for_uri(uri)) if host_allowed?(uri)
  rescue URI::InvalidURIError
    nil
  end

  def sanitize_redirect(url_or_path)
    safe_redirect_path(url_or_path) || safe_redirect_path_for_url(url_or_path)
  end

  def host_allowed?(uri)
    uri.host == request.host &&
      uri.port == request.port
  end

  def full_path_for_uri(uri)
    path_with_query = [uri.path, uri.query].compact.join('?')
    [path_with_query, uri.fragment].compact.join("#")
  end

  def referer_path(request)
    return unless request.referer.presence

    URI(request.referer).path
  end
end

InternalRedirect.prepend_mod_with('InternalRedirect')
==== ./creates_commit.rb ====
# frozen_string_literal: true

module CreatesCommit
  extend ActiveSupport::Concern
  include Gitlab::Utils::StrongMemoize
  include SafeFormatHelper
  include ActionView::Helpers::SanitizeHelper

  # rubocop:disable Gitlab/ModuleWithInstanceVariables
  def create_commit(service, success_path:, failure_path:, failure_view: nil, success_notice: nil, target_project: nil)
    target_project ||= @project

    if user_access(target_project).can_push_to_branch?(branch_name_or_ref)
      @project_to_commit_into = target_project
      @different_project = false
      @branch_name ||= @ref
    else
      @project_to_commit_into = current_user.fork_of(target_project)
      @different_project = true
      @branch_name ||= generated_branch_name(@project_to_commit_into)
    end

    @start_branch ||= @ref || @branch_name

    commit_params = @commit_params.merge(
      start_project: @project_to_commit_into,
      start_branch: @start_branch,
      source_project: @project,
      target_project: target_project,
      branch_name: @branch_name
    )

    result = service.new(@project_to_commit_into, current_user, commit_params).execute

    if result[:status] == :success
      success_path = final_success_path(success_path, target_project)

      update_flash_notice(success_notice, success_path)

      respond_to do |format|
        format.html { redirect_to success_path }
        format.json { render json: { message: _("success"), filePath: success_path } }
      end
    else
      flash[:alert] = flash_message(result, @project, @branch_name, @commit_params)

      failure_path = failure_path.call if failure_path.respond_to?(:call)

      respond_to do |format|
        format.html do
          if failure_view
            render failure_view
          else
            redirect_to failure_path
          end
        end
        format.json do
          render json: {
            error: result[:message],
            filePath: failure_path
          }, status: :unprocessable_entity
        end
      end
    end
  end
  # rubocop:enable Gitlab/ModuleWithInstanceVariables

  def authorize_edit_tree!
    return if can_collaborate_with_project?(project, ref: branch_name_or_ref)

    access_denied!
  end

  def format_flash_notice(message)
    formatted_message = message.gsub("\n", "<br>")
    sanitize(formatted_message, tags: %w[br])
  end

  private

  def flash_message(result, project, branch_name, commit_params)
    if result[:status] == :error && commit_params[:revert]
      {
        message: format_flash_notice(result[:message]),
        button_text: _('Create merge request'),
        button_path: project_new_merge_request_path(
          project,
          merge_request: { source_branch: branch_name }
        )
      }
    else
      format_flash_notice(result[:message])
    end
  end

  def generated_branch_name(project)
    return unless project

    project.repository.next_branch('patch')
  end

  def update_flash_notice(success_notice, success_path)
    changes_link = ActionController::Base.helpers.link_to _('changes'), success_path, class: 'gl-link'

    default_message = safe_format(_("Your %{changes_link} have been committed successfully."),
      changes_link: changes_link)

    flash[:notice] = success_notice || default_message

    if create_merge_request?
      flash[:notice] =
        if merge_request_exists?
          nil
        else
          mr_message =
            if @different_project # rubocop:disable Gitlab/ModuleWithInstanceVariables
              _("You can now submit a merge request to get this change into the original project.")
            else
              _("You can now submit a merge request to get this change into the original branch.")
            end

          flash[:notice] += " #{mr_message}"
        end
    end
  end

  def final_success_path(success_path, target_project)
    if create_merge_request?
      merge_request_exists? ? existing_merge_request_path : new_merge_request_path(target_project)
    else
      success_path = success_path.call if success_path.respond_to?(:call)

      success_path
    end
  end

  # rubocop:disable Gitlab/ModuleWithInstanceVariables
  def new_merge_request_path(target_project)
    project_new_merge_request_path(
      @project_to_commit_into,
      merge_request: {
        target_project_id: @project_to_commit_into.default_merge_request_target.id,
        source_branch: @branch_name,
        target_branch: @start_branch
      }
    )
  end
  # rubocop:enable Gitlab/ModuleWithInstanceVariables

  def existing_merge_request_path
    project_merge_request_path(@project, @merge_request) # rubocop:disable Gitlab/ModuleWithInstanceVariables
  end

  # rubocop:disable Gitlab/ModuleWithInstanceVariables
  # rubocop: disable CodeReuse/ActiveRecord
  def merge_request_exists?
    MergeRequestsFinder.new(current_user, project_id: @project.id)
        .execute
        .opened
        .find_by(
          source_project_id: @project_to_commit_into,
          source_branch: @branch_name,
          target_branch: @start_branch)
  end
  strong_memoize_attr :merge_request_exists?
  # rubocop: enable CodeReuse/ActiveRecord
  # rubocop:enable Gitlab/ModuleWithInstanceVariables

  def create_merge_request?
    # Even if the field is set, if we're checking the same branch
    # as the target branch in the same project,
    # we don't want to create a merge request.
    # FIXME: We should use either 1 or true, not both.
    ActiveModel::Type::Boolean.new.cast(params[:create_merge_request]) &&
      (@different_project || @start_branch != @branch_name) # rubocop:disable Gitlab/ModuleWithInstanceVariables
  end

  def branch_name_or_ref
    @branch_name || @ref # rubocop:disable Gitlab/ModuleWithInstanceVariables
  end
end
==== ./send_file_upload.rb ====
# frozen_string_literal: true

module SendFileUpload
  def send_upload(
    file_upload, send_params: {}, redirect_params: {}, attachment: nil, proxy: false,
    disposition: 'attachment', ssrf_params: {})
    content_type = content_type_for(attachment)

    if attachment
      response_disposition = ActionDispatch::Http::ContentDisposition.format(disposition: disposition,
        filename: attachment)

      # Response-Content-Type will not override an existing Content-Type in
      # Google Cloud Storage, so the metadata needs to be cleared on GCS for
      # this to work. However, this override works with AWS.
      redirect_params[:query] = { "response-content-disposition" => response_disposition,
                                  "response-content-type" => content_type }
      # By default, Rails will send uploads with an extension of .js with a
      # content-type of text/javascript, which will trigger Rails'
      # cross-origin JavaScript protection.
      send_params[:content_type] = 'text/plain' if File.extname(attachment) == '.js'

      send_params.merge!(filename: attachment, disposition: disposition)
    end

    if image_scaling_request?(file_upload)
      location = file_upload.file_storage? ? file_upload.path : file_upload.url
      headers.store(*Gitlab::Workhorse.send_scaled_image(location, params[:width].to_i, content_type))
      head :ok
    elsif file_upload.file_storage?
      send_file file_upload.path, send_params
    elsif file_upload.proxy_download_enabled? || proxy
      headers.store(*Gitlab::Workhorse.send_url(file_upload.url(**redirect_params), **ssrf_params))
      head :ok
    else
      file_url = ObjectStorage::CDN::FileUrl.new(
        file: file_upload,
        ip_address: request.remote_ip,
        redirect_params: redirect_params)
      redirect_to file_url.url
    end
  end

  def content_type_for(attachment)
    return '' unless attachment

    ::Gitlab::Utils::MimeType.from_filename(attachment)
  end

  private

  def image_scaling_request?(file_upload)
    avatar_safe_for_scaling?(file_upload) || pwa_icon_safe_for_scaling?(file_upload)
  end

  def pwa_icon_safe_for_scaling?(file_upload)
    file_upload.try(:image_safe_for_scaling?) &&
      mounted_as_pwa_icon?(file_upload) &&
      valid_image_scaling_width?(Appearance::ALLOWED_PWA_ICON_SCALER_WIDTHS)
  end

  def avatar_safe_for_scaling?(file_upload)
    file_upload.try(:image_safe_for_scaling?) &&
      mounted_as_avatar?(file_upload) &&
      valid_image_scaling_width?(Avatarable::ALLOWED_IMAGE_SCALER_WIDTHS)
  end

  def mounted_as_avatar?(file_upload)
    file_upload.try(:mounted_as)&.to_sym == :avatar
  end

  def mounted_as_pwa_icon?(file_upload)
    file_upload.try(:mounted_as)&.to_sym == :pwa_icon
  end

  def valid_image_scaling_width?(allowed_scalar_widths)
    allowed_scalar_widths.include?(params[:width]&.to_i)
  end
end
==== ./issuable_collections_action.rb ====
# frozen_string_literal: true

module IssuableCollectionsAction
  extend ActiveSupport::Concern
  include IssuableCollections
  include IssuesCalendar

  included do
    before_action :check_search_rate_limit!, only: [:issues, :merge_requests, :search_merge_requests], if: -> {
      params[:search].present?
    }
  end

  # rubocop:disable Gitlab/ModuleWithInstanceVariables
  def issues
    respond_to do |format|
      format.html
      format.atom do
        @issues = issuables_collection
                  .non_archived
                  .page(params[:page])

        @issuable_meta_data = Gitlab::IssuableMetadata.new(current_user, @issues).data

        render layout: 'xml'
      end
    end
  end
  # rubocop:enable Gitlab/ModuleWithInstanceVariables

  def merge_requests
    render_merge_requests
  end

  def issues_calendar
    render_issues_calendar(issuables_collection)
  end

  private

  def sorting_field
    case action_name
    when 'issues'
      Issue::SORTING_PREFERENCE_FIELD
    when 'merge_requests', 'search_merge_requests'
      MergeRequest::SORTING_PREFERENCE_FIELD
    end
  end

  def finder_type
    case action_name
    when 'issues', 'issues_calendar'
      IssuesFinder
    when 'merge_requests', 'search_merge_requests'
      MergeRequestsFinder
    end
  end

  def finder_options
    issue_types = Issue::TYPES_FOR_LIST

    super.merge(
      non_archived: true,
      issue_types: issue_types
    )
  end

  # rubocop:disable Gitlab/ModuleWithInstanceVariables
  def render_merge_requests
    @merge_requests = issuables_collection.page(params[:page])

    @issuable_meta_data = Gitlab::IssuableMetadata.new(current_user, @merge_requests).data
  rescue ActiveRecord::QueryCanceled => exception # rubocop:disable Database/RescueQueryCanceled
    log_exception(exception)

    @search_timeout_occurred = true
  end
  # rubocop:enable Gitlab/ModuleWithInstanceVariables
end
==== ./integrations/params.rb ====
# frozen_string_literal: true

module Integrations
  module Params
    extend ActiveSupport::Concern

    ALLOWED_PARAMS_CE = [
      :app_store_issuer_id,
      :app_store_key_id,
      :app_store_private_key,
      :app_store_private_key_file_name,
      :app_store_protected_refs,
      :active,
      :alert_events,
      :api_key,
      :api_token,
      :api_url,
      :archive_trace_events,
      :bamboo_url,
      :branches_to_be_notified,
      :labels_to_be_notified,
      :labels_to_be_notified_behavior,
      :build_key,
      :build_type,
      :ca_pem,
      :channel,
      :channels,
      :color,
      :colorize_messages,
      :comment_on_event_enabled,
      :comment_detail,
      :confidential_issues_events,
      :confluence_url,
      :datadog_site,
      :datadog_env,
      :datadog_service,
      :datadog_tags,
      :datadog_ci_visibility,
      :default_irc_uri,
      :device,
      :disable_diffs,
      :diffblue_access_token_name,
      :diffblue_access_token_secret,
      :diffblue_license_key,
      :drone_url,
      :enable_ssl_verification,
      :exclude_service_accounts,
      :external_wiki_url,
      :google_play_protected_refs,
      :group_confidential_mention_events,
      :group_mention_events,
      :hostname,
      :incident_events,
      :inherit_from_id,
      # We're using `issues_events` and `merge_requests_events`
      # in the view so we still need to explicitly state them
      # here. `Service#event_names` would only give
      # `issue_events` and `merge_request_events` (singular!)
      # See app/helpers/services_helper.rb for how we
      # make those event names plural as special case.
      :issues_events,
      :issues_url,
      :jenkins_url,
      :jira_auth_type,
      :jira_issue_prefix,
      :jira_issue_regex,
      :jira_issue_transition_automatic,
      :jira_issue_transition_id,
      :jira_cloud_app_service_ids,
      :jira_cloud_app_enable_deployment_gating,
      :jira_cloud_app_deployment_gating_environments,
      :manual_configuration,
      :merge_requests_events,
      :mock_service_url,
      :namespace,
      :new_issue_url,
      :notify_only_broken_pipelines,
      :package_name,
      :password,
      :priority,
      :project_key,
      :project_name,
      :project_url,
      :recipients,
      :restrict_to_branch,
      :room,
      :send_from_committer_email,
      :server,
      :server_host,
      :server_port,
      :service_account_key,
      :service_account_key_file_name,
      :sound,
      :subdomain,
      :teamcity_url,
      :thread,
      :token,
      :type,
      :url,
      :user_key,
      :username,
      :webhook,
      :workspace_url,
      :zentao_product_xid
    ].freeze

    def integration_params
      dynamic_params = integration.event_channel_names + integration.event_names
      allowed = allowed_integration_params + dynamic_params
      return_value = params.permit(:id, integration: allowed, service: allowed)
      return_value[:integration] ||= return_value.delete(:service)
      param_values = return_value[:integration]

      if param_values.is_a?(ActionController::Parameters)
        if %w[update test].include?(action_name) && integration.chat?
          param_values.delete('webhook') if param_values['webhook'] == Base::ChatNotification::SECRET_MASK

          if integration.try(:mask_configurable_channels?)
            integration.event_channel_names.each do |channel|
              param_values.delete(channel) if param_values[channel] == Base::ChatNotification::SECRET_MASK
            end
          end
        end

        integration.secret_fields.each do |param|
          param_values.delete(param) if param_values[param].blank?
        end
      end

      return_value
    end

    def allowed_integration_params
      ALLOWED_PARAMS_CE
    end
  end
end

Integrations::Params.prepend_mod_with('Integrations::Params')
==== ./integrations/slack_controller_settings.rb ====
# frozen_string_literal: true

# Shared concern for controllers to handle editing the GitLab for Slack app
# integration at project, group and instance-levels.
#
# Controllers should define these methods:
# - `#integration` to return the Integrations::GitLabSlackApplication record.
# - `#redirect_to_integration_page` to redirect to the integration edit page.
# - `#installation_service` to return a service class to handle the OAuth flow.
module Integrations
  module SlackControllerSettings
    extend ActiveSupport::Concern

    included do
      feature_category :integrations

      before_action :handle_oauth_error, only: :slack_auth
      before_action :check_oauth_state, only: :slack_auth
    end

    def slack_auth
      result = installation_service.execute

      flash[:alert] = result.message if result.error?

      session[:slack_install_success] = result.success?
      redirect_to_integration_page
    end

    def destroy
      slack_integration.destroy

      PropagateIntegrationWorker.perform_async(integration.id) unless integration.project_level?

      redirect_to_integration_page
    end

    private

    def slack_integration
      @slack_integration ||= integration.slack_integration
    end

    def handle_oauth_error
      return unless params[:error] == 'access_denied'

      flash[:alert] = s_('SlackIntegration|Access request canceled')
      redirect_to_integration_page
    end

    def check_oauth_state
      render_403 unless valid_authenticity_token?(session, params[:state])

      true
    end
  end
end
==== ./integrations/actions.rb ====
# frozen_string_literal: true

module Integrations::Actions
  extend ActiveSupport::Concern

  included do
    include Integrations::Params
    include IntegrationsHelper

    # :overrides is defined in Admin:IntegrationsController
    # rubocop:disable Rails/LexicallyScopedActionFilter
    before_action :ensure_integration_enabled, only: [:edit, :update, :overrides, :test]
    before_action :integration, only: [:edit, :update, :overrides, :test]
    # rubocop:enable Rails/LexicallyScopedActionFilter

    before_action :render_404, only: [:edit, :update, :overrides, :test], if: -> do
      integration.is_a?(::Integrations::Prometheus) && Feature.enabled?(:remove_monitor_metrics)
    end

    urgency :low, [:test]
  end

  def edit
    render 'shared/integrations/edit'
  end

  def update
    saved = integration.update(integration_params[:integration])

    respond_to do |format|
      format.html do
        if saved
          PropagateIntegrationWorker.perform_async(integration.id)
          redirect_to scoped_edit_integration_path(integration, project: integration.project, group: integration.group),
            notice: success_message
        else
          render 'shared/integrations/edit'
        end
      end

      format.json do
        status = saved ? :ok : :unprocessable_entity

        render json: serialize_as_json, status: status
      end
    end
  end

  def test
    if integration.testable?
      render json: integration_test_response, status: :ok
    else
      render json: {}, status: :not_found
    end
  end

  def reset
    if integration.manual_activation?
      integration.destroy!

      flash[:notice] = s_('Integrations|This integration, and inheriting projects were reset.')

      render json: {}, status: :ok
    else
      render json: { message: s_('Integrations|Integration cannot be reset.') }, status: :unprocessable_entity
    end
  end

  private

  def integration
    @integration ||= find_or_initialize_non_project_specific_integration(params[:id])
  end

  def ensure_integration_enabled
    render_404 unless integration
  end

  def success_message
    if integration.active?
      format(s_('Integrations|%{integration} settings saved and active.'), integration: integration.title)
    else
      format(s_('Integrations|%{integration} settings saved, but not active.'), integration: integration.title)
    end
  end

  def serialize_as_json
    integration
      .as_json(only: integration.json_fields)
      .merge(errors: integration.errors.as_json)
  end

  def integration_test_response
    integration.assign_attributes(integration_params[:integration])

    result = if integration.project_level?
               ::Integrations::Test::ProjectService.new(integration, current_user, params[:event]).execute
             elsif integration.group_level?
               ::Integrations::Test::GroupService.new(integration, current_user, params[:event]).execute
             else
               {}
             end

    unless result[:success]
      return {
        error: true,
        message: s_('Integrations|Connection failed. Check your integration settings.'),
        service_response: result[:result].to_s,
        test_failed: true
      }
    end

    result[:data].presence || {}
  end
end
==== ./renders_blob.rb ====
# frozen_string_literal: true

module RendersBlob
  extend ActiveSupport::Concern

  def blob_viewer_json(blob)
    viewer = case params[:viewer]
             when 'rich' then blob.rich_viewer
             when 'auxiliary' then blob.auxiliary_viewer
             when 'none' then nil
             else blob.simple_viewer
             end

    return {} unless viewer

    {
      html: view_to_html_string("projects/blob/_viewer", viewer: viewer, load_async: false)
    }
  end

  def render_blob_json(blob)
    json = blob_viewer_json(blob)
    return render_404 unless json.present?

    render json: json
  end

  def conditionally_expand_blob(blob)
    conditionally_expand_blobs([blob])
  end

  def conditionally_expand_blobs(blobs)
    return unless params[:expanded] == 'true'

    blobs.each(&:expand!)
  end
end
==== ./enforces_step_up_authentication.rb ====
# frozen_string_literal: true

# Enforces step-up authentication requirements for admin access
#
# This controller concern ensures users complete step-up authentication
# before accessing admin functionality. Include this module in admin
# controllers to enforce the authentication check.
#
# @example
#   class Admin::ApplicationController < ApplicationController
#     include EnforcesStepUpAuthentication
#   end
module EnforcesStepUpAuthentication
  extend ActiveSupport::Concern

  included do
    before_action :enforce_step_up_authentication
  end

  private

  def enforce_step_up_authentication
    return if Feature.disabled?(:omniauth_step_up_auth_for_admin_mode, current_user)

    return if step_up_auth_disabled_for_admin_mode?
    return if step_up_auth_flow_state_success?

    handle_failed_authentication
  end

  def step_up_auth_disabled_for_admin_mode?
    !::Gitlab::Auth::Oidc::StepUpAuthentication.enabled_by_config?
  end

  def step_up_auth_flow_state_success?
    ::Gitlab::Auth::Oidc::StepUpAuthentication.succeeded?(session)
  end

  def handle_failed_authentication
    # We need to disable (reset) the admin mode in order to redirect the user to the admin login page.
    # If we do not do this, the Admin::SessionsController will thinks that the admin mode has been successfully reached
    # and will redirect the user to the path 'admin/dashboard'. But, the check in this EnforceStepUpAuthentication
    # will fail again and redirect the user to the login page which will end up in a loop.
    disable_admin_mode

    redirect_to(new_admin_session_path, notice: _('Step-up auth not successful'))
  end

  def disable_admin_mode
    current_user_mode.disable_admin_mode! if current_user_mode.admin_mode?
  end
end
==== ./search_rate_limitable.rb ====
# frozen_string_literal: true

module SearchRateLimitable
  extend ActiveSupport::Concern

  private

  def check_search_rate_limit!
    if current_user
      # Because every search in the UI typically runs concurrent searches with different
      # scopes to get counts, we apply rate limits on the search scope if it is present.
      #
      # If abusive search is detected, we have stricter limits and ignore the search scope.
      check_rate_limit!(:search_rate_limit, scope: [current_user, safe_search_scope].compact,
        users_allowlist: Gitlab::CurrentSettings.current_application_settings.search_rate_limit_allowlist)
    else
      check_rate_limit!(:search_rate_limit_unauthenticated, scope: [request.ip])
    end
  end

  def safe_search_scope
    # Sometimes search scope can have abusive length or invalid keyword. We don't want
    # to send those to redis for rate limit checks, so we guard against that here.
    params[:scope] unless Gitlab::Search::Params.new(params).abusive?
  end
end
==== ./synchronize_broadcast_message_dismissals.rb ====
# frozen_string_literal: true

module SynchronizeBroadcastMessageDismissals
  extend ActiveSupport::Concern

  def synchronize_broadcast_message_dismissals(user)
    Users::BroadcastMessageDismissalFinder.new(user).execute
      .find_each do |dismissal|
      create_dismissal_cookie(dismissal) if cookies[dismissal.cookie_key].blank?
    end
  end

  private

  def create_dismissal_cookie(dismissal)
    cookies[dismissal.cookie_key] = { value: true, expires: dismissal.expires_at }
  end
end
==== ./preview_markdown.rb ====
# frozen_string_literal: true

module PreviewMarkdown
  extend ActiveSupport::Concern

  def preview_markdown
    result = PreviewMarkdownService.new(
      container: resource_parent,
      current_user: current_user,
      params: markdown_service_params
    ).execute do |text|
      view_context.markdown(text, markdown_context_params)
    end

    render json: {
      body: result[:rendered_html],
      references: {
        users: result[:users],
        suggestions: SuggestionSerializer.new.represent_diff(result[:suggestions]),
        commands: view_context.markdown(result[:commands])
      }
    }
  end

  private

  def resource_parent
    @project
  end

  def projects_filter_params
    {
      issuable_reference_expansion_enabled: true,
      suggestions_filter_enabled: params[:preview_suggestions].present?
    }
  end

  def timeline_events_filter_params
    {
      issuable_reference_expansion_enabled: true,
      pipeline: :'incident_management/timeline_event'
    }
  end

  def wikis_filter_params
    {
      pipeline: :wiki,
      wiki: wiki,
      page_slug: params[:id],
      repository: wiki.repository,
      issuable_reference_expansion_enabled: true
    }
  end

  def markdown_service_params
    params
  end

  def markdown_context_params
    case controller_name
    when 'wikis'
      wiki_page = wiki.find_page(params[:id])

      wikis_filter_params
    when 'snippets'        then { skip_project_check: true }
    when 'groups'          then { group: group, issuable_reference_expansion_enabled: true }
    when 'projects'        then projects_filter_params
    when 'timeline_events' then timeline_events_filter_params
    when 'organizations'   then { pipeline: :description }
    else {}
    end.merge(
      requested_path: params[:path] || wiki_page&.path,
      ref: params[:ref],
      # Disable comments in markdown for IE browsers because comments in IE
      # could allow script execution.
      allow_comments: !browser.ie?
    )
  end
end
==== ./toggle_subscription_action.rb ====
# frozen_string_literal: true

module ToggleSubscriptionAction
  extend ActiveSupport::Concern

  def toggle_subscription
    return unless current_user

    subscribable_resource.toggle_subscription(current_user, subscribable_project)

    head :ok
  end

  private

  def subscribable_project
    @project ||= raise(NotImplementedError)
  end

  def subscribable_resource
    raise NotImplementedError
  end
end
==== ./boards_actions.rb ====
# frozen_string_literal: true

module BoardsActions
  include Gitlab::Utils::StrongMemoize
  extend ActiveSupport::Concern

  included do
    before_action :authorize_read_board!, only: [:index, :show]
    before_action :redirect_to_recent_board, only: [:index]
    before_action :board, only: [:index, :show]
    before_action :push_licensed_features, only: [:index, :show]
  end

  def index
    # if no board exists, create one
    @board = board_create_service.execute.payload unless board # rubocop:disable Gitlab/ModuleWithInstanceVariables
  end

  def show
    return render_404 unless board

    # Add / update the board in the recent visits table
    board_visit_service.new(parent, current_user).execute(board)
  end

  private

  def redirect_to_recent_board
    return if !parent.multiple_issue_boards_available? || !latest_visited_board

    redirect_to board_path(latest_visited_board.board)
  end

  def latest_visited_board
    @latest_visited_board ||= Boards::VisitsFinder.new(parent, current_user).latest
  end

  # Noop on FOSS
  def push_licensed_features; end

  def board
    board_finder.execute.first
  end
  strong_memoize_attr :board

  def board_visit_service
    Boards::Visits::CreateService
  end

  def parent
    group? ? group : project
  end
  strong_memoize_attr :parent

  def board_path(board)
    if group?
      group_board_path(parent, board)
    else
      project_board_path(parent, board)
    end
  end

  def group?
    instance_variable_defined?(:@group)
  end
end

BoardsActions.prepend_mod_with('BoardsActions')
==== ./renders_ldap_servers.rb ====
# frozen_string_literal: true

module RendersLdapServers
  extend ActiveSupport::Concern

  included do
    helper_method :ldap_servers
  end

  def ldap_servers
    @ldap_servers ||= if Gitlab::Auth::Ldap::Config.sign_in_enabled?
                        Gitlab::Auth::Ldap::Config.available_servers
                      else
                        []
                      end
  end
end
==== ./enforces_two_factor_authentication.rb ====
# frozen_string_literal: true

# == EnforcesTwoFactorAuthentication
#
# Controller concern to enforce two-factor authentication requirements
#
# Upon inclusion, adds `check_two_factor_requirement` as a before_action,
# and makes `two_factor_grace_period_expired?` and `two_factor_skippable?`
# available as view helpers.
module EnforcesTwoFactorAuthentication
  extend ActiveSupport::Concern

  included do
    before_action :check_two_factor_requirement, except: [:route_not_found]

    # to include this in controllers inheriting from `ActionController::Metal`
    # we need to add this block
    helper_method :two_factor_grace_period_expired?, :two_factor_skippable? if respond_to?(:helper_method)
  end

  def check_two_factor_requirement
    return unless respond_to?(:current_user)

    if two_factor_authentication_required? && current_user_requires_two_factor?
      case self
      when GraphqlController
        render_error(
          format(
            _("Authentication error: enable 2FA in your profile settings to continue using GitLab: %{mfa_help_page}"),
            mfa_help_page: mfa_help_page_url
          ),
          status: :unauthorized
        )
      else
        redirect_to profile_two_factor_auth_path
      end
    end
  end

  def two_factor_authentication_required?
    two_factor_verifier.two_factor_authentication_required?
  end

  def current_user_requires_two_factor?
    two_factor_verifier.current_user_needs_to_setup_two_factor? && !skip_two_factor?
  end

  # rubocop: disable CodeReuse/ActiveRecord
  def execute_action_for_2fa_reason(actions)
    reason = two_factor_verifier.two_factor_authentication_reason
    groups_enforcing_two_factor = current_user.source_groups_of_two_factor_authentication_requirement
                                              .reorder(name: :asc)
    actions[reason].call(groups_enforcing_two_factor)
  end
  # rubocop: enable CodeReuse/ActiveRecord

  def two_factor_grace_period
    two_factor_verifier.two_factor_grace_period
  end

  def two_factor_grace_period_expired?
    two_factor_verifier.two_factor_grace_period_expired?
  end

  def two_factor_skippable?
    two_factor_authentication_required? &&
      !current_user.two_factor_enabled? &&
      !two_factor_grace_period_expired?
  end

  def skip_two_factor?
    session[:skip_two_factor] && session[:skip_two_factor].future?
  end

  def two_factor_verifier
    @two_factor_verifier ||= Gitlab::Auth::TwoFactorAuthVerifier.new(current_user, request)
  end

  def mfa_help_page_url
    Rails.application.routes.url_helpers.help_page_url(
      'user/profile/account/two_factor_authentication.md',
      anchor: 'enable-two-factor-authentication'
    )
  end
end

EnforcesTwoFactorAuthentication.prepend_mod_with('EnforcesTwoFactorAuthentication')
==== ./project_unauthorized.rb ====
# frozen_string_literal: true

module ProjectUnauthorized
  module ControllerActions
    def self.on_routable_not_found
      ->(routable, full_path) do
        return unless routable.is_a?(Project)

        label = routable.external_authorization_classification_label
        rejection_reason = nil

        unless ::Gitlab::ExternalAuthorization.access_allowed?(current_user, label)
          rejection_reason = ::Gitlab::ExternalAuthorization.rejection_reason(current_user, label)
          rejection_reason ||= _('External authorization denied access to this project')
        end

        access_denied!(rejection_reason) if rejection_reason
      end
    end
  end
end
==== ./checks_collaboration.rb ====
# frozen_string_literal: true

module ChecksCollaboration
  def can_collaborate_with_project?(project, ref: nil)
    return true if can?(current_user, :push_code, project)

    can_create_merge_request =
      can?(current_user, :create_merge_request_in, project) &&
      current_user.already_forked?(project)

    can_create_merge_request ||
      user_access(project).can_push_to_branch?(ref)
  end

  # rubocop:disable Gitlab/ModuleWithInstanceVariables
  # enabling this so we can easily cache the user access value as it might be
  # used across multiple calls in the view
  def user_access(project)
    @user_access ||= {}
    @user_access[project] ||= Gitlab::UserAccess.new(current_user, container: project)
  end
  # rubocop:enable Gitlab/ModuleWithInstanceVariables
end
==== ./static_object_external_storage_csp.rb ====
# frozen_string_literal: true

module StaticObjectExternalStorageCSP
  extend ActiveSupport::Concern

  included do
    content_security_policy do |p|
      next if p.directives.blank?
      next unless Gitlab::CurrentSettings.static_objects_external_storage_enabled?

      default_connect_src = p.directives['connect-src'] || p.directives['default-src']
      connect_src_values =
        Array.wrap(default_connect_src) | [Gitlab::CurrentSettings.static_objects_external_storage_url]
      p.connect_src(*connect_src_values)
    end
  end
end
==== ./sessionless_authentication.rb ====
# frozen_string_literal: true

# == SessionlessAuthentication
#
# Controller concern to handle PAT, RSS, and static objects token authentication methods
#
module SessionlessAuthentication
  # This filter handles personal access tokens, atom requests with rss tokens, and static object tokens
  def authenticate_sessionless_user!(request_format)
    user = request_authenticator.find_sessionless_user(request_format)
    sessionless_sign_in(user) if user
  end

  def request_authenticator
    @request_authenticator ||= Gitlab::Auth::RequestAuthenticator.new(request)
  end

  def sessionless_user?
    current_user && @sessionless_sign_in # rubocop:disable Gitlab/ModuleWithInstanceVariables -- This is only used within this module
  end

  def sessionless_sign_in(user)
    @sessionless_sign_in = true # rubocop:disable Gitlab/ModuleWithInstanceVariables -- This is only used within this module

    if user.can_log_in_with_non_expired_password?
      # Notice we are passing store false, so the user is not
      # actually stored in the session and a token is needed
      # for every request. If you want the token to work as a
      # sign in token, you can simply remove store: false.
      sign_in(user, store: false, message: :sessionless_sign_in)
    elsif request_authenticator.can_sign_in_bot?(user)
      # we suppress callbacks to avoid redirecting the bot
      sign_in(user, store: false, message: :sessionless_sign_in, run_callbacks: false)
    end
  end

  def sessionless_bypass_admin_mode!(&block)
    return yield unless Gitlab::CurrentSettings.admin_mode

    Gitlab::Auth::CurrentUserMode.bypass_session!(current_user.id, &block)
  end
end
==== ./packages_access.rb ====
# frozen_string_literal: true

module PackagesAccess
  extend ActiveSupport::Concern

  included do
    before_action :verify_packages_enabled!
    before_action :verify_read_package!
  end

  private

  def verify_packages_enabled!
    render_404 unless Gitlab.config.packages.enabled
  end

  def verify_read_package!
    access_denied! unless can?(current_user, :read_package, project&.packages_policy_subject)
  end
end
==== ./snippets_actions.rb ====
# frozen_string_literal: true

module SnippetsActions
  extend ActiveSupport::Concern

  include RendersNotes
  include RendersBlob
  include PaginatedCollection
  include Gitlab::NoteableMetadata
  include Snippets::SendBlob
  include SnippetsSort
  include ProductAnalyticsTracking

  included do
    skip_before_action :verify_authenticity_token,
      if: -> { action_name == 'show' && js_request? }

    track_event :show, name: 'i_snippets_show'

    respond_to :html
  end

  def edit; end

  # This endpoint is being replaced by Snippets::BlobController#raw
  # Support for old raw links will be maintainted via this action but
  # it will only return the first blob found,
  # see: https://gitlab.com/gitlab-org/gitlab/-/issues/217775
  def raw
    workhorse_set_content_type!

    # Until we don't migrate all snippets to version
    # snippets we need to support old `SnippetBlob`
    # blobs
    if defined?(blob.snippet)
      send_data(
        convert_line_endings(blob.data),
        type: 'text/plain; charset=utf-8',
        disposition: content_disposition,
        filename: Snippet.sanitized_file_name(blob.name)
      )
    else
      send_snippet_blob(snippet, blob)
    end
  end

  def js_request?
    request.format.js?
  end

  # rubocop:disable Gitlab/ModuleWithInstanceVariables
  def show
    respond_to do |format|
      format.html do
        @note = Note.new(noteable: @snippet, project: @snippet.project)
        @noteable = @snippet

        @discussions = @snippet.discussions
        @notes = prepare_notes_for_rendering(@discussions.flat_map(&:notes))
        render 'show'
      end

      format.js do
        if @snippet.embeddable?
          conditionally_expand_blobs(blobs)

          render 'shared/snippets/show'
        else
          head :not_found
        end
      end
    end
  end
  # rubocop:enable Gitlab/ModuleWithInstanceVariables

  private

  def blob
    @blob ||= blobs.first
  end

  def blobs
    @blobs ||= if snippet.empty_repo?
                 [snippet.blob]
               else
                 snippet.blobs
               end
  end

  def convert_line_endings(content)
    params[:line_ending] == 'raw' ? content : content.gsub(/\r\n/, "\n")
  end
end
==== ./continue_params.rb ====
# frozen_string_literal: true

module ContinueParams
  include InternalRedirect
  extend ActiveSupport::Concern

  def continue_params
    continue_params = params[:continue]
    return {} unless continue_params

    continue_params = continue_params.permit(:to, :notice, :notice_now)
    continue_params[:to] = safe_redirect_path(continue_params[:to])

    continue_params
  end
end
==== ./renders_projects_list.rb ====
# frozen_string_literal: true

module RendersProjectsList
  include RendersMemberAccess

  def prepare_projects_for_rendering(projects)
    preload_max_member_access_for_collection(Project, projects)
    preload_member_roles(projects) if current_user

    # Call the count methods on every project, so the BatchLoader would load them all at
    # once when the entities are rendered
    projects.each(&:forks_count)
    projects.each(&:open_issues_count)
    projects.each(&:open_merge_requests_count)

    projects
  end

  def preload_member_roles(projects)
    # overridden in EE
  end
end

RendersProjectsList.prepend_mod
==== ./routable_actions.rb ====
# frozen_string_literal: true

module RoutableActions
  extend ActiveSupport::Concern

  def find_routable!(routable_klass, routable_full_path, full_path, extra_authorization_proc: nil)
    routable = routable_klass.find_by_full_path(routable_full_path, follow_redirects: request.get?)
    if routable_authorized?(routable, extra_authorization_proc)
      ensure_canonical_path(routable, routable_full_path)
      routable
    else
      perform_not_found_actions(routable, not_found_actions, full_path)

      route_not_found unless performed?

      nil
    end
  end

  def not_found_actions
    [ProjectUnauthorized::ControllerActions.on_routable_not_found]
  end

  def perform_not_found_actions(routable, actions, full_path)
    actions.each do |action|
      break if performed?

      instance_exec(routable, full_path, &action)
    end
  end

  def routable_authorized?(routable, extra_authorization_proc)
    return false unless routable

    action = :"read_#{routable.class.to_s.underscore}"
    return false unless can?(current_user, action, routable)

    if extra_authorization_proc
      extra_authorization_proc.call(routable)
    else
      true
    end
  end

  def ensure_canonical_path(routable, routable_full_path)
    return unless request.get?

    canonical_path = routable.full_path
    return unless canonical_path != routable_full_path

    if !request.xhr? && request.format.html? && canonical_path.casecmp(routable_full_path) != 0
      flash[:notice] =
        <<~HEREDOC.squish
        #{routable.class.to_s.titleize} '#{routable_full_path}' was moved to '#{canonical_path}'.
        Please update any links and bookmarks that may still have the old path.
        HEREDOC
    end

    redirect_to build_canonical_path(routable), status: :moved_permanently
  rescue ActionController::UrlGenerationError
    route_not_found
  end
end

RoutableActions.prepend_mod_with('RoutableActions')
==== ./diff_for_path.rb ====
# frozen_string_literal: true

module DiffForPath
  extend ActiveSupport::Concern

  def render_diff_for_path(diffs)
    diff_file = diffs.diff_files.find do |diff|
      diff.file_identifier == params[:file_identifier]
    end

    return render_404 unless diff_file

    render json: { html: view_to_html_string('projects/diffs/_content', diff_file: diff_file) }
  end
end
==== ./spammable_actions/captcha_check/common.rb ====
# frozen_string_literal: true

module SpammableActions
  module CaptchaCheck
    module Common
      extend ActiveSupport::Concern

      private

      def with_captcha_check_common(spammable:, captcha_render_lambda:, &block)
        # If the Spammable indicates that CAPTCHA is not necessary (either due to it not being flagged
        # as spam, or if spam/captcha is disabled for some reason), then we will go ahead and
        # yield to the block containing the action's original behavior, then return.
        return yield unless spammable.render_recaptcha?

        # If we got here, we need to render the CAPTCHA instead of yielding to action's original
        # behavior. We will present a CAPTCHA to be solved by executing the lambda which was passed
        # as the `captcha_render_lambda:` argument. This lambda contains either the HTML-specific or
        # JSON-specific behavior to cause the CAPTCHA modal to be rendered.
        Gitlab::Recaptcha.load_configurations!
        captcha_render_lambda.call
      end
    end
  end
end
==== ./spammable_actions/captcha_check/rest_api_actions_support.rb ====
# frozen_string_literal: true

# This module should be included to support CAPTCHA check for REST API actions via Grape.
#
# If the request is directly handled by a controller action, then the corresponding module which
# supports HTML or JSON formats should be used instead.
module SpammableActions::CaptchaCheck::RestApiActionsSupport
  extend ActiveSupport::Concern
  include SpammableActions::CaptchaCheck::Common
  include Spam::Concerns::HasSpamActionResponseFields

  private

  def with_captcha_check_rest_api(spammable:, &block)
    # In the case of the REST API, the request is handled by Grape, so if there is a spam-related
    # error, we don't render directly, instead we will pass the error message and other necessary
    # fields to the Grape api error helper for it to handle.
    captcha_render_lambda = -> do
      fields = spam_action_response_fields(spammable)

      fields.delete :spam
      # NOTE: "409 - Conflict" seems to be the most appropriate HTTP status code for a response
      # which requires a CAPTCHA to be solved in order for the request to be resubmitted.
      # https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.10
      status = 409

      # NOTE: This nested 'error' key may not be consistent with all other API error responses,
      # because they are not currently consistent across different API endpoints
      # and models. Some (snippets) will nest errors in an errors key like this,
      # while others (issues) will return the model's errors hash without an errors key,
      # while still others just return a plain string error.
      # See https://gitlab.com/groups/gitlab-org/-/epics/5527#revisit-inconsistent-shape-of-error-responses-in-rest-api
      fields[:message] = { error: spammable.errors.full_messages.to_sentence }
      render_structured_api_error!(fields, status)
    end

    with_captcha_check_common(spammable: spammable, captcha_render_lambda: captcha_render_lambda, &block)
  end
end
==== ./spammable_actions/captcha_check/html_format_actions_support.rb ====
# frozen_string_literal: true

# This module should *ONLY* be included if needed to support forms submits with HTML MIME type.
# In other words, forms handled by actions which use a `respond_to` of `format.html`.
#
# If the request is handled by actions via `format.json`, for example, for all Javascript based form
# submissions and Vue components which use Apollo and Axios, then the corresponding module
# which supports JSON format should be used instead.
module SpammableActions::CaptchaCheck::HtmlFormatActionsSupport
  extend ActiveSupport::Concern
  include SpammableActions::CaptchaCheck::Common

  included do
    before_action :convert_html_spam_params_to_headers, only: [:create, :update]
  end

  private

  def with_captcha_check_html_format(spammable:, &block)
    captcha_render_lambda = -> { render :captcha_check }
    with_captcha_check_common(spammable: spammable, captcha_render_lambda: captcha_render_lambda, &block)
  end

  # Convert spam/CAPTCHA values from form field params to headers, because all spam-related services
  # expect these values to be passed as headers.
  #
  # The 'g-recaptcha-response' field name comes from `Recaptcha::Adapters::ViewMethods#recaptcha_tags` in the
  # recaptcha gem. This is a field which is automatically included by calling the
  # `#recaptcha_tags` method within a HAML template's form.
  def convert_html_spam_params_to_headers
    return unless params['g-recaptcha-response'] || params[:spam_log_id]

    request.headers['X-GitLab-Captcha-Response'] = params['g-recaptcha-response'] if params['g-recaptcha-response']
    request.headers['X-GitLab-Spam-Log-Id'] = params[:spam_log_id] if params[:spam_log_id]

    # Reset the spam_params on the request context, since they have changed mid-request
    Gitlab::RequestContext.instance.spam_params = ::Spam::SpamParams.new_from_request(request: request)
  end
end

SpammableActions::CaptchaCheck::HtmlFormatActionsSupport.prepend_mod
==== ./spammable_actions/captcha_check/json_format_actions_support.rb ====
# frozen_string_literal: true

# This module should be included to support forms submits with a 'js' or 'json' type of MIME type.
# In other words, forms handled by actions which use a `respond_to` of `format.js` or `format.json`.
#
# For example, for all Javascript based form submissions and Vue components which use Apollo and Axios
# which are directly handled by a controller other than `GraphqlController`. For example, issue
# update currently uses this module.
#
# However, requests which directly hit `GraphqlController` will not use this module - the
# `Mutations::SpamProtection` module handles those requests (for example, snippet create/update
# requests)
#
# If the request is handled by actions via `format.html`, then the corresponding module which
# supports HTML format should be used instead.
module SpammableActions::CaptchaCheck::JsonFormatActionsSupport
  extend ActiveSupport::Concern
  include SpammableActions::CaptchaCheck::Common
  include Spam::Concerns::HasSpamActionResponseFields

  private

  def with_captcha_check_json_format(spammable:, &block)
    # NOTE: "409 - Conflict" seems to be the most appropriate HTTP status code for a response
    # which requires a CAPTCHA to be solved in order for the request to be resubmitted.
    # https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.10
    captcha_render_lambda = -> { render json: spam_action_response_fields(spammable), status: :conflict }
    with_captcha_check_common(spammable: spammable, captcha_render_lambda: captcha_render_lambda, &block)
  end
end
==== ./spammable_actions/akismet_mark_as_spam_action.rb ====
# frozen_string_literal: true

module SpammableActions::AkismetMarkAsSpamAction
  extend ActiveSupport::Concern

  included do
    before_action :authorize_submit_spammable!, only: :mark_as_spam
  end

  def mark_as_spam
    if Spam::AkismetMarkAsSpamService.new(target: spammable).execute
      redirect_to spammable_path,
        notice: format(_("%{spammable_titlecase} was submitted to Akismet successfully."),
          spammable_titlecase: spammable.spammable_entity_type.titlecase)
    else
      redirect_to spammable_path, alert: _('Error with Akismet. Please check the logs for more info.')
    end
  end

  private

  def authorize_submit_spammable!
    access_denied! unless current_user.can_admin_all_resources?
  end

  def spammable
    # The class extending this module should define the #spammable method to return
    # the Spammable model instance via: `alias_method :spammable , <:model_name>`
    raise NotImplementedError, "#{self.class} should implement #{__method__}"
  end

  def spammable_path
    # The class extending this module should define the #spammable_path method to return
    # the route helper pointing to the action to show the Spammable instance
    raise NotImplementedError, "#{self.class} should implement #{__method__}"
  end
end
==== ./record_user_last_activity.rb ====
# frozen_string_literal: true

# == RecordUserLastActivity
#
# Controller concern that updates the `last_activity_on` field of `users`
# for any authenticated GET request. The DB update will only happen once per day.
#
# In order to determine if you should include this concern or not, please check the
# description and discussion on this issue: https://gitlab.com/gitlab-org/gitlab-foss/issues/54947
module RecordUserLastActivity
  include CookiesHelper
  extend ActiveSupport::Concern

  included do
    before_action :set_user_last_activity
    after_action :set_member_last_activity
  end

  def set_user_last_activity
    return unless request.get?
    return if Gitlab::Database.read_only?
    return unless current_user

    # TODO: add namespace & project - https://gitlab.com/gitlab-org/gitlab/-/issues/387952
    Users::ActivityService.new(author: current_user).execute
  end

  def set_member_last_activity
    context = @group || @project # rubocop:disable Gitlab/ModuleWithInstanceVariables -- This is a controller concern
    return unless current_user && context && context.persisted?

    Gitlab::EventStore.publish(
      Users::ActivityEvent.new(data: {
        user_id: current_user.id,
        namespace_id: context.root_ancestor.id
      })
    )
  end
end

RecordUserLastActivity.prepend_mod
==== ./todos_actions.rb ====
# frozen_string_literal: true

module TodosActions
  extend ActiveSupport::Concern

  def create
    todo = TodoService.new.mark_todo(issuable, current_user)

    render json: {
      count: TodosFinder.new(users: current_user, state: :pending).execute.count,
      delete_path: dashboard_todo_path(todo)
    }
  end
end
==== ./registry/connection_errors_handler.rb ====
# frozen_string_literal: true

module Registry
  module ConnectionErrorsHandler
    extend ActiveSupport::Concern

    included do
      rescue_from ContainerRegistry::Path::InvalidRegistryPathError, with: :invalid_registry_path
      rescue_from Faraday::Error, with: :connection_error

      before_action :ping_container_registry
    end

    private

    # rubocop:disable Gitlab/ModuleWithInstanceVariables
    # These instance variables are only read by a view helper to pass
    # them to the frontend
    # See app/views/projects/registry/repositories/index.html.haml
    # app/views/groups/registry/repositories/index.html.haml
    def invalid_registry_path
      @invalid_path_error = true

      render :index
    end

    def connection_error
      @connection_error = true

      render :index
    end
    # rubocop:enable Gitlab/ModuleWithInstanceVariables

    def ping_container_registry
      ContainerRegistry::Client.registry_info
    end
  end
end
==== ./workhorse_authorization.rb ====
# frozen_string_literal: true

module WorkhorseAuthorization
  extend ActiveSupport::Concern
  include WorkhorseRequest

  included do
    skip_before_action :verify_authenticity_token, only: %i[authorize]
    before_action :verify_workhorse_api!, only: %i[authorize]
  end

  def authorize
    set_workhorse_internal_api_content_type

    authorized = uploader_class.workhorse_authorize(
      has_length: false,
      maximum_size: maximum_size.to_i)

    render json: authorized
  rescue SocketError
    render json: _("Error uploading file"), status: :internal_server_error
  end

  private

  def file_is_valid?(file)
    return false unless file.is_a?(::UploadedFile)

    file_extension_allowlist.include?(File.extname(file.original_filename).downcase.delete('.'))
  end

  def uploader_class
    raise NotImplementedError
  end

  def maximum_size
    raise NotImplementedError
  end

  def file_extension_allowlist
    ImportExportUploader::EXTENSION_ALLOWLIST
  end
end
==== ./sourcegraph_decorator.rb ====
# frozen_string_literal: true

module SourcegraphDecorator
  extend ActiveSupport::Concern

  included do
    before_action :push_sourcegraph_gon, if: :html_request?

    content_security_policy do |p|
      next if p.directives.blank?
      next unless Gitlab::CurrentSettings.sourcegraph_enabled

      default_connect_src = p.directives['connect-src'] || p.directives['default-src']
      connect_src_values = Array.wrap(default_connect_src) | [Gitlab::Utils.append_path(
        Gitlab::CurrentSettings.sourcegraph_url, '.api/')]
      p.connect_src(*connect_src_values)
    end
  end

  private

  def push_sourcegraph_gon
    return unless sourcegraph_enabled?

    gon.push({
      sourcegraph: { url: Gitlab::CurrentSettings.sourcegraph_url }
    })
  end

  def sourcegraph_enabled?
    Gitlab::CurrentSettings.sourcegraph_enabled && sourcegraph_enabled_for_project? && current_user&.sourcegraph_enabled
  end

  def sourcegraph_enabled_for_project?
    return false unless project
    return project.public? if Gitlab::CurrentSettings.sourcegraph_public_only

    true
  end
end
==== ./dependency_proxy/group_access.rb ====
# frozen_string_literal: true

module DependencyProxy
  module GroupAccess
    extend ActiveSupport::Concern

    included do
      before_action :verify_dependency_proxy_available!
      before_action :authorize_read_dependency_proxy!
    end

    private

    def auth_user_or_token
      if defined?(personal_access_token) && personal_access_token && auth_user.is_a?(::User) &&
          (
            (auth_user.project_bot? && auth_user.resource_bot_resource.is_a?(::Group)) ||
            auth_user.human? ||
            auth_user.service_account?
          )
        personal_access_token
      else
        auth_user
      end
    end

    def verify_dependency_proxy_available!
      render_404 unless group&.dependency_proxy_feature_available?
    end

    # TODO: Split the authorization logic into dedicated methods
    # https://gitlab.com/gitlab-org/gitlab/-/issues/452145
    def authorize_read_dependency_proxy!
      if auth_user_or_token.is_a?(User)
        authorize_read_dependency_proxy_for_users!
      else
        authorize_read_dependency_proxy_for_tokens!
      end
    end

    def authorize_read_dependency_proxy_for_users!
      access_denied! unless can?(auth_user, :read_dependency_proxy, group)
    end

    def authorize_read_dependency_proxy_for_tokens!
      access_denied! unless can?(auth_user_or_token, :read_dependency_proxy,
        group&.dependency_proxy_for_containers_policy_subject)
    end
  end
end

DependencyProxy::GroupAccess.prepend_mod_with('DependencyProxy::GroupAccess')
==== ./onboarding/redirectable.rb ====
# frozen_string_literal: true

module Onboarding
  module Redirectable
    extend ActiveSupport::Concern

    private

    def after_sign_up_path(_user)
      if onboarding_status_presenter.single_invite?
        flash[:notice] = helpers.invite_accepted_notice(onboarding_status_presenter.last_invited_member)
        polymorphic_path(onboarding_status_presenter.last_invited_member_source)
      else
        # Invites will come here if there is more than 1.
        path_for_signed_in_user
      end
    end

    def path_for_signed_in_user
      stored_location_for(:user) || last_member_source_path
    end

    def last_member_source_path
      return dashboard_projects_path unless onboarding_status_presenter.last_invited_member_source.present?

      polymorphic_path(onboarding_status_presenter.last_invited_member_source)
    end
  end
end

Onboarding::Redirectable.prepend_mod
==== ./members/invite_modal_actions.rb ====
# frozen_string_literal: true

module Members
  module InviteModalActions
    extend ActiveSupport::Concern

    def invite_search
      users = Members::InviteUsersFinder.new(current_user, source, search: invite_search_params[:search]).execute
        .page(1)
        .per(invite_search_per_page)

      render json: UserSerializer.new.represent(users)
    end

    private

    def invite_search_per_page
      (pagination_params[:per_page] || 20).to_i
    end

    def invite_search_params
      params.permit(:search)
    end
  end
end
==== ./renders_assignees.rb ====
# frozen_string_literal: true

module RendersAssignees
  def preload_assignees_for_render(merge_request)
    merge_request.project.team.max_member_access_for_user_ids(merge_request.assignees.map(&:id))
  end
end
==== ./verifies_with_email.rb ====
# frozen_string_literal: true

# == VerifiesWithEmail
#
# Controller concern to handle verification by email
module VerifiesWithEmail
  extend ActiveSupport::Concern
  include ActionView::Helpers::DateHelper
  include SessionsHelper

  included do
    prepend_before_action :verify_with_email, only: :create, unless: -> { skip_verify_with_email? }
  end

  def verify_with_email
    return unless user = find_user || find_verification_user
    return unless user.active?

    if session[:verification_user_id] && token = verification_params[:verification_token].presence
      # The verification token is submitted, verify it
      verify_token(user, token)
    elsif require_email_verification_enabled?(user)
      # Limit the amount of password guesses, since we now display the email verification page
      # when the password is correct, which could be a giveaway when brute-forced.
      return render_sign_in_rate_limited if check_rate_limit!(:user_sign_in, scope: user) { true }

      # Verify the email if the user has logged in successfully.
      verify_email(user) if user.valid_password?(user_params[:password])
    end
  end

  def resend_verification_code
    return unless user = find_verification_user

    if send_rate_limited?(user)
      render_send_rate_limited
    else
      secondary_email = user_secondary_email(user, email_params[:email])

      if email_params[:email].present? && secondary_email.present?
        lock_and_send_verification_instructions(user, secondary_email: secondary_email)
      elsif email_params[:email].blank?
        lock_and_send_verification_instructions(user)
      end

      render json: { status: :success }
    end
  end

  def successful_verification
    session.delete(:verification_user_id)
    @redirect_url = after_sign_in_path_for(current_user) # rubocop:disable Gitlab/ModuleWithInstanceVariables

    render layout: 'minimal'
  end

  private

  def skip_verify_with_email?
    two_factor_enabled? || Gitlab::Qa.request?(request.user_agent)
  end

  def find_verification_user
    return unless session[:verification_user_id]

    User.find_by_id(session[:verification_user_id])
  end

  def lock_and_send_verification_instructions(user, secondary_email: nil, reason: nil)
    service = Users::EmailVerification::GenerateTokenService.new(attr: :unlock_token, user: user)
    raw_token, encrypted_token = service.execute
    user.unlock_token = encrypted_token
    user.lock_access!({ send_instructions: false, reason: reason })
    send_verification_instructions_email(user, raw_token, secondary_email)
  end

  def send_verification_instructions_email(user, token, secondary_email)
    email = secondary_email || user.email
    Notify.verification_instructions_email(email, token: token).deliver_later

    log_verification(user, :instructions_sent)
  end

  # As this is a prepended controller action, we only want to block
  # log in if the VerifiesWithEmail is required
  def requires_verify_email?(user)
    user.access_locked? || user.unlock_token || !trusted_ip_address?(user)
  end

  def verify_email(user)
    return true unless requires_verify_email?(user)

    # If they've received too many codes already, we won't send more
    unless send_rate_limited?(user)
      # If access is locked but there's no unlock_token, or the token has
      # expired, send a new one
      if user.access_locked?
        if !user.unlock_token || unlock_token_expired?(user) # rubocop:disable Style/IfUnlessModifier -- This is easier to read
          lock_and_send_verification_instructions(user)
        end
      # If they're not already locked but from a new IP, lock and send a
      # code
      elsif !trusted_ip_address?(user)
        lock_and_send_verification_instructions(
          user,
          reason: 'sign in from untrusted IP address'
        )
      end
    end

    # At this point they have a non-expired token in their email inbox.
    # Prompt for them to enter it.
    prompt_for_email_verification(user)
  end

  def verify_token(user, token)
    service = Users::EmailVerification::ValidateTokenService.new(attr: :unlock_token, user: user, token: token)
    result = service.execute

    if result[:status] == :success
      handle_verification_success(user)
      render json: { status: :success, redirect_path: users_successful_verification_path }
    else
      handle_verification_failure(user, result[:reason], result[:message])
      render json: result
    end
  end

  def render_sign_in_rate_limited
    message = format(
      s_('IdentityVerification|Maximum login attempts exceeded. Wait %{interval} and try again.'),
      interval: rate_limit_interval(:user_sign_in)
    )
    redirect_to new_user_session_path, alert: message
  end

  def render_send_rate_limited
    message = format(
      s_("IdentityVerification|You've reached the maximum amount of resends. Wait %{interval} and try again."),
      interval: rate_limit_interval(:email_verification_code_send)
    )
    render json: { status: :failure, message: message }
  end

  def rate_limit_interval(rate_limit)
    interval_in_seconds = Gitlab::ApplicationRateLimiter.rate_limits[rate_limit][:interval]
    distance_of_time_in_words(interval_in_seconds)
  end

  def send_rate_limited?(user)
    Gitlab::ApplicationRateLimiter.throttled?(:email_verification_code_send, scope: user)
  end

  def handle_verification_failure(user, reason, message)
    user.errors.add(:base, message)
    log_verification(user, :failed_attempt, reason)
  end

  def handle_verification_success(user)
    user.unlock_access!
    log_verification(user, :successful)

    sign_in(user)

    log_audit_event(current_user, user, with: authentication_method)
    log_user_activity(user)
    verify_known_sign_in
  end

  def trusted_ip_address?(user)
    AuthenticationEvent.initial_login_or_known_ip_address?(user, request.ip)
  end

  def prompt_for_email_verification(user)
    session[:verification_user_id] = user.id
    self.resource = user
    add_gon_variables # Necessary to set the sprite_icons path, since we skip the ApplicationController before_filters

    render 'devise/sessions/email_verification'
  end

  def verification_params
    params.require(:user).permit(:verification_token)
  end

  def email_params
    params.require(:user).permit(:email)
  end

  def user_secondary_email(user, email)
    user.emails.confirmed.find_by_email(email)&.email
  end

  def log_verification(user, event, reason = nil)
    Gitlab::AppLogger.info(
      message: 'Email Verification',
      event: event.to_s.titlecase,
      username: user.username,
      ip: request.ip,
      reason: reason.to_s
    )
  end

  def require_email_verification_enabled?(user)
    ::Gitlab::CurrentSettings.require_email_verification_on_account_locked &&
      Feature.disabled?(:skip_require_email_verification, user, type: :ops)
  end

  def unlock_token_expired?(user)
    Users::EmailVerification::ValidateTokenService.new(
      attr: :unlock_token,
      user: user,
      # We explicitly pass nil - we're only checking expiry, not the
      # token itself
      token: nil
    ).expired_token?
  end
end
==== ./initializes_current_user_mode.rb ====
# frozen_string_literal: true

module InitializesCurrentUserMode
  extend ActiveSupport::Concern

  included do
    helper_method :current_user_mode
  end

  def current_user_mode
    @current_user_mode ||= Gitlab::Auth::CurrentUserMode.new(current_user)
  end
end
==== ./snippets/blobs_actions.rb ====
# frozen_string_literal: true

module Snippets::BlobsActions
  extend ActiveSupport::Concern

  include Gitlab::Utils::StrongMemoize
  include Snippets::SendBlob

  included do
    before_action :authorize_read_snippet!, only: [:raw]
    before_action :ensure_repository
    before_action :ensure_blob
  end

  def raw
    send_snippet_blob(snippet, blob)
  end

  private

  def blob
    ref_extractor = ExtractsRef::RefExtractor.new(snippet, params.permit(:id, :ref, :path, :ref_type))
    ref_extractor.extract!
    return unless ref_extractor.commit

    snippet.repository.blob_at(ref_extractor.commit.id, ref_extractor.path)
  end
  strong_memoize_attr :blob

  def ensure_blob
    render_404 unless blob
  end

  def ensure_repository
    return if snippet.repo_exists?

    Gitlab::AppLogger.error(message: "Snippet raw blob attempt with no repo", snippet: snippet.id)

    respond_422
  end

  def snippet_id
    params[:snippet_id]
  end
end

Snippets::BlobsActions.prepend_mod
==== ./snippets/send_blob.rb ====
# frozen_string_literal: true

module Snippets::SendBlob
  include SendsBlob

  def send_snippet_blob(snippet, blob)
    workhorse_set_content_type!

    send_blob(
      snippet.repository,
      blob,
      inline: content_disposition == 'inline',
      allow_caching: ::Users::Anonymous.can?(:cache_blob, snippet)
    )
  end

  private

  def content_disposition
    @disposition ||= params[:inline] == 'false' ? 'attachment' : 'inline'
  end
end
==== ./product_analytics_tracking.rb ====
# frozen_string_literal: true

module ProductAnalyticsTracking
  include Gitlab::Tracking::Helpers
  extend ActiveSupport::Concern

  class_methods do
    def track_event(
      *controller_actions, name:, action: nil, label: nil, conditions: nil, destinations: [:redis_hll],
      &block)
      custom_conditions = [:trackable_html_request?, *conditions]

      after_action only: controller_actions, if: custom_conditions do
        route_events_to(destinations, name, action, label, &block)
      end
    end

    def track_internal_event(*controller_actions, name:, conditions: nil, **event_args)
      custom_conditions = [:trackable_html_request?, *conditions]

      after_action only: controller_actions, if: custom_conditions do
        additional_properties = event_args[:additional_properties]
        additional_properties =
          if additional_properties.respond_to?(:call)
            additional_properties.call(self) || {}
          elsif additional_properties.is_a?(Hash)
            additional_properties
          else
            {}
          end

        Gitlab::InternalEvents.track_event(
          name,
          user: current_user,
          project: tracking_project_source,
          namespace: tracking_namespace_source,
          **event_args.except(:additional_properties),
          additional_properties: additional_properties
        )
      end
    end
  end

  private

  def route_events_to(destinations, name, action, label, &block)
    track_unique_redis_hll_event(name, &block) if destinations.include?(:redis_hll)

    return unless destinations.include?(:snowplow)
    raise "action is required when destination is snowplow" unless action
    raise "label is required when destination is snowplow" unless label

    optional_arguments = {
      namespace: tracking_namespace_source,
      project: tracking_project_source
    }.compact

    Gitlab::Tracking.event(
      self.class.to_s,
      action,
      user: current_user,
      property: name,
      label: label,
      context: [Gitlab::Tracking::ServicePingContext.new(data_source: :redis_hll, event: name).to_context],
      **optional_arguments
    )
  end

  def track_unique_redis_hll_event(event_name, &block)
    custom_id = block ? yield(self) : nil

    unique_id = custom_id || visitor_id

    return unless unique_id

    Gitlab::UsageDataCounters::HLLRedisCounter.track_event(event_name, values: unique_id)
  end

  def visitor_id
    return cookies[:visitor_id] if cookies[:visitor_id].present?
    return unless current_user

    uuid = SecureRandom.uuid
    cookies[:visitor_id] = { value: uuid, expires: 24.months }
    uuid
  end
end
==== ./hotlink_interceptor.rb ====
# frozen_string_literal: true

module HotlinkInterceptor
  extend ActiveSupport::Concern

  def intercept_hotlinking!
    render_406 if Gitlab::HotlinkingDetector.intercept_hotlinking?(request)
  end

  private

  def render_406
    head :not_acceptable
  end
end
==== ./check_rate_limit.rb ====
# frozen_string_literal: true

# == CheckRateLimit
#
# Controller concern that checks if the rate limit for a given action is throttled by calling the
# Gitlab::ApplicationRateLimiter class. If the action is throttled for the current user, the request
# will be logged and an error message will be rendered with a Too Many Requests response status.
# See lib/api/helpers/rate_limiter.rb for API version
module CheckRateLimit
  def check_rate_limit!(key, scope:, redirect_back: false, **options)
    return unless Gitlab::ApplicationRateLimiter.throttled_request?(request, current_user, key, scope: scope, **options)

    return yield if block_given?

    message = _('This endpoint has been requested too many times. Try again later.')

    if redirect_back
      redirect_back_or_default(options: { alert: message })
    else
      render plain: message, status: :too_many_requests
    end
  end
end
==== ./confirm_email_warning.rb ====
# frozen_string_literal: true

module ConfirmEmailWarning
  include Gitlab::Utils::StrongMemoize
  extend ActiveSupport::Concern

  included do
    before_action :set_confirm_warning, if: :show_confirm_warning?
  end

  protected

  def show_confirm_warning?
    html_request? && request.get? && Gitlab::CurrentSettings.email_confirmation_setting_soft?
  end

  def set_confirm_warning
    return unless current_user
    return if current_user.confirmed?

    flash.now[:warning] = format(
      confirm_warning_message,
      email: email_to_display,
      resend_link: view_context.link_to(_('Resend it'), user_confirmation_path(user: { email: email }), method: :post),
      update_link: view_context.link_to(_('Update it'), user_settings_profile_path)
    ).html_safe
  end

  private

  def email
    current_user.unconfirmed_email || current_user.email
  end
  strong_memoize_attr :email

  def confirm_warning_message
    _("Please check your email (%{email}) to verify that you own this address and unlock the power of CI/CD. " \
      "Didn't receive it? %{resend_link}. Wrong email address? %{update_link}.")
  end

  def email_to_display
    ERB::Util.html_escape(email)
  end
end
==== ./request_payload_logger.rb ====
# frozen_string_literal: true

module RequestPayloadLogger
  extend ActiveSupport::Concern
  include Gitlab::Logging::CloudflareHelper

  def append_info_to_payload(payload)
    super

    payload[:ua] = request.env["HTTP_USER_AGENT"]
    payload[:remote_ip] = request.remote_ip
    payload[Labkit::Correlation::CorrelationId::LOG_KEY] = Labkit::Correlation::CorrelationId.current_id

    payload[:metadata] = Gitlab::ApplicationContext.current

    if defined?(urgency)
      payload[:request_urgency] = urgency&.name
      payload[:target_duration_s] = urgency&.duration
    end

    logged_user = auth_user
    if logged_user.present?
      payload[:user_id] = logged_user.try(:id)
      payload[:username] = logged_user.try(:username)
    end

    payload[:queue_duration_s] = request.env[::Gitlab::Middleware::RailsQueueDuration::GITLAB_RAILS_QUEUE_DURATION_KEY]

    store_cloudflare_headers!(payload, request)
  end
end
==== ./sorting_preference.rb ====
# frozen_string_literal: true

module SortingPreference
  include SortingHelper
  include CookiesHelper

  def set_sort_order(field = sorting_field, default_order = default_sort_order)
    sort_order = set_sort_order_from_user_preference(field) ||
      set_sort_order_from_cookie(field) ||
      pagination_params[:sort]

    # some types of sorting might not be available on the dashboard
    return default_order unless valid_sort_order?(sort_order)

    sort_order
  end

  # Implement sorting_field method on controllers
  # to choose which column to store the sorting parameter.
  def sorting_field
    nil
  end

  # Implement default_sort_order method on controllers
  # to choose which default sort should be applied if
  # sort param is not provided.
  def default_sort_order
    nil
  end

  # Implement legacy_sort_cookie_name method on controllers
  # to set sort from cookie for backwards compatibility.
  def legacy_sort_cookie_name
    nil
  end

  private

  def set_sort_order_from_user_preference(field = sorting_field)
    return unless current_user
    return unless field

    user_preference = current_user.user_preference

    sort_param = pagination_params[:sort]
    sort_param ||= user_preference[field]

    return sort_param if Gitlab::Database.read_only?

    user_preference.update(field => sort_param) if user_preference[field] != sort_param

    sort_param
  end

  def set_sort_order_from_cookie(field = sorting_field)
    return unless legacy_sort_cookie_name

    sort_param = pagination_params[:sort] if pagination_params[:sort].present?
    # fallback to legacy cookie value for backward compatibility
    sort_param ||= cookies[legacy_sort_cookie_name]
    sort_param ||= cookies[remember_sorting_key(field)]

    sort_value = update_cookie_value(sort_param)
    set_secure_cookie(remember_sorting_key(field), sort_value)
    sort_value
  end

  # Convert sorting_field to legacy cookie name for backwards compatibility
  # :merge_requests_sort => 'mergerequest_sort'
  # :issues_sort => 'issue_sort'
  def remember_sorting_key(field = sorting_field)
    @remember_sorting_key ||= field
      .to_s
      .split('_')[0..-2]
      .map(&:singularize)
      .join('')
      .concat('_sort')
  end

  # Update old values to the actual ones.
  def update_cookie_value(value)
    case value
    when 'id_asc'             then sort_value_oldest_created
    when 'id_desc'            then sort_value_recently_created
    when 'downvotes_asc'      then sort_value_popularity
    when 'downvotes_desc'     then sort_value_popularity
    else value
    end
  end

  def valid_sort_order?(sort_order)
    return false unless sort_order
    return can_sort_by_issue_weight?(action_name == 'issues') if sort_order.include?('weight')

    if sort_order.include?('merged_at')
      return can_sort_by_merged_date?(controller_name == 'merge_requests' || action_name == 'merge_requests')
    end

    true
  end
end
==== ./skips_already_signed_in_message.rb ====
# frozen_string_literal: true

# This concern can be included in devise controllers to skip showing an "already signed in"
# warning on registrations and logins
module SkipsAlreadySignedInMessage
  extend ActiveSupport::Concern

  included do
    # replaced with :require_no_authentication_without_flash
    # rubocop: disable Rails/LexicallyScopedActionFilter
    # The actions are defined in Devise
    skip_before_action :require_no_authentication, only: [:new, :create]
    before_action :require_no_authentication_without_flash, only: [:new, :create]
    # rubocop: enable Rails/LexicallyScopedActionFilter
  end

  def require_no_authentication_without_flash
    require_no_authentication

    return unless flash[:alert] == I18n.t('devise.failure.already_authenticated')

    flash[:alert] = nil
  end
end
==== ./wiki_actions.rb ====
# frozen_string_literal: true

module WikiActions
  include DiffHelper
  include PreviewMarkdown
  include SendsBlob
  include Gitlab::Utils::StrongMemoize
  include ProductAnalyticsTracking
  include SafeFormatHelper
  extend ActiveSupport::Concern
  include StrongPaginationParams

  RESCUE_GIT_TIMEOUTS_IN = %w[show raw edit history diff pages templates].freeze

  included do
    content_security_policy do |p|
      next if p.directives.blank?
      next unless Gitlab::CurrentSettings.diagramsnet_enabled?

      default_frame_src = p.directives['frame-src'] || p.directives['default-src']
      frame_src_values = Array.wrap(default_frame_src) | [Gitlab::CurrentSettings.diagramsnet_url].compact

      p.frame_src(*frame_src_values)
    end

    before_action { respond_to :html }

    before_action :authorize_read_wiki!
    before_action :authorize_create_wiki!, only: [:edit, :create, :destroy]

    before_action :wiki
    before_action :page, only: [:show, :edit, :update, :history, :destroy, :diff]
    before_action :load_sidebar, except: [:pages]

    before_action do
      push_frontend_feature_flag(:preserve_markdown, container)

      if Feature.enabled?(:glql_work_items, container) || Feature.enabled?(:glql_work_items, current_user)
        push_force_frontend_feature_flag(:glql_work_items, true)
      end

      push_force_frontend_feature_flag(:glql_load_on_click, !!container&.glql_load_on_click_feature_flag_enabled?)
    end

    before_action only: [:show, :edit, :update] do
      @valid_encoding = valid_encoding?
    end

    before_action only: [:edit, :update], unless: :valid_encoding? do
      if params[:id].present?
        redirect_to wiki_page_path(wiki, page || params[:id])
      else
        redirect_to wiki_path(wiki)
      end
    end

    track_internal_event :show, name: 'view_wiki_page'

    helper_method :view_file_button, :diff_file_html_data

    rescue_from ::Gitlab::Git::CommandTimedOut do |exc|
      raise exc unless RESCUE_GIT_TIMEOUTS_IN.include?(action_name)

      render 'shared/wikis/git_error'
    end

    rescue_from Gitlab::Git::Repository::NoRepository do
      @error = s_('Wiki|Could not access the Wiki Repository at this time.')

      render 'shared/wikis/empty'
    end
  end

  def new
    redirect_to wiki_page_path(wiki, SecureRandom.uuid, random_title: true, view: 'create')
  end

  # rubocop:disable Gitlab/ModuleWithInstanceVariables
  def pages
    @wiki_entries = WikiDirectory.group_pages(pages_list)

    render 'shared/wikis/pages'
  end

  def pages_list
    strong_memoize(:pages_list) do
      Kaminari.paginate_array(
        # only include pages not starting with 'templates/'
        wiki
          .list_pages(direction: params[:direction])
          .reject { |page| page.slug.start_with?('templates/') }
      ).page(pagination_params[:page])
    end
  end

  def templates_list
    strong_memoize(:templates_list) do
      Kaminari.paginate_array(
        # only include pages starting with 'templates/'
        wiki
          .list_pages(direction: params[:direction])
          .select { |page| page.slug.start_with?('templates/') }
      ).page(pagination_params[:page])
    end
  end

  def templates
    @wiki_entries_count = templates_list.total_count
    @wiki_entries = WikiDirectory.group_pages(templates_list, templates: true)

    render 'shared/wikis/templates'
  end
  # rubocop:enable Gitlab/ModuleWithInstanceVariables

  # `#show` handles a number of scenarios:
  #
  # - If `id` matches a WikiPage, then show the wiki page.
  # - If `id` is a file in the wiki repository, then send the file.
  # - If we know the user wants to create a new page with the given `id`,
  #   then display a create form.
  # - Otherwise show the empty wiki page and invite the user to create a page.
  #
  # rubocop:disable Gitlab/ModuleWithInstanceVariables
  def show
    if page
      set_encoding_error unless valid_encoding?

      # Assign vars expected by MarkupHelper
      @ref = params[:version_id]
      @path = page.path
      @templates = templates_list

      render 'shared/wikis/show'
    elsif file_blob
      # This is needed by [GitLab JH](https://gitlab.com/gitlab-jh/gitlab/-/issues/247)
      send_wiki_file_blob(wiki, file_blob)
    else
      handle_redirection
    end
  end

  def handle_redirection
    redir = find_redirection(params[:id]) unless params[:redirect_limit_reached] || params[:no_redirect]
    if redir.is_a?(Hash) && redir[:error]
      message = safe_format(
        s_('Wiki|The page at %{code_start}%{redirected_from}%{code_end} redirected too many times. ' \
          'You are now editing the page at %{code_start}%{redirected_from}%{code_end}.'),
        tag_pair(helpers.content_tag(:code), :code_start, :code_end),
        redirected_from: params[:id]
      )
      redirect_to(
        "#{wiki_page_path(wiki, params[:id])}?redirect_limit_reached=true",
        status: :found,
        notice: message
      )
    elsif redir
      redirected_from = params[:redirected_from] || params[:id]
      message = safe_format(
        s_('Wiki|The page at %{code_start}%{redirected_from}%{code_end} ' \
          'has been moved to %{code_start}%{redirected_to}%{code_end}.'),
        tag_pair(helpers.content_tag(:code), :code_start, :code_end),
        redirected_from: redirected_from,
        redirected_to: redir
      )
      redirect_to(
        "#{wiki_page_path(wiki, redir)}?redirected_from=#{redirected_from}",
        status: :found,
        notice: message
      )
    elsif show_create_form?
      handle_create_form
    elsif wiki.exists?
      render 'shared/wikis/404', status: :not_found
    else
      render 'shared/wikis/empty'
    end
  end

  def handle_create_form
    title = params[:id]
    if params[:redirected_from] # override the notice if redirected
      redirected_link = helpers.link_to('', "#{wiki_page_path(wiki, params[:redirected_from])}?no_redirect=true")
      flash[:notice] = safe_format(
        s_('Wiki|The page at %{code_start}%{redirected_from}%{code_end} tried to redirect to ' \
          '%{code_start}%{redirected_to}%{code_end}, but it does not exist. You are now ' \
          'editing the page at %{code_start}%{redirected_to}%{code_end}. %{link_start}Edit ' \
          'page at %{code_start}%{redirected_from}%{code_end} instead.%{link_end}'
          ),
        tag_pair(helpers.content_tag(:code), :code_start, :code_end),
        tag_pair(redirected_link, :link_start, :link_end),
        redirected_from: params[:redirected_from],
        redirected_to: params[:id]
      )
    end

    @page = build_page(title: title)
    @templates = templates_list

    render 'shared/wikis/edit'

    flash[:notice] = nil if params[:redirected_from]
  end

  def raw
    response.headers['Content-Type'] = 'text/plain'
    render plain: page.raw_content
  end

  def edit
    @templates = templates_list

    render 'shared/wikis/edit'
  end

  def update
    return render('shared/wikis/empty') unless can?(current_user, :create_wiki, container)

    response = WikiPages::UpdateService.new(
      container: container,
      current_user: current_user,
      params: wiki_params
    ).execute(page)
    @page = response.payload[:page]

    if response.success?
      handle_action_success :updated, @page
    else
      @error = response.message
      @templates = templates_list

      render 'shared/wikis/edit'
    end
  end
  # rubocop:enable Gitlab/ModuleWithInstanceVariables

  # rubocop:disable Gitlab/ModuleWithInstanceVariables
  def create
    response = WikiPages::CreateService.new(container: container, current_user: current_user,
      params: wiki_params).execute
    @page = response.payload[:page]

    if response.success?
      handle_action_success :created, @page
    else
      @templates = templates_list

      render 'shared/wikis/edit'
    end
  end
  # rubocop:enable Gitlab/ModuleWithInstanceVariables

  # rubocop:disable Gitlab/ModuleWithInstanceVariables
  def history
    if page
      @commits_count = page.count_versions
      @commits = Kaminari.paginate_array(page.versions(page: pagination_params[:page].to_i),
        total_count: page.count_versions)
        .page(pagination_params[:page])

      render 'shared/wikis/history'
    else
      redirect_to(
        wiki_path(wiki),
        notice: _("Page not found")
      )
    end
  end
  # rubocop:enable Gitlab/ModuleWithInstanceVariables

  # rubocop:disable Gitlab/ModuleWithInstanceVariables
  def diff
    return render_404 unless page

    apply_diff_view_cookie!

    @diffs = page.diffs(diff_options)
    @diff_notes_disabled = true

    render 'shared/wikis/diff'
  end
  # rubocop:enable Gitlab/ModuleWithInstanceVariables

  # rubocop:disable Gitlab/ModuleWithInstanceVariables
  def destroy
    return render_404 unless page

    response = WikiPages::DestroyService.new(container: container, current_user: current_user).execute(page)

    if response.success?
      flash[:toast] = _("Wiki page was successfully deleted.")

      redirect_to wiki_path(wiki), status: :found
    else
      @error = response.message
      @templates = templates_list

      render 'shared/wikis/edit'
    end
  end
  # rubocop:enable Gitlab/ModuleWithInstanceVariables

  def git_access
    render 'shared/wikis/git_access'
  end

  private

  def handle_action_success(action, page)
    if page.title == Wiki::SIDEBAR
      flash[:toast] = s_('Wiki|Sidebar was successfully created.') if action == :created
      flash[:toast] = s_('Wiki|Sidebar was successfully updated.') if action == :updated

      redirect_to wiki_path(wiki)
    else
      flash[:toast] = s_('Wiki|Wiki page was successfully created.') if action == :created
      flash[:toast] = s_('Wiki|Wiki page was successfully updated.') if action == :updated

      redirect_to(wiki_page_path(wiki, page))
    end
  end

  def container
    raise NotImplementedError
  end

  def show_create_form?
    can?(current_user, :create_wiki, container) &&
      page.nil? &&
      # Only show the form when the user has navigated from
      # the 'empty wiki' or '404' page
      params[:view] == 'create'
  end

  def wiki
    strong_memoize(:wiki) do
      wiki = Wiki.for_container(container, current_user)
      wiki.create_wiki_repository

      wiki
    end
  rescue Wiki::CouldNotCreateWikiError
    flash[:notice] = _("Could not create Wiki Repository at this time. Please try again later.")
    redirect_to container
    false
  end

  def page
    strong_memoize(:page) do
      wiki.find_page(*page_params, load_content: load_content?)
    end
  end

  # rubocop:disable Gitlab/ModuleWithInstanceVariables
  def load_sidebar
    @sidebar_page = wiki.find_sidebar(params[:version_id])
    @wiki_pages_count = pages_list.total_count
  end
  # rubocop:enable Gitlab/ModuleWithInstanceVariables

  def wiki_params
    params.require(:wiki).permit(:title, :content, :format, :message, :last_commit_sha)
  end

  def build_page(args = {})
    WikiPage.new(wiki).tap do |page|
      page.update_attributes(args) # rubocop:disable Rails/ActiveRecordAliases
    end
  end

  def page_params
    keys = [:id]
    keys << :version_id if %w[show diff].include?(params[:action])

    params.values_at(*keys)
  end

  def valid_encoding?
    page_encoding == Encoding::UTF_8
  end

  def page_encoding
    strong_memoize(:page_encoding) { page&.content&.encoding }
  end

  def set_encoding_error
    flash.now[:notice] =
      _("The content of this page is not encoded in UTF-8. Edits can only be made via the Git repository.")
  end

  def file_blob
    strong_memoize(:file_blob) do
      commit = wiki.repository.commit(wiki.default_branch)

      next unless commit

      wiki.repository.blob_at(commit.id, params[:id])
    end
  end

  # Override CommitsHelper#view_file_button
  def view_file_button(commit_sha, *args)
    path = wiki_page_path(wiki, page, version_id: page.version.id)

    helpers.link_button_to(path) do
      helpers.raw(_('View page @ ')) + helpers.content_tag(:span, Commit.truncate_sha(commit_sha), class: 'commit-sha')
    end
  end

  # Override DiffHelper#diff_file_html_data
  def diff_file_html_data(_project, _diff_file_path, diff_commit_id)
    {
      blob_diff_path: wiki_page_path(wiki, page, action: :diff, version_id: diff_commit_id),
      view: diff_view
    }
  end

  def send_wiki_file_blob(wiki, file_blob)
    send_blob(wiki.repository, file_blob)
  end

  def load_content?
    skip_actions = %w[history destroy diff]

    return false if skip_actions.include?(params[:action])

    true
  end

  def tracking_project_source
    container if container.is_a?(Project)
  end

  def tracking_namespace_source
    case container
    when Project
      container.namespace
    when Group
      container
    end
  end

  def find_redirection(path, redirect_limit = 50)
    seen = Set[]
    current_path = path

    redirect_limit.times do
      seen << current_path
      next_path = find_single_redirection(current_path)

      # if no single redirect is found, then use the current path
      # unless it is the same as the original path
      return current_path == path ? nil : current_path if next_path.nil?

      # if the file was already seen, then we have a loop
      return { error: true, reason: :loop } if seen.include?(next_path)

      current_path = next_path
    end

    { error: true, reason: :limit }
  end

  def find_single_redirection(path)
    current = path
    rest = []

    until current == '.'
      redirect = redirections[current]
      return File.join(redirect, *rest) if redirect

      current, basename = File.split(current)
      rest.unshift(basename)
    end

    nil
  end

  def redirections
    strong_memoize(:redirections) do
      redirects_file = wiki.repository.blob_at(wiki.default_branch, Wiki::REDIRECTS_YML, limit: 0.5.megabytes)
      redirects_file ? YAML.safe_load(redirects_file.data).to_h : {}
    end
  end
end

WikiActions.prepend_mod
==== ./graceful_timeout_handling.rb ====
# frozen_string_literal: true

module GracefulTimeoutHandling
  extend ActiveSupport::Concern

  included do
    rescue_from ActiveRecord::QueryCanceled do |exception|
      raise exception unless request.format.json?

      log_exception(exception)

      render json: { error: _('There is too much data to calculate. Please change your selection.') }
    end
  end
end
==== ./authenticates_with_two_factor_for_admin_mode.rb ====
# frozen_string_literal: true

module AuthenticatesWithTwoFactorForAdminMode
  extend ActiveSupport::Concern

  included do
    include AuthenticatesWithTwoFactor
  end

  def admin_mode_prompt_for_two_factor(user)
    @user = user # rubocop:disable Gitlab/ModuleWithInstanceVariables -- Set @user for Admin views

    return handle_locked_user(user) unless user.can?(:log_in)

    session[:otp_user_id] = user.id
    setup_webauthn_authentication(user)

    render 'admin/sessions/two_factor', layout: 'application'
  end

  def admin_mode_authenticate_with_two_factor
    user = current_user

    return handle_locked_user(user) unless user.can?(:log_in)

    if user_params[:otp_attempt].present? && session[:otp_user_id]
      admin_mode_authenticate_with_two_factor_via_otp(user)
    elsif user_params[:device_response].present? && session[:otp_user_id]
      admin_mode_authenticate_with_two_factor_via_webauthn(user)
    elsif user && user.valid_password?(user_params[:password])
      admin_mode_prompt_for_two_factor(user)
    else
      invalid_login_redirect
    end
  end

  def admin_mode_authenticate_with_two_factor_via_otp(user)
    if valid_otp_attempt?(user)
      # Remove any lingering user data from login
      session.delete(:otp_user_id)

      user.save! unless Gitlab::Database.read_only?

      # The admin user has successfully passed 2fa, enable admin mode ignoring password
      enable_admin_mode
    else
      admin_handle_two_factor_failure(user, 'OTP', _('Invalid two-factor code.'))
    end
  end

  def admin_mode_authenticate_with_two_factor_via_webauthn(user)
    if Webauthn::AuthenticateService.new(user, user_params[:device_response], session[:challenge]).execute
      admin_handle_two_factor_success
    else
      admin_handle_two_factor_failure(user, 'WebAuthn', _('Authentication via WebAuthn device failed.'))
    end
  end

  private

  def enable_admin_mode
    if current_user_mode.enable_admin_mode!(skip_password_validation: true)
      redirect_to redirect_path, notice: _('Admin mode enabled')
    else
      invalid_login_redirect
    end
  end

  def invalid_login_redirect
    flash.now[:alert] = _('Invalid login or password')
    render :new
  end

  def admin_handle_two_factor_success
    # Remove any lingering user data from login
    session.delete(:otp_user_id)
    session.delete(:challenge)

    # The admin user has successfully passed 2fa, enable admin mode ignoring password
    enable_admin_mode
  end

  def admin_handle_two_factor_failure(user, method, message)
    user.increment_failed_attempts!
    log_failed_two_factor(user, method)

    Gitlab::AppLogger.info("Failed Admin Mode Login: user=#{user.username} ip=#{request.remote_ip} method=#{method}")
    flash.now[:alert] = message
    admin_mode_prompt_for_two_factor(user)
  end
end
==== ./gitlab_recaptcha.rb ====
# frozen_string_literal: true

module GitlabRecaptcha
  extend ActiveSupport::Concern
  include Recaptcha::Adapters::ControllerMethods
  include RecaptchaHelper

  def load_recaptcha
    recaptcha_enabled? && Gitlab::Recaptcha.load_configurations!
  end

  def check_recaptcha
    return unless load_recaptcha
    return if verify_recaptcha

    flash[:alert] = _('There was an error with the reCAPTCHA. Please solve the reCAPTCHA again.')
    flash.delete :recaptcha_error

    self.resource = resource_class.new

    add_gon_variables

    render action: 'new'
  end
end
==== ./preferred_language_switcher.rb ====
# frozen_string_literal: true

module PreferredLanguageSwitcher
  extend ActiveSupport::Concern
  include Gitlab::Utils::StrongMemoize
  include PreferredLanguageSwitcherHelper

  private

  def init_preferred_language
    return if Feature.enabled?(:disable_preferred_language_cookie)

    cookies[:preferred_language] = preferred_language
  end

  def preferred_language
    cookies[:preferred_language].presence_in(Gitlab::I18n.available_locales) ||
      selectable_language(language_from_params) ||
      selectable_language(browser_languages) ||
      Gitlab::CurrentSettings.default_preferred_language
  end

  def selectable_language(language_options)
    language_options.find { |lan| ordered_selectable_locales_codes.include?(lan) }
  end

  def ordered_selectable_locales_codes
    ordered_selectable_locales.pluck(:value) # rubocop:disable CodeReuse/ActiveRecord
  end

  def browser_languages
    formatted_http_language_header = request.env['HTTP_ACCEPT_LANGUAGE']&.tr('-', '_')

    return [] unless formatted_http_language_header

    formatted_http_language_header.split(%r{[;,]}).reject { |str| str.start_with?('q') }
  end
  strong_memoize_attr :browser_languages

  def language_from_params
    # overridden in ee
    []
  end
end

PreferredLanguageSwitcher.prepend_mod
==== ./web_ide_csp.rb ====
# frozen_string_literal: true

module WebIdeCSP
  extend ActiveSupport::Concern

  included do
    before_action :include_web_ide_csp
  end

  # We want to include frames from `/assets/webpack` of the request's host to
  # support URL flexibility with the Web IDE.
  # https://gitlab.com/gitlab-org/gitlab/-/merge_requests/118875
  def include_web_ide_csp
    return if request.content_security_policy.directives.blank?

    base_uri = URI(request.url)
    base_uri.path = ::Gitlab.config.gitlab.relative_url_root || '/'
    # note: `.path +=` handles combining trailing and leading slashes (e.g. `x/` and `/foo`)
    base_uri.path += '/assets/webpack/'
    # note: this fixes a browser console warning where CSP included query params
    base_uri.query = nil
    webpack_url = base_uri.to_s

    default_src = Array(request.content_security_policy.directives['default-src'] || [])
    request.content_security_policy.directives['frame-src'] ||= default_src
    request.content_security_policy.directives['frame-src'].concat([webpack_url, 'https://*.web-ide.gitlab-static.net/',
      ide_oauth_redirect_url, oauth_authorization_url])

    request.content_security_policy.directives['worker-src'] ||= default_src
    request.content_security_policy.directives['worker-src'].concat([webpack_url])
  end
end

WebIdeCSP.prepend_mod_with('WebIdeCSP')
==== ./redirects_for_missing_path_on_tree.rb ====
# frozen_string_literal: true

module RedirectsForMissingPathOnTree
  def redirect_to_tree_root_for_missing_path(project, ref, path, ref_type: nil)
    redirect_to project_tree_path(project, ref, ref_type: ref_type), notice: missing_path_on_ref(path, ref)
  end

  private

  def missing_path_on_ref(path, ref)
    format(_('"%{path}" did not exist on "%{ref}"'), path: truncate_path(path), ref: ref)
  end

  def truncate_path(path)
    path.reverse.truncate(60, separator: "/").reverse
  end
end
==== ./authenticates_with_two_factor.rb ====
# frozen_string_literal: true

# == AuthenticatesWithTwoFactor
#
# Controller concern to handle two-factor authentication
module AuthenticatesWithTwoFactor
  extend ActiveSupport::Concern

  # Store the user's ID in the session for later retrieval and render the
  # two factor code prompt
  #
  # The user must have been authenticated with a valid login and password
  # before calling this method!
  #
  # user - User record
  #
  # Returns nil
  def prompt_for_two_factor(user)
    @user = user # rubocop:disable Gitlab/ModuleWithInstanceVariables -- Set @user for Devise views

    return handle_locked_user(user) unless user.can?(:log_in)

    session[:otp_user_id] = user.id
    session[:user_password_hash] = Digest::SHA256.hexdigest(user.encrypted_password)

    add_gon_variables
    setup_webauthn_authentication(user)

    render 'devise/sessions/two_factor'
  end

  def handle_locked_user(user)
    clear_two_factor_attempt!

    locked_user_redirect(user)
  end

  def locked_user_redirect(user)
    redirect_to new_user_session_path, alert: locked_user_redirect_alert(user)
  end

  def authenticate_with_two_factor
    user = self.resource = find_user
    return handle_locked_user(user) unless user.can?(:log_in)
    return handle_changed_user(user) if user_password_changed?(user)

    if user_params[:otp_attempt].present? && session[:otp_user_id]
      authenticate_with_two_factor_via_otp(user)
    elsif user_params[:device_response].present? && session[:otp_user_id]
      authenticate_with_two_factor_via_webauthn(user)
    elsif user && user.valid_password?(user_params[:password])
      prompt_for_two_factor(user)
    end
  rescue ActiveRecord::RecordInvalid => e
    # We expect User to always be valid.
    # Otherwise, raise internal server error instead of unprocessable entity to improve observability/alerting
    if e.record.is_a?(User)
      raise e.message
    else
      raise e
    end
  end

  private

  def locked_user_redirect_alert(user)
    if user.access_locked?
      _('Your account is locked.')
    elsif !user.confirmed?
      I18n.t('devise.failure.unconfirmed')
    else
      _('Invalid login or password')
    end
  end

  def clear_two_factor_attempt!
    session.delete(:otp_user_id)
    session.delete(:user_password_hash)
    session.delete(:challenge)
  end

  def authenticate_with_two_factor_via_otp(user)
    if valid_otp_attempt?(user)
      # Remove any lingering user data from login
      clear_two_factor_attempt!

      remember_me(user) if user_params[:remember_me] == '1'
      user.save!
      sign_in(user, message: :two_factor_authenticated, event: :authentication)
    else
      send_two_factor_otp_attempt_failed_email(user)
      handle_two_factor_failure(user, 'OTP', _('Invalid two-factor code.'))
    end
  end

  def authenticate_with_two_factor_via_webauthn(user)
    if Webauthn::AuthenticateService.new(user, user_params[:device_response], session[:challenge]).execute
      handle_two_factor_success(user)
    else
      handle_two_factor_failure(user, 'WebAuthn', _('Authentication via WebAuthn device failed.'))
    end
  end

  # rubocop: disable CodeReuse/ActiveRecord
  def setup_webauthn_authentication(user)
    if user.webauthn_registrations.present?

      webauthn_registration_ids = user.webauthn_registrations.pluck(:credential_xid)

      get_options = WebAuthn::Credential.options_for_get(
        allow: webauthn_registration_ids,
        user_verification: 'discouraged',
        extensions: { appid: WebAuthn.configuration.origin }
      )
      session[:challenge] = get_options.challenge
      gon.push(webauthn: { options: Gitlab::Json.dump(get_options) })
    end
  end
  # rubocop: enable CodeReuse/ActiveRecord

  def handle_two_factor_success(user)
    # Remove any lingering user data from login
    clear_two_factor_attempt!

    remember_me(user) if user_params[:remember_me] == '1'
    sign_in(user, message: :two_factor_authenticated, event: :authentication)
  end

  def handle_two_factor_failure(user, method, message)
    user.increment_failed_attempts!
    log_failed_two_factor(user, method)

    Gitlab::AppLogger.info("Failed Login: user=#{user.username} ip=#{request.remote_ip} method=#{method}")
    flash.now[:alert] = message
    prompt_for_two_factor(user)
  end

  def send_two_factor_otp_attempt_failed_email(user)
    user.notification_service.two_factor_otp_attempt_failed(user, request.remote_ip)
  end

  def log_failed_two_factor(user, method)
    # overridden in EE
  end

  def handle_changed_user(user)
    clear_two_factor_attempt!

    redirect_to new_user_session_path, alert: _('An error occurred. Please sign in again.')
  end

  # If user has been updated since we validated the password,
  # the password might have changed.
  def user_password_changed?(user)
    return false unless session[:user_password_hash]

    Digest::SHA256.hexdigest(user.encrypted_password) != session[:user_password_hash]
  end
end

AuthenticatesWithTwoFactor.prepend_mod_with('AuthenticatesWithTwoFactor')
==== ./homepage_data.rb ====
# frozen_string_literal: true

module HomepageData
  extend ActiveSupport::Concern
  include Gitlab::Utils::StrongMemoize
  include MergeRequestsHelper

  private

  def homepage_app_data(user)
    {
      review_requested_path: review_requested_path(user),
      activity_path: activity_dashboard_path,
      assigned_merge_requests_path: assigned_merge_requests_path(user),
      assigned_work_items_path: issues_dashboard_path(assignee_username: user.username),
      authored_work_items_path: issues_dashboard_path(author_username: user.username),
      duo_code_review_bot_username: duo_code_review_bot.username,
      merge_requests_review_requested_title: dashboard_list_title('reviews_requested'),
      merge_requests_your_merge_requests_title: dashboard_list_title('assigned_to_you')
    }
  end

  def review_requested_path(user)
    return merge_requests_dashboard_path if Feature.enabled?(:merge_request_dashboard, user)

    merge_requests_dashboard_path(reviewer_username: user.username)
  end

  def assigned_merge_requests_path(user)
    return merge_requests_dashboard_path if Feature.enabled?(:merge_request_dashboard, user)

    merge_requests_dashboard_path(assignee_username: user.username)
  end

  def duo_code_review_bot
    ::Users::Internal.duo_code_review_bot
  end
  strong_memoize_attr :duo_code_review_bot
end
==== ./repository_settings_redirect.rb ====
# frozen_string_literal: true

module RepositorySettingsRedirect
  extend ActiveSupport::Concern

  def redirect_to_repository_settings(project, anchor: nil)
    redirect_to project_settings_repository_path(project, anchor: anchor)
  end
end
==== ./cycle_analytics_params.rb ====
# frozen_string_literal: true

module CycleAnalyticsParams
  extend ActiveSupport::Concern

  def cycle_analytics_project_params
    return {} unless params[:cycle_analytics].present?

    params[:cycle_analytics].permit(:start_date, :created_after, :created_before, :branch_name)
  end

  def cycle_analytics_group_params
    return {} unless params.present?

    params.permit(:group_id, :start_date, :created_after, :created_before, project_ids: [])
  end

  def options(params)
    @options ||= {}.tap do |opts|
      opts[:current_user] = current_user
      opts[:projects] = params[:project_ids] if params[:project_ids]
      opts[:from] = params[:from] || start_date(params)
      opts[:to] = params[:to] if params[:to]
      opts[:end_event_filter] = params[:end_event_filter] if params[:end_event_filter]
      if params[:use_aggregated_data_collector]
        opts[:use_aggregated_data_collector] = params[:use_aggregated_data_collector]
      end

      opts.merge!(params.slice(*::Gitlab::Analytics::CycleAnalytics::RequestParams::FINDER_PARAM_NAMES))
      opts.merge!(date_range(params))
    end
  end

  private

  def start_date(params)
    case params[:start_date]
    when '7'
      7.days.ago
    when '30'
      30.days.ago
    else
      90.days.ago
    end
  end

  def date_range(params)
    {}.tap do |date_range_params|
      date_range_params[:from] = to_utc_time(params[:created_after]).beginning_of_day if params[:created_after]
      date_range_params[:to] = to_utc_time(params[:created_before]).end_of_day if params[:created_before]
    end.compact
  end

  def to_utc_time(field)
    date = field.is_a?(Date) || field.is_a?(Time) ? field : Date.parse(field)
    date.to_time.utc
  end

  def permitted_cycle_analytics_params
    params.permit(*::Gitlab::Analytics::CycleAnalytics::RequestParams::STRONG_PARAMS_DEFINITION)
  end

  def all_cycle_analytics_params
    permitted_cycle_analytics_params.merge(current_user: current_user, namespace: namespace)
  end

  def request_params
    @request_params ||= ::Gitlab::Analytics::CycleAnalytics::RequestParams.new(all_cycle_analytics_params)
  end

  def validate_params
    if request_params.invalid?
      render(
        json: { message: 'Invalid parameters', errors: request_params.errors },
        status: :unprocessable_entity
      )
    end
  end
end
==== ./render_service_results.rb ====
# frozen_string_literal: true

module RenderServiceResults
  extend ActiveSupport::Concern

  def success_response(result)
    render({
      status: result[:http_status],
      json: result[:body]
    })
  end

  def continue_polling_response
    render({
      status: :no_content,
      json: {
        status: _('processing'),
        message: _('Not ready yet. Try again later.')
      }
    })
  end

  def error_response(result)
    render({
      status: result[:http_status] || :bad_request,
      json: { status: result[:status], message: result[:message] }
    })
  end
end
==== ./security_and_compliance_permissions.rb ====
# frozen_string_literal: true

module SecurityAndCompliancePermissions
  extend ActiveSupport::Concern

  included do
    before_action :ensure_security_and_compliance_enabled!
  end

  private

  def ensure_security_and_compliance_enabled!
    render_404 unless can?(current_user, :access_security_and_compliance, project)
  end
end
==== ./toggle_award_emoji.rb ====
# frozen_string_literal: true

module ToggleAwardEmoji
  extend ActiveSupport::Concern

  def toggle_award_emoji
    authenticate_user!
    name = params.require(:name)

    service = AwardEmojis::ToggleService.new(awardable, name, current_user).execute

    if service[:status] == :success
      render json: { ok: true }
    else
      render json: { ok: false }
    end
  end

  private

  def awardable
    raise NotImplementedError
  end
end
==== ./milestone_actions.rb ====
# frozen_string_literal: true

module MilestoneActions
  extend ActiveSupport::Concern

  def issues
    respond_to do |format|
      format.html { redirect_to milestone_redirect_path }
      format.json do
        render json: tabs_json("shared/milestones/_issues_tab", {
          issues: @milestone.milestone_issues(current_user), # rubocop:disable Gitlab/ModuleWithInstanceVariables
          show_project_name: Gitlab::Utils.to_boolean(params[:show_project_name])
        })
      end
    end
  end

  def merge_requests
    respond_to do |format|
      format.html { redirect_to milestone_redirect_path }
      format.json do
        render json: tabs_json("shared/milestones/_merge_requests_tab", {
          merge_requests: @milestone.merge_requests_visible_to_user(current_user).preload_milestoneish_associations, # rubocop:disable Gitlab/ModuleWithInstanceVariables
          show_project_name: Gitlab::Utils.to_boolean(params[:show_project_name])
        })
      end
    end
  end

  def participants
    respond_to do |format|
      format.html { redirect_to milestone_redirect_path }
      format.json do
        render json: tabs_json("shared/milestones/_participants_tab", {
          users: @milestone.issue_participants_visible_by_user(current_user) # rubocop:disable Gitlab/ModuleWithInstanceVariables
        })
      end
    end
  end

  # rubocop:disable Gitlab/ModuleWithInstanceVariables
  def labels
    respond_to do |format|
      format.html { redirect_to milestone_redirect_path }
      format.json do
        milestone_labels = @milestone.issue_labels_visible_by_user(current_user)

        render json: tabs_json("shared/milestones/_labels_tab", {
          labels: milestone_labels.map do |label|
            label.present(issuable_subject: @milestone.resource_parent)
          end
        })
      end
    end
  end
  # rubocop:enable Gitlab/ModuleWithInstanceVariables

  private

  def tabs_json(partial, data = {})
    {
      html: view_to_html_string(partial, data)
    }
  end

  def milestone_redirect_path
    url_for(action: :show)
  end
end
==== ./find_snippet.rb ====
# frozen_string_literal: true

module FindSnippet
  extend ActiveSupport::Concern
  include Gitlab::Utils::StrongMemoize

  private

  # rubocop:disable CodeReuse/ActiveRecord
  def snippet
    snippet_klass.inc_relations_for_view.find_by(snippet_find_params)
  end
  strong_memoize_attr :snippet
  # rubocop:enable CodeReuse/ActiveRecord

  def snippet_klass
    raise NotImplementedError
  end

  def snippet_id
    params[:id]
  end

  def snippet_find_params
    { id: snippet_id }
  end
end
==== ./members_presentation.rb ====
# frozen_string_literal: true

module MembersPresentation
  extend ActiveSupport::Concern

  def present_members(members)
    preload_associations(members)

    Gitlab::View::Presenter::Factory.new(
      members,
      current_user: current_user,
      presenter_class: MembersPresenter
    ).fabricate!
  end

  def preload_associations(members)
    MembersPreloader.new(members).preload_all
  end
end
==== ./floc_opt_out.rb ====
# frozen_string_literal: true

module FlocOptOut
  extend ActiveSupport::Concern

  included do
    before_action :set_floc_opt_out_header, unless: :floc_enabled?
  end

  def floc_enabled?
    Gitlab::CurrentSettings.floc_enabled
  end

  def set_floc_opt_out_header
    response.headers['Permissions-Policy'] = 'interest-cohort=()'
  end
end
==== ./import/github_oauth.rb ====
# frozen_string_literal: true

module Import
  module GithubOauth
    extend ActiveSupport::Concern

    OAuthConfigMissingError = Class.new(StandardError)

    included do
      rescue_from OAuthConfigMissingError, with: :missing_oauth_config
    end

    private

    def provider_auth
      return if session[access_token_key].present?

      go_to_provider_for_permissions unless ci_cd_only?
    end

    def ci_cd_only?
      %w[1 true].include?(params[:ci_cd_only])
    end

    def go_to_provider_for_permissions
      redirect_to authorize_url
    end

    def oauth_client
      raise OAuthConfigMissingError unless oauth_config

      oauth_client_from_config
    end

    def oauth_client_from_config
      @oauth_client_from_config ||= ::OAuth2::Client.new(
        oauth_config.app_id,
        oauth_config.app_secret,
        oauth_options.merge(ssl: { verify: oauth_config['verify_ssl'] })
      )
    end

    def oauth_config
      @oauth_config ||= Gitlab::Auth::OAuth::Provider.config_for('github')
    end

    def oauth_options
      return unless oauth_config

      oauth_config.dig('args', 'client_options').to_h.deep_symbolize_keys
    end

    def authorize_url
      state = SecureRandom.base64(64)
      session[auth_state_key] = state
      session[:auth_on_failure_path] = "#{new_project_path}#import_project"
      oauth_client.auth_code.authorize_url(
        redirect_uri: callback_import_url,
        # read:org only required for collaborator import, which is optional,
        # but at the time of this OAuth request we do not know which optional
        # configuration the user will select because the options are only shown
        # after authenticating
        scope: 'repo, read:org',
        state: state
      )
    end

    def get_token(code)
      oauth_client.auth_code.get_token(code).token
    end

    def missing_oauth_config
      session[access_token_key] = nil

      message = _('Missing OAuth configuration for GitHub.')

      respond_to do |format|
        format.json do
          render json: { errors: message }, status: :unauthorized
        end

        format.any do
          redirect_to new_import_url,
            alert: message
        end
      end
    end

    def callback_import_url
      public_send("users_import_#{provider_name}_callback_url", extra_import_params.merge({ namespace_id: params[:namespace_id] })) # rubocop:disable GitlabSecurity/PublicSend
    end

    def extra_import_params
      {}
    end
  end
end
==== ./strong_pagination_params.rb ====
# frozen_string_literal: true

module StrongPaginationParams
  extend ActiveSupport::Concern

  PAGINATION_PARAMS = [:page, :per_page, :limit, :sort, :order_by, :pagination].freeze

  def pagination_params
    params.permit(PAGINATION_PARAMS)
  end
end
==== ./content_security_policy_patch.rb ====
# frozen_string_literal: true

# TEMPORARY PATCH - REMOVE AFTER RAILS 7.2 MIGRATION IS COMPLETE
#
# This patch provides backwards compatibility for content_security_policy_with_context
# during the Rails 7.2 upgrade process.
#
# TODO: Remove this entire file once all controllers have been updated to use
# the native content_security_policy method instead of content_security_policy_with_context.
#
# Migration steps:
# 1. Update all controllers to use content_security_policy instead of content_security_policy_with_context
# 2. Remove this file

module ContentSecurityPolicyPatch
  def content_security_policy_with_context(enabled = true, **options, &block)
    if Rails.gem_version >= Gem::Version.new("7.2")
      # For Rails 7.2+, redirect to the native implementation
      content_security_policy(enabled, **options, &block)
    else
      # Original patch implementation for Rails < 7.2
      before_action(options) do
        if block
          policy = current_content_security_policy
          instance_exec(policy, &block)
          request.content_security_policy = policy
        end

        request.content_security_policy = nil unless enabled
      end
    end
  end
end
==== ./check_initial_setup.rb ====
# frozen_string_literal: true

module CheckInitialSetup
  extend ActiveSupport::Concern

  included do
    helper_method :in_initial_setup_state?
  end

  def in_initial_setup_state?
    return false unless User.limit(2).count == 1 # Count as much 2 to know if we have exactly one

    user = User.admins.last

    return false unless user && user.require_password_creation_for_web?

    true
  end
end
==== ./render_access_tokens.rb ====
# frozen_string_literal: true

module RenderAccessTokens
  extend ActiveSupport::Concern

  def active_access_tokens
    tokens = finder(state: 'active', sort: 'expires_asc').execute.preload_users
    size = tokens.size

    tokens = tokens.page(page)
    add_pagination_headers(tokens)

    [represent(tokens), size]
  end

  def inactive_access_tokens
    finder(state: 'inactive', sort: 'updated_at_desc').execute.preload_users
  end

  def add_pagination_headers(relation)
    Gitlab::Pagination::OffsetHeaderBuilder.new(
      request_context: self,
      per_page: relation.limit_value,
      page: relation.current_page,
      next_page: relation.next_page,
      prev_page: relation.prev_page,
      total: relation.total_count,
      params: params.permit(:page, :per_page)
    ).execute
  end

  def page
    (pagination_params[:page] || 1).to_i
  end

  def expiry_ics(tokens)
    cal = Icalendar::Calendar.new
    tokens.each do |token|
      cal.event do |event|
        event.dtstart = Icalendar::Values::Date.new(token[:expires_at].delete('-'))
        event.dtend = Icalendar::Values::Date.new(token[:expires_at].delete('-'))
        event.summary = "Token #{token[:name]} expires today"
      end
    end
    cal.to_ical
  end
end
==== ./workhorse_request.rb ====
# frozen_string_literal: true

module WorkhorseRequest
  extend ActiveSupport::Concern

  included do
    before_action :verify_workhorse_api!
  end

  private

  def verify_workhorse_api!
    Gitlab::Workhorse.verify_api_request!(request.headers)
  end
end
