# frozen_string_literal: true

module Groups
  module Security
    module ComplianceDashboard
      class FrameworksController < Groups::ApplicationController
        include Groups::SecurityFeaturesHelper
        include Gitlab::Utils::StrongMemoize

        layout 'group'

        before_action :authorize_compliance_dashboard!
        before_action :authorize_admin_compliance_framework!

        feature_category :compliance_management

        def show
          respond_to do |format|
            format.json do
              if export_service_response.success?
                send_data(
                  export_service_response.payload,
                  filename: "#{framework.filename}.json",
                  type: 'application/json',
                  disposition: 'attachment'
                )
              else
                render json: { error: export_service_response.message }.to_json, status: :internal_server_error
              end
            end
          end
        end

        private

        def export_service_response
          ComplianceManagement::Frameworks::JsonExportService.new(
            user: current_user,
            group: group,
            framework: framework
          ).execute
        end
        strong_memoize_attr :export_service_response

        def framework = group.compliance_management_frameworks.find(params.permit(:id)[:id])
        strong_memoize_attr :framework
      end
    end
  end
end
# frozen_string_literal: true

module ComplianceManagement
  module Frameworks
    class JsonExportService
      def initialize(user:, group:, framework:)
        @user = user
        @group = group
        @framework = framework
      end

      def execute
        return ServiceResponse.error(message: 'namespace must be a group') unless group.is_a?(Group)
        return ServiceResponse.error(message: "Access to group denied for user with ID: #{user.id}") unless allowed?

        begin
          success
        rescue StandardError => e
          Gitlab::ErrorTracking.track_exception(e, group_id: group.id, user_id: user.id, framework_id: framework.id)
          error
        end
      end

      private

      attr_reader :user, :group, :framework

      def allowed? = Ability.allowed?(user, :admin_compliance_framework, group)
      def success = ServiceResponse.success(payload:)
      def error = ServiceResponse.error(message: _('Failed to export framework'))

      def payload
        {
          name: framework.name,
          description: framework.description,
          color: framework.color,
          requirements: framework.compliance_requirements.map do |requirement|
            {
              name: requirement.name,
              description: requirement.description,
              controls: requirement.compliance_requirements_controls.map do |control|
                {
                  name: control.name,
                  control_type: control.control_type,
                  expression: control.expression_as_hash
                }
              end
            }
          end
        }.to_json
      end
    end
  end
end
# frozen_string_literal: true

module Groups
  module Security
    module ComplianceDashboard
      class ExportsController < Groups::ApplicationController
        include Groups::SecurityFeaturesHelper

        before_action :authorize_compliance_dashboard!
        before_action :authorize_read_compliance_adherence_report!, only: :compliance_status_report
        before_action :authorize_read_compliance_violations_report!, only: :violations_report

        feature_category :compliance_management

        def compliance_status_report
          ComplianceManagement::ComplianceFramework::ProjectRequirementStatuses::ExportService
            .new(user: current_user, group: group).email_export

          flash[:notice] = _('After the report is generated, an email will be sent with the report attached.')

          redirect_to group_security_compliance_dashboard_path(group)
        end

        def violations_report
          ComplianceManagement::Groups::ComplianceViolations::ExportService
            .new(user: current_user, group: group).email_export

          flash[:notice] = _('After the report is generated, an email will be sent with the report attached.')

          redirect_to group_security_compliance_dashboard_path(group)
        end
      end
    end
  end
end
# frozen_string_literal: true

class Groups::ApplicationController < ApplicationController
  include RoutableActions
  include ControllerWithCrossProjectAccessCheck
  include SortingHelper
  include SortingPreference

  layout 'group'

  skip_before_action :authenticate_user!
  before_action :group
  before_action :set_sorting
  requires_cross_project_access

  before_action do
    push_namespace_setting(:math_rendering_limits_enabled, @group)
  end

  private

  def group
    @group ||= find_routable!(Group, params[:group_id] || params[:id], request.fullpath)
  end

  def group_projects
    @projects ||= GroupProjectsFinder.new(group: group, current_user: current_user).execute
  end

  def group_projects_with_subgroups
    @group_projects_with_subgroups ||= GroupProjectsFinder.new(
      group: group,
      current_user: current_user,
      options: { include_subgroups: true }
    ).execute
  end

  def authorize_admin_group!
    render_404 unless can?(current_user, :admin_group, group)
  end

  def authorize_create_deploy_token!
    render_404 unless can?(current_user, :create_deploy_token, group)
  end

  def authorize_destroy_deploy_token!
    render_404 unless can?(current_user, :destroy_deploy_token, group)
  end

  def authorize_admin_group_member!
    render_403 unless can?(current_user, :admin_group_member, group)
  end

  def authorize_owner_access!
    render_403 unless can?(current_user, :owner_access, group)
  end

  def authorize_billings_page!
    render_404 unless can?(current_user, :read_billing, group)
  end

  def authorize_read_group_member!
    render_403 unless can?(current_user, :read_group_member, group)
  end

  def build_canonical_path(group)
    params[:group_id] = group.to_param

    url_for(safe_params)
  end

  def set_sorting
    @group_projects_sort = set_sort_order(Project::SORTING_PREFERENCE_FIELD, sort_value_name) if has_project_list?
  end

  def has_project_list?
    false
  end

  def validate_crm_group!
    render_404 unless group.crm_group?
  end

  def authorize_action!(action)
    access_denied! unless can?(current_user, action, group)
  end

  def respond_to_missing?(method, *args)
    case method.to_s
    when /\Aauthorize_(.*)!\z/
      true
    else
      super
    end
  end

  def method_missing(method_sym, *arguments, &block)
    case method_sym.to_s
    when /\Aauthorize_(.*)!\z/
      authorize_action!(Regexp.last_match(1).to_sym)
    else
      super
    end
  end
end

Groups::ApplicationController.prepend_mod_with('Groups::ApplicationController')
# frozen_string_literal: true

module Groups::SecurityFeaturesHelper
  def group_level_compliance_dashboard_available?(group)
    group.licensed_feature_available?(:group_level_compliance_dashboard) &&
      can?(current_user, :read_compliance_dashboard, group)
  end

  def authorize_compliance_dashboard!
    render_404 unless group_level_compliance_dashboard_available?(group)
  end

  def group_level_credentials_inventory_available?(group)
    can?(current_user, :read_group_credentials_inventory, group)
  end

  def group_level_security_dashboard_data(group)
    {
      projects_endpoint: expose_url(api_v4_groups_projects_path(id: group.id)),
      group_full_path: group.full_path,
      group_security_vulnerabilities_path: group_security_vulnerabilities_path(group),
      no_vulnerabilities_svg_path: image_path('illustrations/empty-state/empty-search-md.svg'),
      empty_state_svg_path: image_path('illustrations/empty-state/empty-dashboard-md.svg'),
      security_dashboard_empty_svg_path: image_path('illustrations/empty-state/empty-secure-md.svg'),
      vulnerabilities_export_endpoint: expose_path(api_v4_security_groups_vulnerability_exports_path(id: group.id)),
      vulnerabilities_pdf_export_endpoint: expose_path(api_v4_security_groups_vulnerability_exports_path(id: group.id,
        params: { export_format: :pdf })),
      can_admin_vulnerability: can?(current_user, :admin_vulnerability, group).to_s,
      can_view_false_positive: group.licensed_feature_available?(:sast_fp_reduction).to_s,
      has_projects: Project.for_group_and_its_subgroups(group).any?.to_s,
      show_retention_alert: ::Gitlab.com?.to_s, # rubocop:disable Gitlab/AvoidGitlabInstanceChecks -- We want to display this banner to all GitLab.com users and hide it for self-hosted and dedicated customers.
      dismissal_descriptions: dismissal_descriptions.to_json
    }
  end

  def group_level_security_inventory_data(group)
    {
      group_full_path: group.full_path,
      group_name: group.name,
      new_project_path: new_project_path(namespace_id: group.id)
    }
  end

  def group_security_discover_data(group)
    content = 'discover-group-security'

    {
      link: {
        main: new_trial_registration_path(glm_source: 'gitlab.com', glm_content: content),
        secondary: group_billings_path(group.root_ancestor, source: content)
      }
    }
  end

  def group_security_configuration_data(group)
    {
      group_full_path: group.full_path
    }
  end
end
