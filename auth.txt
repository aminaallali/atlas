==== /workspace/gitlab/app/controllers/admin/sessions_controller.rb ====
# frozen_string_literal: true

class Admin::SessionsController < ApplicationController
  include AuthenticatesWithTwoFactorForAdminMode
  include InternalRedirect
  include RendersLdapServers

  before_action :user_is_admin!

  feature_category :system_access

  def new
    if current_user_mode.admin_mode?
      redirect_to redirect_path, notice: _('Admin mode already enabled')
    else
      current_user_mode.request_admin_mode! unless current_user_mode.admin_mode_requested?
      store_location_for(:redirect, redirect_path)
    end
  end

  def create
    if two_factor_enabled_for_user?
      admin_mode_authenticate_with_two_factor
    elsif current_user_mode.enable_admin_mode!(password: user_params[:password])
      redirect_to redirect_path, notice: _('Admin mode enabled')
    else
      flash.now[:alert] = _('Invalid login or password')
      render :new
    end
  rescue Gitlab::Auth::CurrentUserMode::NotRequestedError
    redirect_to new_admin_session_path,
      alert: _('Re-authentication period expired or never requested. Please try again')
  end

  def destroy
    current_user_mode.disable_admin_mode!

    if Feature.enabled?(:omniauth_step_up_auth_for_admin_mode, current_user)
      ::Gitlab::Auth::Oidc::StepUpAuthentication.disable_step_up_authentication!(session: session, scope: :admin_mode)
    end

    redirect_to root_path, status: :found, notice: _('Admin mode disabled')
  end

  private

  def user_is_admin!
    render_404 unless current_user&.can_access_admin_area?
  end

  def two_factor_enabled_for_user?
    current_user&.two_factor_enabled?
  end

  def redirect_path
    redirect_to_path = safe_redirect_path(stored_location_for(:redirect)) || safe_redirect_path_for_url(request.referer)

    if redirect_to_path &&
        excluded_redirect_paths.none? { |excluded| redirect_to_path.include?(excluded) }
      redirect_to_path
    else
      admin_root_path
    end
  end

  def excluded_redirect_paths
    [new_admin_session_path, admin_session_path]
  end

  def user_params
    params.fetch(:user, {}).permit(:password, :otp_attempt, :device_response) # rubocop:disable Rails/StrongParams -- fetch is safely followed by permit
  end

  def valid_otp_attempt?(user)
    otp_validation_result =
      ::Users::ValidateManualOtpService.new(user).execute(user_params[:otp_attempt])
    valid_otp_attempt = otp_validation_result[:status] == :success

    return valid_otp_attempt if Gitlab::Database.read_only?

    valid_otp_attempt || user.invalidate_otp_backup_code!(user_params[:otp_attempt])
  end
end
==== /workspace/gitlab/app/controllers/application_controller.rb ====
# frozen_string_literal: true

require 'gon'

class ApplicationController < BaseActionController
  use Gitlab::Middleware::ActionControllerStaticContext

  include Gitlab::GonHelper
  include Gitlab::NoCacheHeaders
  include GitlabRoutingHelper
  include PageLayoutHelper
  include SafeParamsHelper
  include WorkhorseHelper
  include EnforcesTwoFactorAuthentication
  include WithPerformanceBar
  include Gitlab::SearchContext::ControllerConcern
  include PreferredLanguageSwitcher
  include SessionlessAuthentication
  include SessionsHelper
  include ConfirmEmailWarning
  include InitializesCurrentUserMode
  include Impersonation
  include Gitlab::Logging::CloudflareHelper
  include Gitlab::Utils::StrongMemoize
  include ::Gitlab::EndpointAttributes
  include FlocOptOut
  include CheckRateLimit
  include RequestPayloadLogger
  include StrongPaginationParams
  include Gitlab::HttpRouter::RuleContext
  include Gitlab::HttpRouter::RuleMetrics

  around_action :set_current_ip_address

  before_action :authenticate_user!, except: [:route_not_found]
  before_action :set_current_organization
  before_action :enforce_terms!, if: :should_enforce_terms?
  before_action :check_password_expiration, if: :html_request?
  before_action :ldap_security_check
  before_action :default_headers
  before_action :add_gon_variables, if: :html_request?
  before_action :configure_permitted_parameters, if: :devise_controller?
  before_action :require_email, unless: :devise_controller?
  before_action :active_user_check, unless: :devise_controller?
  before_action :set_usage_stats_consent_flag
  before_action :check_impersonation_availability
  before_action :increment_http_router_metrics

  # Make sure the `auth_user` is memoized so it can be logged, we do this after
  # all other before filters that could have set the user.
  before_action :auth_user

  around_action :set_current_context

  around_action :sessionless_bypass_admin_mode!, if: :sessionless_user?
  around_action :set_locale
  around_action :set_session_storage
  around_action :set_current_admin

  after_action :set_page_title_header, if: :json_request?

  protect_from_forgery with: :exception, prepend: true

  helper_method :can?
  helper_method :import_sources_enabled?, :github_import_enabled?,
    :gitea_import_enabled?, :github_import_configured?,
    :bitbucket_import_enabled?, :bitbucket_import_configured?,
    :bitbucket_server_import_enabled?, :fogbugz_import_enabled?,
    :git_import_enabled?, :gitlab_project_import_enabled?,
    :manifest_import_enabled?, :masked_page_url

  rescue_from Encoding::CompatibilityError do |exception|
    log_exception(exception)
    render "errors/encoding", layout: "errors", status: :internal_server_error
  end

  rescue_from ActiveRecord::RecordNotFound do |exception|
    log_exception(exception)
    render_404
  end

  rescue_from(ActionController::UnknownFormat) do
    render_404
  end

  rescue_from Gitlab::Access::AccessDeniedError do |exception|
    render_403
  end

  rescue_from Browser::Error do |e|
    render plain: e.message, status: :forbidden
  end

  rescue_from Gitlab::Auth::IpBlocked do |e|
    Gitlab::AuthLogger.error(
      message: 'Rack_Attack',
      env: :blocklist,
      remote_ip: request.ip,
      request_method: request.request_method,
      path: request.filtered_path
    )

    render plain: e.message, status: :forbidden
  end

  rescue_from Gitlab::Auth::TooManyIps do |e|
    head :forbidden, retry_after: Gitlab::Auth::UniqueIpsLimiter.config.unique_ips_limit_time_window
  end

  rescue_from RateLimitedService::RateLimitedError do |e|
    e.log_request(request, current_user)
    response.headers.merge!(e.headers)
    render plain: e.message, status: :too_many_requests
  end

  rescue_from Gitlab::Git::ResourceExhaustedError do |e|
    response.headers.merge!(e.headers)
    render_503(e.message)
  end

  rescue_from Regexp::TimeoutError do |e|
    log_exception(e)
    head :service_unavailable
  end

  def redirect_back_or_default(default: root_path, options: {})
    redirect_back(fallback_location: default, **options)
  end

  def not_found
    render_404
  end

  def route_not_found
    if current_user || browser.bot.search_engine?
      not_found
    else
      store_location_for(:user, request.fullpath) unless request.xhr?

      redirect_to new_user_session_path, alert: I18n.t('devise.failure.unauthenticated')
    end
  end

  def handle_unverified_request
    Gitlab::Auth::Activity
      .new(controller: self)
      .user_csrf_token_mismatch!

    super
  end

  def render(*args)
    super.tap do
      # Set a header for custom error pages to prevent them from being intercepted by gitlab-workhorse
      if (400..599).cover?(response.status) && workhorse_excluded_content_types.include?(response.media_type)
        response.headers['X-GitLab-Custom-Error'] = '1'
      end
    end
  end

  def feature_category
    self.class.feature_category_for_action(action_name).to_s
  end

  def urgency
    self.class.urgency_for_action(action_name)
  end

  protected

  def workhorse_excluded_content_types
    @workhorse_excluded_content_types ||= %w[text/html application/json]
  end

  ##
  # Controllers such as GitHttpController may use alternative methods
  # (e.g. tokens) to authenticate the user, whereas Devise sets current_user.
  #
  def auth_user
    if user_signed_in?
      current_user
    else
      try(:authenticated_user)
    end
  end
  strong_memoize_attr :auth_user

  def log_exception(exception)
    # At this point, the controller already exits set_current_context around
    # block. To maintain the context while handling error exception, we need to
    # set the context again
    set_current_context do
      Gitlab::ErrorTracking.track_exception(exception)
    end

    backtrace_cleaner = request.env["action_dispatch.backtrace_cleaner"]
    application_trace = ActionDispatch::ExceptionWrapper.new(backtrace_cleaner, exception).application_trace
    application_trace.map! { |t| "  #{t}\n" }
    logger.error "\n#{exception.class.name} (#{exception.message}):\n#{application_trace.join}"
  end

  def after_sign_in_path_for(resource)
    redirect_location = stored_location_for(:redirect)
    redirect_location ||= stored_location_for(resource) if resource.present?
    redirect_location || root_path
  end

  def after_sign_out_path_for(resource)
    Gitlab::CurrentSettings.after_sign_out_path.presence || new_user_session_path
  end

  def can?(user, action, subject = :global)
    Ability.allowed?(user, action, subject)
  end

  def access_denied!(message = nil, status = nil)
    # If we display a custom access denied message to the user, we don't want to
    # hide existence of the resource, rather tell them they cannot access it using
    # the provided message
    status ||= message.present? ? :forbidden : :not_found
    template =
      if status == :not_found
        "errors/not_found"
      else
        "errors/access_denied"
      end

    respond_to do |format|
      format.html do
        render template, layout: "errors", status: status, locals: { message: message }
      end
      format.any { head status }
    end
  end

  def git_not_found!
    render template: "errors/git_not_found", formats: :html, layout: "errors", status: :not_found
  end

  def render_403
    respond_to do |format|
      format.html { render template: "errors/access_denied", formats: :html, layout: "errors", status: :forbidden }
      format.any { head :forbidden }
    end
  end

  def render_404
    respond_to do |format|
      format.html { render template: "errors/not_found", formats: :html, layout: "errors", status: :not_found }
      # Prevent the Rails CSRF protector from thinking a missing .js file is a JavaScript file
      format.js { render json: '', status: :not_found, content_type: 'application/json' }
      format.any { head :not_found }
    end
  end

  def render_503(message = nil)
    respond_to do |format|
      format.html { render template: "errors/service_unavailable", formats: :html, layout: "errors", status: :service_unavailable, locals: { message: message } }
      format.any { head :service_unavailable }
    end
  end

  def render_409(message = nil)
    respond_to do |format|
      format.html do
        render template: "errors/request_conflict", formats: :html, layout: "errors", status: :conflict,
          locals: { message: message }
      end
      format.any { head :conflict }
    end
  end

  def respond_422
    head :unprocessable_entity
  end

  def no_cache_headers
    DEFAULT_GITLAB_NO_CACHE_HEADERS.each do |k, v|
      headers[k] = v
    end
  end

  def stream_headers
    headers['Content-Length'] = nil
    headers['X-Accel-Buffering'] = 'no' # Disable buffering on Nginx
    headers['Last-Modified'] = '0' # Prevent buffering via Rack::ETag middleware
  end

  def default_headers
    headers['X-Frame-Options'] = 'SAMEORIGIN'
    headers['X-XSS-Protection'] = '1; mode=block'
    headers['X-UA-Compatible'] = 'IE=edge'
    headers['X-Content-Type-Options'] = 'nosniff'
  end

  def stream_csv_headers(csv_filename)
    no_cache_headers
    stream_headers

    headers['Content-Type'] = 'text/csv; charset=utf-8; header=present'
    safe_filename = sanitize_filename_for_header(csv_filename)
    headers['Content-Disposition'] = ActionDispatch::Http::ContentDisposition.format(disposition: 'attachment', filename: safe_filename)
  end

  private

  def sanitize_filename_for_header(name)
    str = name.to_s.encode('UTF-8', invalid: :replace, undef: :replace, replace: '')
    str = str.gsub(/[\x00-\x1F\x7F]/, '')
    str = str.gsub(/[\\"]/,'_')
    str = 'download.csv' if str.empty?
    str
  end

  def check_password_expiration
    return if session[:impersonator_id]
    return if current_user.nil?

    if current_user.password_expired? && current_user.allow_password_authentication?
      redirect_to new_user_settings_password_path
    end
  end

  def active_user_check
    return unless current_user && current_user.deactivated?

    sign_out current_user
    flash[:alert] =
      _("Your account has been deactivated by your administrator. Please log back in to reactivate your account.")
    redirect_to new_user_session_path
  end

  def ldap_security_check
    if current_user && current_user.requires_ldap_check?
      return unless current_user.try_obtain_ldap_lease

      unless Gitlab::Auth::Ldap::Access.allowed?(current_user)
        sign_out current_user
        flash[:alert] = _("Access denied for your LDAP account.")
        redirect_to new_user_session_path
      end
    end
  end

  # JSON for infinite scroll via Pager object
  def pager_json(partial, count, locals = {})
    html = render_to_string(
      partial,
      locals: locals,
      layout: false,
      formats: [:html]
    )

    render json: {
      html: html,
      count: count
    }
  end

  def view_to_html_string(partial, locals = {})
    render_to_string(
      partial,
      locals: locals,
      layout: false,
      formats: [:html]
    )
  end

  def configure_permitted_parameters
    devise_parameter_sanitizer.permit(
      :sign_in,
      keys: [:username, :email, :password, :login, :remember_me, :otp_attempt]
    )
  end

  def hexdigest(string)
    Digest::SHA1.hexdigest string
  end

  def require_email
    if current_user && current_user.temp_oauth_email? && session[:impersonator_id].nil?
      redirect_to user_settings_profile_path, notice: _('Please complete your profile with email address')
    end
  end

  def enforce_terms!
    return unless current_user
    return if current_user.terms_accepted?

    message = _("Please accept the Terms of Service before continuing.")

    if sessionless_user?
      access_denied!(message)
    else
      # Redirect to the destination if the request is a get.
      # Redirect to the source if it was a post, so the user can re-submit after
      # accepting the terms.
      redirect_path = if request.get?
                        request.fullpath
                      elsif request.referer
                        URI(request.referer).path
                      end

      flash[:notice] = message
      redirect_to terms_path(redirect: redirect_path), status: :found
    end
  end

  def import_sources_enabled?
    !Gitlab::CurrentSettings.import_sources.empty?
  end

  def bitbucket_server_import_enabled?
    Gitlab::CurrentSettings.import_sources.include?('bitbucket_server')
  end

  def github_import_enabled?
    Gitlab::CurrentSettings.import_sources.include?('github')
  end

  def gitea_import_enabled?
    Gitlab::CurrentSettings.import_sources.include?('gitea')
  end

  def github_import_configured?
    Gitlab::Auth::OAuth::Provider.enabled?(:github)
  end

  def bitbucket_import_enabled?
    Gitlab::CurrentSettings.import_sources.include?('bitbucket')
  end

  def bitbucket_import_configured?
    Gitlab::Auth::OAuth::Provider.enabled?(:bitbucket)
  end

  def fogbugz_import_enabled?
    Gitlab::CurrentSettings.import_sources.include?('fogbugz')
  end

  def git_import_enabled?
    Gitlab::CurrentSettings.import_sources.include?('git')
  end

  def gitlab_project_import_enabled?
    Gitlab::CurrentSettings.import_sources.include?('gitlab_project')
  end

  def manifest_import_enabled?
    Gitlab::CurrentSettings.import_sources.include?('manifest')
  end

  def set_current_context(&block)
    # even though feature_category is pre-populated by
    # Gitlab::Middleware::ActionControllerStaticContext
    # using the static annotation on controllers, the
    # controllers can override feature_category conditionally
    Gitlab::ApplicationContext.push(feature_category: feature_category) if feature_category.present?

    Gitlab::ApplicationContext.push(
      user: -> { context_user },
      project: -> { @project if @project&.persisted? },
      namespace: -> { @group if @group&.persisted? },
      remote_ip: request.ip,
      **http_router_rule_context
    )
    yield
  ensure
    @current_context = Gitlab::ApplicationContext.current
  end

  def set_current_ip_address(&block)
    ::Gitlab::IpAddressState.with(request.ip, &block) # rubocop: disable CodeReuse/ActiveRecord -- not an ActiveRecord model
  end

  def set_locale(&block)
    if current_user
      Gitlab::I18n.with_user_locale(current_user, &block)
    else
      Gitlab::I18n.with_locale(preferred_language, &block)
    end
  end

  def set_session_storage(&block)
    return yield if sessionless_user?

    Gitlab::Session.with_session(session, &block)
  end

  def set_page_title_header
    # Per https://www.rfc-editor.org/rfc/rfc5987, headers need to be ISO-8859-1, not UTF-8
    response.headers['Page-Title'] = Addressable::URI.encode_component(page_title('GitLab'))
  end

  def set_current_admin(&block)
    return yield unless Gitlab::CurrentSettings.admin_mode
    return yield unless current_user

    Gitlab::Auth::CurrentUserMode.with_current_admin(current_user, &block)
  end

  def html_request?
    request.format.html?
  end

  def json_request?
    request.format.json?
  end

  def should_enforce_terms?
    return false unless Gitlab::CurrentSettings.current_application_settings.enforce_terms

    html_request? && !devise_controller?
  end

  def public_visibility_restricted?
    Gitlab::VisibilityLevel.public_visibility_restricted?
  end

  def set_usage_stats_consent_flag
    return unless current_user
    return if sessionless_user?
    return if session.has_key?(:ask_for_usage_stats_consent)

    session[:ask_for_usage_stats_consent] = current_user.requires_usage_stats_consent?

    disable_usage_stats if session[:ask_for_usage_stats_consent]
  end

  def disable_usage_stats
    application_setting_params = {
      usage_ping_enabled: false,
      version_check_enabled: false,
      skip_usage_stats_user: true
    }
    settings = Gitlab::CurrentSettings.current_application_settings

    ApplicationSettings::UpdateService
      .new(settings, current_user, application_setting_params)
      .execute
  end

  def allow_gitaly_ref_name_caching
    ::Gitlab::GitalyClient.allow_ref_name_caching do
      yield
    end
  end

  # Avoid loading the auth_user again after the request. Otherwise calling
  # `auth_user` again would also trigger the Warden callbacks again
  def context_user
    auth_user if strong_memoized?(:auth_user)
  end

  # Used by `set_current_organization` in BaseActionController
  def organization_params
    params.permit(
      :controller, :namespace_id, :group_id, :id, :organization_path
    )
  end
end

ApplicationController.prepend_mod
==== /workspace/gitlab/app/controllers/concerns/authenticates_with_two_factor_for_admin_mode.rb ====
# frozen_string_literal: true

module AuthenticatesWithTwoFactorForAdminMode
  extend ActiveSupport::Concern

  included do
    include AuthenticatesWithTwoFactor
  end

  def admin_mode_prompt_for_two_factor(user)
    @user = user # rubocop:disable Gitlab/ModuleWithInstanceVariables -- Set @user for Admin views

    return handle_locked_user(user) unless user.can?(:log_in)

    session[:otp_user_id] = user.id
    setup_webauthn_authentication(user)

    render 'admin/sessions/two_factor', layout: 'application'
  end

  def admin_mode_authenticate_with_two_factor
    user = current_user

    return handle_locked_user(user) unless user.can?(:log_in)

    if user_params[:otp_attempt].present? && session[:otp_user_id]
      admin_mode_authenticate_with_two_factor_via_otp(user)
    elsif user_params[:device_response].present? && session[:otp_user_id]
      admin_mode_authenticate_with_two_factor_via_webauthn(user)
    elsif user && user.valid_password?(user_params[:password])
      admin_mode_prompt_for_two_factor(user)
    else
      invalid_login_redirect
    end
  end

  def admin_mode_authenticate_with_two_factor_via_otp(user)
    if valid_otp_attempt?(user)
      # Remove any lingering user data from login
      session.delete(:otp_user_id)

      user.save! unless Gitlab::Database.read_only?

      # The admin user has successfully passed 2fa, enable admin mode ignoring password
      enable_admin_mode
    else
      admin_handle_two_factor_failure(user, 'OTP', _('Invalid two-factor code.'))
    end
  end

  def admin_mode_authenticate_with_two_factor_via_webauthn(user)
    if Webauthn::AuthenticateService.new(user, user_params[:device_response], session[:challenge]).execute
      admin_handle_two_factor_success
    else
      admin_handle_two_factor_failure(user, 'WebAuthn', _('Authentication via WebAuthn device failed.'))
    end
  end

  private

  def enable_admin_mode
    if current_user_mode.enable_admin_mode!(skip_password_validation: true)
      redirect_to redirect_path, notice: _('Admin mode enabled')
    else
      invalid_login_redirect
    end
  end

  def invalid_login_redirect
    flash.now[:alert] = _('Invalid login or password')
    render :new
  end

  def admin_handle_two_factor_success
    # Remove any lingering user data from login
    session.delete(:otp_user_id)
    session.delete(:challenge)

    # The admin user has successfully passed 2fa, enable admin mode ignoring password
    enable_admin_mode
  end

  def admin_handle_two_factor_failure(user, method, message)
    user.increment_failed_attempts!
    log_failed_two_factor(user, method)

    Gitlab::AppLogger.info("Failed Admin Mode Login: user=#{user.username} ip=#{request.remote_ip} method=#{method}")
    flash.now[:alert] = message
    admin_mode_prompt_for_two_factor(user)
  end
end
==== /workspace/gitlab/app/controllers/concerns/authenticates_with_two_factor.rb ====
# frozen_string_literal: true

# == AuthenticatesWithTwoFactor
#
# Controller concern to handle two-factor authentication
module AuthenticatesWithTwoFactor
  extend ActiveSupport::Concern

  # Store the user's ID in the session for later retrieval and render the
  # two factor code prompt
  #
  # The user must have been authenticated with a valid login and password
  # before calling this method!
  #
  # user - User record
  #
  # Returns nil
  def prompt_for_two_factor(user)
    @user = user # rubocop:disable Gitlab/ModuleWithInstanceVariables -- Set @user for Devise views

    return handle_locked_user(user) unless user.can?(:log_in)

    session[:otp_user_id] = user.id
    session[:user_password_hash] = Digest::SHA256.hexdigest(user.encrypted_password)

    add_gon_variables
    setup_webauthn_authentication(user)

    render 'devise/sessions/two_factor'
  end

  def handle_locked_user(user)
    clear_two_factor_attempt!

    locked_user_redirect(user)
  end

  def locked_user_redirect(user)
    redirect_to new_user_session_path, alert: locked_user_redirect_alert(user)
  end

  def authenticate_with_two_factor
    user = self.resource = find_user
    return handle_locked_user(user) unless user.can?(:log_in)
    return handle_changed_user(user) if user_password_changed?(user)

    if user_params[:otp_attempt].present? && session[:otp_user_id]
      authenticate_with_two_factor_via_otp(user)
    elsif user_params[:device_response].present? && session[:otp_user_id]
      authenticate_with_two_factor_via_webauthn(user)
    elsif user && user.valid_password?(user_params[:password])
      prompt_for_two_factor(user)
    end
  rescue ActiveRecord::RecordInvalid => e
    # We expect User to always be valid.
    # Otherwise, raise internal server error instead of unprocessable entity to improve observability/alerting
    if e.record.is_a?(User)
      raise e.message
    else
      raise e
    end
  end

  private

  def locked_user_redirect_alert(user)
    if user.access_locked?
      _('Your account is locked.')
    elsif !user.confirmed?
      I18n.t('devise.failure.unconfirmed')
    else
      _('Invalid login or password')
    end
  end

  def clear_two_factor_attempt!
    session.delete(:otp_user_id)
    session.delete(:user_password_hash)
    session.delete(:challenge)
  end

  def authenticate_with_two_factor_via_otp(user)
    if valid_otp_attempt?(user)
      # Remove any lingering user data from login
      clear_two_factor_attempt!

      remember_me(user) if user_params[:remember_me] == '1'
      user.save!
      sign_in(user, message: :two_factor_authenticated, event: :authentication)
    else
      send_two_factor_otp_attempt_failed_email(user)
      handle_two_factor_failure(user, 'OTP', _('Invalid two-factor code.'))
    end
  end

  def authenticate_with_two_factor_via_webauthn(user)
    if Webauthn::AuthenticateService.new(user, user_params[:device_response], session[:challenge]).execute
      handle_two_factor_success(user)
    else
      handle_two_factor_failure(user, 'WebAuthn', _('Authentication via WebAuthn device failed.'))
    end
  end

  # rubocop: disable CodeReuse/ActiveRecord
  def setup_webauthn_authentication(user)
    if user.webauthn_registrations.present?

      webauthn_registration_ids = user.webauthn_registrations.pluck(:credential_xid)

      get_options = WebAuthn::Credential.options_for_get(
        allow: webauthn_registration_ids,
        user_verification: 'discouraged',
        extensions: { appid: WebAuthn.configuration.origin }
      )
      session[:challenge] = get_options.challenge
      gon.push(webauthn: { options: Gitlab::Json.dump(get_options) })
    end
  end
  # rubocop: enable CodeReuse/ActiveRecord

  def handle_two_factor_success(user)
    # Remove any lingering user data from login
    clear_two_factor_attempt!

    remember_me(user) if user_params[:remember_me] == '1'
    sign_in(user, message: :two_factor_authenticated, event: :authentication)
  end

  def handle_two_factor_failure(user, method, message)
    user.increment_failed_attempts!
    log_failed_two_factor(user, method)

    Gitlab::AppLogger.info("Failed Login: user=#{user.username} ip=#{request.remote_ip} method=#{method}")
    flash.now[:alert] = message
    prompt_for_two_factor(user)
  end

  def send_two_factor_otp_attempt_failed_email(user)
    user.notification_service.two_factor_otp_attempt_failed(user, request.remote_ip)
  end

  def log_failed_two_factor(user, method)
    # overridden in EE
  end

  def handle_changed_user(user)
    clear_two_factor_attempt!

    redirect_to new_user_session_path, alert: _('An error occurred. Please sign in again.')
  end

  # If user has been updated since we validated the password,
  # the password might have changed.
  def user_password_changed?(user)
    return false unless session[:user_password_hash]

    Digest::SHA256.hexdigest(user.encrypted_password) != session[:user_password_hash]
  end
end

AuthenticatesWithTwoFactor.prepend_mod_with('AuthenticatesWithTwoFactor')
==== /workspace/gitlab/app/controllers/concerns/ci/auth_build_trace.rb ====
# frozen_string_literal: true

module Ci
  module AuthBuildTrace
    extend ActiveSupport::Concern

    def authorize_read_build_trace!
      return if can?(current_user, :read_build_trace, build)

      if build.debug_mode?
        access_denied!(
          _('You must have developer or higher permissions in the associated project to view job logs when debug ' \
            "trace is enabled. To disable debug trace, set the 'CI_DEBUG_TRACE' and 'CI_DEBUG_SERVICES' variables to " \
            "'false' in your pipeline configuration or CI/CD settings. If you must view this job log, " \
            'a project maintainer or owner must add you to the project with developer permissions or higher.')
        )
      else
        access_denied!(_('The current user is not authorized to access the job log.'))
      end
    end
  end
end
==== /workspace/gitlab/app/controllers/concerns/enforces_admin_authentication.rb ====
# frozen_string_literal: true

# == EnforcesAdminAuthentication
#
# Controller concern to enforce that users are authenticated as admins
#
# Upon inclusion, adds `authenticate_admin!` as a before_action
#
module EnforcesAdminAuthentication
  extend ActiveSupport::Concern

  included do
    before_action :authenticate_admin!

    def self.authorize!(ability, only:)
      actions = Array(only)

      skip_before_action :authenticate_admin!, only: actions
      before_action -> { authorize_ability!(ability) }, only: actions
    end
  end

  def authenticate_admin!
    return render_404 unless user_is_admin?
    return unless Gitlab::CurrentSettings.admin_mode

    unless current_user_mode.admin_mode?
      current_user_mode.request_admin_mode!
      store_location_for(:redirect, request.fullpath) if storable_location?
      redirect_to(new_admin_session_path, notice: _('Re-authentication required'))
    end
  end

  def storable_location?
    request.path != new_admin_session_path
  end

  private

  def user_is_admin?
    current_user.admin?
  end

  def authorize_ability!(ability)
    return authenticate_admin! if current_user.admin?

    render_404 unless current_user.can?(ability)
  end
end
==== /workspace/gitlab/app/controllers/concerns/enforces_step_up_authentication.rb ====
# frozen_string_literal: true

# Enforces step-up authentication requirements for admin access
#
# This controller concern ensures users complete step-up authentication
# before accessing admin functionality. Include this module in admin
# controllers to enforce the authentication check.
#
# @example
#   class Admin::ApplicationController < ApplicationController
#     include EnforcesStepUpAuthentication
#   end
module EnforcesStepUpAuthentication
  extend ActiveSupport::Concern

  included do
    before_action :enforce_step_up_authentication
  end

  private

  def enforce_step_up_authentication
    return if Feature.disabled?(:omniauth_step_up_auth_for_admin_mode, current_user)

    return if step_up_auth_disabled_for_admin_mode?
    return if step_up_auth_flow_state_success?

    handle_failed_authentication
  end

  def step_up_auth_disabled_for_admin_mode?
    !::Gitlab::Auth::Oidc::StepUpAuthentication.enabled_by_config?
  end

  def step_up_auth_flow_state_success?
    ::Gitlab::Auth::Oidc::StepUpAuthentication.succeeded?(session)
  end

  def handle_failed_authentication
    # We need to disable (reset) the admin mode in order to redirect the user to the admin login page.
    # If we do not do this, the Admin::SessionsController will thinks that the admin mode has been successfully reached
    # and will redirect the user to the path 'admin/dashboard'. But, the check in this EnforceStepUpAuthentication
    # will fail again and redirect the user to the login page which will end up in a loop.
    disable_admin_mode

    redirect_to(new_admin_session_path, notice: _('Step-up auth not successful'))
  end

  def disable_admin_mode
    current_user_mode.disable_admin_mode! if current_user_mode.admin_mode?
  end
end
==== /workspace/gitlab/app/controllers/concerns/enforces_two_factor_authentication.rb ====
# frozen_string_literal: true

# == EnforcesTwoFactorAuthentication
#
# Controller concern to enforce two-factor authentication requirements
#
# Upon inclusion, adds `check_two_factor_requirement` as a before_action,
# and makes `two_factor_grace_period_expired?` and `two_factor_skippable?`
# available as view helpers.
module EnforcesTwoFactorAuthentication
  extend ActiveSupport::Concern

  included do
    before_action :check_two_factor_requirement, except: [:route_not_found]

    # to include this in controllers inheriting from `ActionController::Metal`
    # we need to add this block
    helper_method :two_factor_grace_period_expired?, :two_factor_skippable? if respond_to?(:helper_method)
  end

  def check_two_factor_requirement
    return unless respond_to?(:current_user)

    if two_factor_authentication_required? && current_user_requires_two_factor?
      case self
      when GraphqlController
        render_error(
          format(
            _("Authentication error: enable 2FA in your profile settings to continue using GitLab: %{mfa_help_page}"),
            mfa_help_page: mfa_help_page_url
          ),
          status: :unauthorized
        )
      else
        redirect_to profile_two_factor_auth_path
      end
    end
  end

  def two_factor_authentication_required?
    two_factor_verifier.two_factor_authentication_required?
  end

  def current_user_requires_two_factor?
    two_factor_verifier.current_user_needs_to_setup_two_factor? && !skip_two_factor?
  end

  # rubocop: disable CodeReuse/ActiveRecord
  def execute_action_for_2fa_reason(actions)
    reason = two_factor_verifier.two_factor_authentication_reason
    groups_enforcing_two_factor = current_user.source_groups_of_two_factor_authentication_requirement
                                              .reorder(name: :asc)
    actions[reason].call(groups_enforcing_two_factor)
  end
  # rubocop: enable CodeReuse/ActiveRecord

  def two_factor_grace_period
    two_factor_verifier.two_factor_grace_period
  end

  def two_factor_grace_period_expired?
    two_factor_verifier.two_factor_grace_period_expired?
  end

  def two_factor_skippable?
    two_factor_authentication_required? &&
      !current_user.two_factor_enabled? &&
      !two_factor_grace_period_expired?
  end

  def skip_two_factor?
    session[:skip_two_factor] && session[:skip_two_factor].future?
  end

  def two_factor_verifier
    @two_factor_verifier ||= Gitlab::Auth::TwoFactorAuthVerifier.new(current_user, request)
  end

  def mfa_help_page_url
    Rails.application.routes.url_helpers.help_page_url(
      'user/profile/account/two_factor_authentication.md',
      anchor: 'enable-two-factor-authentication'
    )
  end
end

EnforcesTwoFactorAuthentication.prepend_mod_with('EnforcesTwoFactorAuthentication')
==== /workspace/gitlab/app/controllers/concerns/gitlab_recaptcha.rb ====
# frozen_string_literal: true

module GitlabRecaptcha
  extend ActiveSupport::Concern
  include Recaptcha::Adapters::ControllerMethods
  include RecaptchaHelper

  def load_recaptcha
    recaptcha_enabled? && Gitlab::Recaptcha.load_configurations!
  end

  def check_recaptcha
    return unless load_recaptcha
    return if verify_recaptcha

    flash[:alert] = _('There was an error with the reCAPTCHA. Please solve the reCAPTCHA again.')
    flash.delete :recaptcha_error

    self.resource = resource_class.new

    add_gon_variables

    render action: 'new'
  end
end
==== /workspace/gitlab/app/controllers/concerns/impersonation.rb ====
# frozen_string_literal: true

module Impersonation
  include Gitlab::Utils::StrongMemoize

  SESSION_KEYS_TO_DELETE = %w[
    github_access_token gitea_access_token gitlab_access_token
    bitbucket_token bitbucket_refresh_token bitbucket_server_personal_access_token
    bulk_import_gitlab_access_token fogbugz_token cloud_platform_access_token
  ].freeze

  def current_user
    user = super

    user.impersonator = impersonator if impersonator

    user
  end

  protected

  def check_impersonation_availability
    return unless impersonation_in_progress?

    unless Gitlab.config.gitlab.impersonation_enabled
      stop_impersonation
      access_denied! _('Impersonation has been disabled')
    end
  end

  def stop_impersonation
    log_impersonation_event

    warden.set_user(impersonator, scope: :user)
    session[:impersonator_id] = nil
    clear_access_token_session_keys!

    current_user
  end

  def impersonation_in_progress?
    session[:impersonator_id].present?
  end

  def log_impersonation_event
    Gitlab::AppLogger.info("User #{impersonator.username} has stopped impersonating #{current_user.username}")
  end

  def clear_access_token_session_keys!
    access_tokens_keys = session.keys & SESSION_KEYS_TO_DELETE

    access_tokens_keys.each { |key| session.delete(key) }
  end

  def impersonator
    User.find(session[:impersonator_id]) if session[:impersonator_id]
  end
  strong_memoize_attr :impersonator
end
==== /workspace/gitlab/app/controllers/concerns/import/github_oauth.rb ====
# frozen_string_literal: true

module Import
  module GithubOauth
    extend ActiveSupport::Concern

    OAuthConfigMissingError = Class.new(StandardError)

    included do
      rescue_from OAuthConfigMissingError, with: :missing_oauth_config
    end

    private

    def provider_auth
      return if session[access_token_key].present?

      go_to_provider_for_permissions unless ci_cd_only?
    end

    def ci_cd_only?
      %w[1 true].include?(params[:ci_cd_only])
    end

    def go_to_provider_for_permissions
      redirect_to authorize_url
    end

    def oauth_client
      raise OAuthConfigMissingError unless oauth_config

      oauth_client_from_config
    end

    def oauth_client_from_config
      @oauth_client_from_config ||= ::OAuth2::Client.new(
        oauth_config.app_id,
        oauth_config.app_secret,
        oauth_options.merge(ssl: { verify: oauth_config['verify_ssl'] })
      )
    end

    def oauth_config
      @oauth_config ||= Gitlab::Auth::OAuth::Provider.config_for('github')
    end

    def oauth_options
      return unless oauth_config

      oauth_config.dig('args', 'client_options').to_h.deep_symbolize_keys
    end

    def authorize_url
      state = SecureRandom.base64(64)
      session[auth_state_key] = state
      session[:auth_on_failure_path] = "#{new_project_path}#import_project"
      oauth_client.auth_code.authorize_url(
        redirect_uri: callback_import_url,
        # read:org only required for collaborator import, which is optional,
        # but at the time of this OAuth request we do not know which optional
        # configuration the user will select because the options are only shown
        # after authenticating
        scope: 'repo, read:org',
        state: state
      )
    end

    def get_token(code)
      oauth_client.auth_code.get_token(code).token
    end

    def missing_oauth_config
      session[access_token_key] = nil

      message = _('Missing OAuth configuration for GitHub.')

      respond_to do |format|
        format.json do
          render json: { errors: message }, status: :unauthorized
        end

        format.any do
          redirect_to new_import_url,
            alert: message
        end
      end
    end

    def callback_import_url
      public_send("users_import_#{provider_name}_callback_url", extra_import_params.merge({ namespace_id: params[:namespace_id] })) # rubocop:disable GitlabSecurity/PublicSend
    end

    def extra_import_params
      {}
    end
  end
end
==== /workspace/gitlab/app/controllers/concerns/invisible_captcha_on_signup.rb ====
# frozen_string_literal: true

module InvisibleCaptchaOnSignup
  extend ActiveSupport::Concern

  included do
    invisible_captcha only: :create, on_spam: :on_honeypot_spam_callback, on_timestamp_spam: :on_timestamp_spam_callback
  end

  def on_honeypot_spam_callback
    return unless Gitlab::CurrentSettings.invisible_captcha_enabled

    invisible_captcha_honeypot_counter.increment
    log_request('Invisible_Captcha_Honeypot_Request')

    head(:ok)
  end

  def on_timestamp_spam_callback
    return unless Gitlab::CurrentSettings.invisible_captcha_enabled

    invisible_captcha_timestamp_counter.increment
    log_request('Invisible_Captcha_Timestamp_Request')

    redirect_to new_user_session_path, alert: InvisibleCaptcha.timestamp_error_message
  end

  def invisible_captcha_honeypot_counter
    @invisible_captcha_honeypot_counter ||= Gitlab::Metrics.counter(
      :bot_blocked_by_invisible_captcha_honeypot,
      'Counter of blocked sign up attempts with filled honeypot'
    )
  end

  def invisible_captcha_timestamp_counter
    @invisible_captcha_timestamp_counter ||= Gitlab::Metrics.counter(
      :bot_blocked_by_invisible_captcha_timestamp,
      'Counter of blocked sign up attempts with invalid timestamp'
    )
  end

  def log_request(message)
    request_information = {
      message: message,
      env: :invisible_captcha_signup_bot_detected,
      remote_ip: request.ip,
      request_method: request.request_method,
      path: request.filtered_path
    }

    Gitlab::AuthLogger.error(request_information)
  end
end
==== /workspace/gitlab/app/controllers/concerns/known_sign_in.rb ====
# frozen_string_literal: true

module KnownSignIn
  include Gitlab::Utils::StrongMemoize
  include CookiesHelper

  KNOWN_SIGN_IN_COOKIE = :known_sign_in
  KNOWN_SIGN_IN_COOKIE_EXPIRY = 14.days

  private

  def verify_known_sign_in
    return unless Gitlab::CurrentSettings.notify_on_unknown_sign_in? && current_user

    notify_user unless known_device? || known_remote_ip?

    update_cookie
  end

  def known_remote_ip?
    known_ip_addresses.include?(request.remote_ip)
  end

  def known_device?
    cookies.encrypted[KNOWN_SIGN_IN_COOKIE] == current_user.id
  end

  def update_cookie
    set_secure_cookie(
      KNOWN_SIGN_IN_COOKIE,
      current_user.id,
      type: COOKIE_TYPE_ENCRYPTED,
      httponly: true,
      expires: KNOWN_SIGN_IN_COOKIE_EXPIRY
    )
  end

  def sessions
    ActiveSession.list(current_user).reject(&:is_impersonated)
  end
  strong_memoize_attr :sessions

  def known_ip_addresses
    [current_user.last_sign_in_ip, sessions.map(&:ip_address)].flatten
  end

  def notify_user
    request_info = Gitlab::Auth::VisitorLocation.new(request)
    current_user.notification_service.unknown_sign_in(
      current_user,
      request.remote_ip,
      current_user.current_sign_in_at,
      request_info
    )
  end
end
==== /workspace/gitlab/app/controllers/concerns/oauth_applications.rb ====
# frozen_string_literal: true

module OauthApplications
  extend ActiveSupport::Concern

  CREATED_SESSION_KEY = :oauth_applications_created

  included do
    before_action :prepare_scopes, only: [:create, :update]
  end

  def prepare_scopes
    scopes = params.fetch(:doorkeeper_application, {}).fetch(:scopes, nil)

    params[:doorkeeper_application][:scopes] = scopes.join(' ') if scopes
  end

  def set_created_session
    session[CREATED_SESSION_KEY] = true
  end

  def get_created_session
    session.delete(CREATED_SESSION_KEY) || false
  end

  def load_scopes
    @scopes ||= Doorkeeper::OAuth::Scopes.from_array(
      Doorkeeper.configuration.scopes.to_a - [
        ::Gitlab::Auth::AI_WORKFLOW.to_s,
        ::Gitlab::Auth::DYNAMIC_USER.to_s,
        ::Gitlab::Auth::SELF_ROTATE_SCOPE.to_s,
        ::Gitlab::Auth::MCP_SCOPE.to_s
      ]
    )
  end

  def permitted_params
    %i[name redirect_uri scopes confidential]
  end

  def application_params
    params
      .require(:doorkeeper_application)
      .permit(*permitted_params)
  end
end
==== /workspace/gitlab/app/controllers/concerns/project_unauthorized.rb ====
# frozen_string_literal: true

module ProjectUnauthorized
  module ControllerActions
    def self.on_routable_not_found
      ->(routable, full_path) do
        return unless routable.is_a?(Project)

        label = routable.external_authorization_classification_label
        rejection_reason = nil

        unless ::Gitlab::ExternalAuthorization.access_allowed?(current_user, label)
          rejection_reason = ::Gitlab::ExternalAuthorization.rejection_reason(current_user, label)
          rejection_reason ||= _('External authorization denied access to this project')
        end

        access_denied!(rejection_reason) if rejection_reason
      end
    end
  end
end
==== /workspace/gitlab/app/controllers/concerns/sessionless_authentication.rb ====
# frozen_string_literal: true

# == SessionlessAuthentication
#
# Controller concern to handle PAT, RSS, and static objects token authentication methods
#
module SessionlessAuthentication
  # This filter handles personal access tokens, atom requests with rss tokens, and static object tokens
  def authenticate_sessionless_user!(request_format)
    user = request_authenticator.find_sessionless_user(request_format)
    sessionless_sign_in(user) if user
  end

  def request_authenticator
    @request_authenticator ||= Gitlab::Auth::RequestAuthenticator.new(request)
  end

  def sessionless_user?
    current_user && @sessionless_sign_in # rubocop:disable Gitlab/ModuleWithInstanceVariables -- This is only used within this module
  end

  def sessionless_sign_in(user)
    @sessionless_sign_in = true # rubocop:disable Gitlab/ModuleWithInstanceVariables -- This is only used within this module

    if user.can_log_in_with_non_expired_password?
      # Notice we are passing store false, so the user is not
      # actually stored in the session and a token is needed
      # for every request. If you want the token to work as a
      # sign in token, you can simply remove store: false.
      sign_in(user, store: false, message: :sessionless_sign_in)
    elsif request_authenticator.can_sign_in_bot?(user)
      # we suppress callbacks to avoid redirecting the bot
      sign_in(user, store: false, message: :sessionless_sign_in, run_callbacks: false)
    end
  end

  def sessionless_bypass_admin_mode!(&block)
    return yield unless Gitlab::CurrentSettings.admin_mode

    Gitlab::Auth::CurrentUserMode.bypass_session!(current_user.id, &block)
  end
end
==== /workspace/gitlab/app/controllers/concerns/snippet_authorizations.rb ====
# frozen_string_literal: true

module SnippetAuthorizations
  extend ActiveSupport::Concern

  private

  def authorize_read_snippet!
    render_404 unless can?(current_user, :read_snippet, snippet)
  end

  def authorize_update_snippet!
    render_404 unless can?(current_user, :update_snippet, snippet)
  end

  def authorize_admin_snippet!
    render_404 unless can?(current_user, :admin_snippet, snippet)
  end

  def authorize_create_snippet!
    render_404 unless can?(current_user, :create_snippet)
  end
end
==== /workspace/gitlab/app/controllers/concerns/verifies_with_email.rb ====
# frozen_string_literal: true

# == VerifiesWithEmail
#
# Controller concern to handle verification by email
module VerifiesWithEmail
  extend ActiveSupport::Concern
  include ActionView::Helpers::DateHelper
  include SessionsHelper

  included do
    prepend_before_action :verify_with_email, only: :create, unless: -> { skip_verify_with_email? }
  end

  def verify_with_email
    return unless user = find_user || find_verification_user
    return unless user.active?

    if session[:verification_user_id] && token = verification_params[:verification_token].presence
      # The verification token is submitted, verify it
      verify_token(user, token)
    elsif require_email_verification_enabled?(user)
      # Limit the amount of password guesses, since we now display the email verification page
      # when the password is correct, which could be a giveaway when brute-forced.
      return render_sign_in_rate_limited if check_rate_limit!(:user_sign_in, scope: user) { true }

      # Verify the email if the user has logged in successfully.
      verify_email(user) if user.valid_password?(user_params[:password])
    end
  end

  def resend_verification_code
    return unless user = find_verification_user

    if send_rate_limited?(user)
      render_send_rate_limited
    else
      secondary_email = user_secondary_email(user, email_params[:email])

      if email_params[:email].present? && secondary_email.present?
        lock_and_send_verification_instructions(user, secondary_email: secondary_email)
      elsif email_params[:email].blank?
        lock_and_send_verification_instructions(user)
      end

      render json: { status: :success }
    end
  end

  def successful_verification
    session.delete(:verification_user_id)
    @redirect_url = after_sign_in_path_for(current_user) # rubocop:disable Gitlab/ModuleWithInstanceVariables

    render layout: 'minimal'
  end

  private

  def skip_verify_with_email?
    two_factor_enabled? || Gitlab::Qa.request?(request.user_agent)
  end

  def find_verification_user
    return unless session[:verification_user_id]

    User.find_by_id(session[:verification_user_id])
  end

  def lock_and_send_verification_instructions(user, secondary_email: nil, reason: nil)
    service = Users::EmailVerification::GenerateTokenService.new(attr: :unlock_token, user: user)
    raw_token, encrypted_token = service.execute
    user.unlock_token = encrypted_token
    user.lock_access!({ send_instructions: false, reason: reason })
    send_verification_instructions_email(user, raw_token, secondary_email)
  end

  def send_verification_instructions_email(user, token, secondary_email)
    email = secondary_email || user.email
    Notify.verification_instructions_email(email, token: token).deliver_later

    log_verification(user, :instructions_sent)
  end

  # As this is a prepended controller action, we only want to block
  # log in if the VerifiesWithEmail is required
  def requires_verify_email?(user)
    user.access_locked? || user.unlock_token || !trusted_ip_address?(user)
  end

  def verify_email(user)
    return true unless requires_verify_email?(user)

    # If they've received too many codes already, we won't send more
    unless send_rate_limited?(user)
      # If access is locked but there's no unlock_token, or the token has
      # expired, send a new one
      if user.access_locked?
        if !user.unlock_token || unlock_token_expired?(user) # rubocop:disable Style/IfUnlessModifier -- This is easier to read
          lock_and_send_verification_instructions(user)
        end
      # If they're not already locked but from a new IP, lock and send a
      # code
      elsif !trusted_ip_address?(user)
        lock_and_send_verification_instructions(
          user,
          reason: 'sign in from untrusted IP address'
        )
      end
    end

    # At this point they have a non-expired token in their email inbox.
    # Prompt for them to enter it.
    prompt_for_email_verification(user)
  end

  def verify_token(user, token)
    service = Users::EmailVerification::ValidateTokenService.new(attr: :unlock_token, user: user, token: token)
    result = service.execute

    if result[:status] == :success
      handle_verification_success(user)
      render json: { status: :success, redirect_path: users_successful_verification_path }
    else
      handle_verification_failure(user, result[:reason], result[:message])
      render json: result
    end
  end

  def render_sign_in_rate_limited
    message = format(
      s_('IdentityVerification|Maximum login attempts exceeded. Wait %{interval} and try again.'),
      interval: rate_limit_interval(:user_sign_in)
    )
    redirect_to new_user_session_path, alert: message
  end

  def render_send_rate_limited
    message = format(
      s_("IdentityVerification|You've reached the maximum amount of resends. Wait %{interval} and try again."),
      interval: rate_limit_interval(:email_verification_code_send)
    )
    render json: { status: :failure, message: message }
  end

  def rate_limit_interval(rate_limit)
    interval_in_seconds = Gitlab::ApplicationRateLimiter.rate_limits[rate_limit][:interval]
    distance_of_time_in_words(interval_in_seconds)
  end

  def send_rate_limited?(user)
    Gitlab::ApplicationRateLimiter.throttled?(:email_verification_code_send, scope: user)
  end

  def handle_verification_failure(user, reason, message)
    user.errors.add(:base, message)
    log_verification(user, :failed_attempt, reason)
  end

  def handle_verification_success(user)
    user.unlock_access!
    log_verification(user, :successful)

    sign_in(user)

    log_audit_event(current_user, user, with: authentication_method)
    log_user_activity(user)
    verify_known_sign_in
  end

  def trusted_ip_address?(user)
    AuthenticationEvent.initial_login_or_known_ip_address?(user, request.ip)
  end

  def prompt_for_email_verification(user)
    session[:verification_user_id] = user.id
    self.resource = user
    add_gon_variables # Necessary to set the sprite_icons path, since we skip the ApplicationController before_filters

    render 'devise/sessions/email_verification'
  end

  def verification_params
    params.require(:user).permit(:verification_token)
  end

  def email_params
    params.require(:user).permit(:email)
  end

  def user_secondary_email(user, email)
    user.emails.confirmed.find_by_email(email)&.email
  end

  def log_verification(user, event, reason = nil)
    Gitlab::AppLogger.info(
      message: 'Email Verification',
      event: event.to_s.titlecase,
      username: user.username,
      ip: request.ip,
      reason: reason.to_s
    )
  end

  def require_email_verification_enabled?(user)
    ::Gitlab::CurrentSettings.require_email_verification_on_account_locked &&
      Feature.disabled?(:skip_require_email_verification, user, type: :ops)
  end

  def unlock_token_expired?(user)
    Users::EmailVerification::ValidateTokenService.new(
      attr: :unlock_token,
      user: user,
      # We explicitly pass nil - we're only checking expiry, not the
      # token itself
      token: nil
    ).expired_token?
  end
end
==== /workspace/gitlab/app/controllers/concerns/workhorse_authorization.rb ====
# frozen_string_literal: true

module WorkhorseAuthorization
  extend ActiveSupport::Concern
  include WorkhorseRequest

  included do
    skip_before_action :verify_authenticity_token, only: %i[authorize]
    before_action :verify_workhorse_api!, only: %i[authorize]
  end

  def authorize
    set_workhorse_internal_api_content_type

    authorized = uploader_class.workhorse_authorize(
      has_length: false,
      maximum_size: maximum_size.to_i)

    render json: authorized
  rescue SocketError
    render json: _("Error uploading file"), status: :internal_server_error
  end

  private

  def file_is_valid?(file)
    return false unless file.is_a?(::UploadedFile)

    file_extension_allowlist.include?(File.extname(file.original_filename).downcase.delete('.'))
  end

  def uploader_class
    raise NotImplementedError
  end

  def maximum_size
    raise NotImplementedError
  end

  def file_extension_allowlist
    ImportExportUploader::EXTENSION_ALLOWLIST
  end
end
==== /workspace/gitlab/app/controllers/google_api/authorizations_controller.rb ====
# frozen_string_literal: true

module GoogleApi
  class AuthorizationsController < ApplicationController
    include Gitlab::Utils::StrongMemoize

    before_action :validate_session_key!

    feature_category :deployment_management
    urgency :low

    ##
    # handle the response from google after the user
    # goes through authentication and authorization process
    def callback
      redirect_uri = redirect_uri_from_session
      ##
      # when  the user declines authorizations
      # `error` param is returned
      if params[:error]
        flash[:alert] = _('Google Cloud authorizations required')
        redirect_uri = session[:error_uri]
      ##
      # on success, the `code` param is returned
      elsif params[:code]
        token, expires_at = GoogleApi::CloudPlatform::Client
          .new(nil, callback_google_api_auth_url)
          .get_token(params[:code])

        session[GoogleApi::CloudPlatform::Client.session_key_for_token] = token
        session[GoogleApi::CloudPlatform::Client.session_key_for_expires_at] = expires_at.to_s
        redirect_uri = redirect_uri_from_session
      end
    ##
    # or google may just timeout
    rescue ::Faraday::TimeoutError, ::Faraday::ConnectionFailed
      flash[:alert] = _('Timeout connecting to the Google API. Please try again.')
    ##
    # regardless, we redirect the user appropriately
    ensure
      redirect_to redirect_uri
    end

    private

    def validate_session_key!
      access_denied! unless redirect_uri_from_session.present?
    end

    def redirect_uri_from_session
      if params[:state].present?
        session[session_key_for_redirect_uri(params[:state])]
      else
        nil
      end
    end
    strong_memoize_attr :redirect_uri_from_session

    def session_key_for_redirect_uri(state)
      GoogleApi::CloudPlatform::Client.session_key_for_redirect_uri(state)
    end
  end
end
==== /workspace/gitlab/app/controllers/groups/dependency_proxy_auth_controller.rb ====
# frozen_string_literal: true

class Groups::DependencyProxyAuthController < ::Groups::DependencyProxy::ApplicationController
  feature_category :virtual_registry
  urgency :low

  def authenticate
    render plain: '', status: :ok
  end
end
==== /workspace/gitlab/app/controllers/jira_connect/oauth_application_ids_controller.rb ====
# frozen_string_literal: true

module JiraConnect
  class OauthApplicationIdsController < ApplicationController
    feature_category :integrations

    skip_before_action :verify_atlassian_jwt!

    def show
      if show_application_id?
        render json: { application_id: jira_connect_application_key }
      else
        head :not_found
      end
    end

    private

    def show_application_id?
      return if Gitlab.com?

      jira_connect_application_key.present?
    end

    def jira_connect_application_key
      Gitlab::CurrentSettings.jira_connect_application_key.presence
    end
  end
end
==== /workspace/gitlab/app/controllers/jira_connect/oauth_callbacks_controller.rb ====
# frozen_string_literal: true

# This controller's role is to serve as a landing page
# that users get redirected to after installing and authenticating
# The GitLab.com for Jira App (https://marketplace.atlassian.com/apps/1221011/gitlab-com-for-jira-cloud)
#
class JiraConnect::OauthCallbacksController < ApplicationController
  feature_category :integrations

  skip_before_action :authenticate_user!

  def index; end
end
==== /workspace/gitlab/app/controllers/ldap/omniauth_callbacks_controller.rb ====
# frozen_string_literal: true

class Ldap::OmniauthCallbacksController < OmniauthCallbacksController
  extend ::Gitlab::Utils::Override

  before_action :check_action_name_in_available_providers

  def self.define_providers!
    return unless Gitlab::Auth::Ldap::Config.sign_in_enabled?

    Gitlab::Auth::Ldap::Config.servers.each do |server|
      alias_method server['provider_name'], :ldap
    end
  end

  # We only find ourselves here
  # if the authentication to LDAP was successful.
  def ldap
    return unless Gitlab::Auth::Ldap::Config.sign_in_enabled?

    if Gitlab::CurrentSettings.admin_mode
      return admin_mode_flow(Gitlab::Auth::Ldap::User) if current_user_mode.admin_mode_requested?
    end

    sign_in_user_flow(Gitlab::Auth::Ldap::User)
  end

  define_providers!

  override :set_remember_me
  def set_remember_me(user, _auth_user)
    user.remember_me = params[:remember_me] if user.persisted?
  end

  override :fail_login
  def fail_login(user)
    flash[:alert] = _('Access denied for your LDAP account.')

    redirect_to new_user_session_path
  end

  private

  def check_action_name_in_available_providers
    render_404 unless available_providers.include?(action_name)
  end

  def available_providers
    Gitlab::Auth::Ldap::Config.available_servers.map do |server|
      server['provider_name']
    end
  end

  override :log_audit_event
  def log_audit_event(user, options = {})
    super(user, options, 'authenticated_with_ldap')
  end
end

Ldap::OmniauthCallbacksController.prepend_mod_with('Ldap::OmniauthCallbacksController')
==== /workspace/gitlab/app/controllers/oauth/authorizations_controller.rb ====
# frozen_string_literal: true

class Oauth::AuthorizationsController < Doorkeeper::AuthorizationsController
  include Gitlab::GonHelper
  include InitializesCurrentUserMode
  include Gitlab::Utils::StrongMemoize
  include RequestPayloadLogger

  alias_method :auth_user, :current_user

  prepend_before_action :set_current_organization

  before_action :add_gon_variables
  before_action :verify_confirmed_email!, :verify_admin_allowed!
  # rubocop: disable Rails/LexicallyScopedActionFilter -- :create is defined in Doorkeeper::AuthorizationsController
  before_action :validate_pkce_for_dynamic_applications, only: [:new, :create]
  after_action :audit_oauth_authorization, only: [:create]
  # rubocop: enable Rails/LexicallyScopedActionFilter

  layout 'minimal'

  # Overridden from Doorkeeper::AuthorizationsController to
  # include the call to session.delete
  def new
    if pre_auth.authorizable?
      if skip_authorization? || (matching_token? && pre_auth.client.application.confidential?)
        auth = authorization.authorize
        parsed_redirect_uri = URI.parse(auth.redirect_uri)
        session.delete(:user_return_to)
        render "doorkeeper/authorizations/redirect", locals: { redirect_uri: parsed_redirect_uri }, layout: false
      else
        redirect_uri = URI(authorization.authorize.redirect_uri)
        allow_redirect_uri_form_action(redirect_uri.scheme)

        render "doorkeeper/authorizations/new"
      end
    else
      render "doorkeeper/authorizations/error"
    end
  end

  private

  def audit_oauth_authorization
    return unless performed? && (response.successful? || response.redirect?) && pre_auth&.client

    application = pre_auth.client.application

    Gitlab::Audit::Auditor.audit(
      name: 'user_authorized_oauth_application',
      author: current_user,
      scope: current_user,
      target: application,
      message: 'User authorized an OAuth application.',
      additional_details: {
        application_name: application.name,
        application_id: application.id,
        scopes: application.scopes.to_a
      },
      ip_address: request.remote_ip
    )
  end

  # Chrome blocks redirections if the form-action CSP directive is present
  # and the redirect location's scheme isn't allow-listed
  # https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/form-action
  # https://github.com/w3c/webappsec-csp/issues/8
  def allow_redirect_uri_form_action(redirect_uri_scheme)
    return unless content_security_policy?

    form_action = request.content_security_policy.form_action
    return unless form_action

    form_action.push("#{redirect_uri_scheme}:")
    request.content_security_policy.form_action(*form_action)
  end

  def pre_auth_params
    # Cannot be achieved with a before_action hook, due to the execution order.
    downgrade_scopes! if action_name == 'new'

    # Force scope to `mcp` when resource is present, and the MCP server API
    params[:scope] = Gitlab::Auth::MCP_SCOPE.to_s if params[:resource].present? && resource_is_mcp_server?
    params[:organization_id] = ::Current.organization.id

    super
  end

  def resource_is_mcp_server?
    params[:resource].end_with?('/api/v4/mcp')
  end

  # limit scopes when signing in with GitLab
  def downgrade_scopes!
    auth_type = params.delete('gl_auth_type')
    return unless auth_type == 'login'

    ensure_read_user_scope!

    params['scope'] = Gitlab::Auth::READ_USER_SCOPE.to_s if application_has_read_user_scope?
  end

  # Configure the application to support read_user scope, if it already
  # supports scopes with greater levels of privileges.
  def ensure_read_user_scope!
    return if application_has_read_user_scope?
    return unless application_has_api_scope?

    add_read_user_scope!
  end

  def add_read_user_scope!
    return unless doorkeeper_application

    scopes = doorkeeper_application.scopes
    scopes.add(Gitlab::Auth::READ_USER_SCOPE)
    doorkeeper_application.scopes = scopes
    doorkeeper_application.save!
  end

  def doorkeeper_application
    ::Doorkeeper::OAuth::Client.find(params['client_id'].to_s)&.application
  end
  strong_memoize_attr :doorkeeper_application

  def application_has_read_user_scope?
    doorkeeper_application&.includes_scope?(Gitlab::Auth::READ_USER_SCOPE)
  end

  def application_has_api_scope?
    doorkeeper_application&.includes_scope?(*::Gitlab::Auth::API_SCOPES)
  end

  def verify_confirmed_email!
    return if current_user&.confirmed?

    pre_auth.error = :unconfirmed_email
    render "doorkeeper/authorizations/error"
  end

  def verify_admin_allowed!
    render "doorkeeper/authorizations/forbidden" if disallow_connect?
  end

  def disallow_connect?
    # we're disabling Cop/UserAdmin as OAuth tokens don't seem to respect admin mode
    current_user&.admin? && Gitlab::CurrentSettings.disable_admin_oauth_scopes && dangerous_scopes? # rubocop:disable Cop/UserAdmin
  end

  def dangerous_scopes?
    doorkeeper_application&.includes_scope?(
      *::Gitlab::Auth::API_SCOPE, *::Gitlab::Auth::READ_API_SCOPE,
      *::Gitlab::Auth::ADMIN_SCOPES, *::Gitlab::Auth::REPOSITORY_SCOPES,
      *::Gitlab::Auth::REGISTRY_SCOPES
    ) && !doorkeeper_application&.trusted?
  end

  def validate_pkce_for_dynamic_applications
    return unless doorkeeper_application&.dynamic?

    if params[:code_challenge].blank?
      pre_auth.error = :pkce_required_for_dynamic_applications
      render "doorkeeper/authorizations/error"
      return
    end

    return unless params[:code_challenge_method].present? && params[:code_challenge_method] != 'S256'

    pre_auth.error = :invalid_code_challenge_method
    render "doorkeeper/authorizations/error"
  end

  # Used by `set_current_organization` in BaseActionController
  def organization_params
    {}
  end
end

Oauth::AuthorizationsController.prepend_mod
==== /workspace/gitlab/app/controllers/oauth/authorized_applications_controller.rb ====
# frozen_string_literal: true

class Oauth::AuthorizedApplicationsController < Doorkeeper::AuthorizedApplicationsController
  include PageLayoutHelper

  layout 'profile'

  def index
    respond_to do |format|
      format.html { render "errors/not_found", layout: "errors", status: :not_found }
      format.json { render json: "", status: :not_found }
    end
  end

  def destroy
    if params[:token_id].present?
      current_resource_owner.oauth_authorized_tokens.find(params[:token_id].to_s).revoke
    else
      Doorkeeper::Application.revoke_tokens_and_grants_for(params[:id].to_s, current_resource_owner)
    end

    redirect_to user_settings_applications_url,
      status: :found,
      notice: I18n.t(:notice, scope: [:doorkeeper, :flash, :authorized_applications, :destroy])
  end
end
==== /workspace/gitlab/app/controllers/oauth/device_authorizations_controller.rb ====
# frozen_string_literal: true

module Oauth
  class DeviceAuthorizationsController < Doorkeeper::DeviceAuthorizationGrant::DeviceAuthorizationsController
    layout 'minimal'

    def index
      respond_to do |format|
        format.html do
          render "doorkeeper/device_authorization_grant/index"
        end
        format.json { head :no_content }
      end
    end

    def confirm
      # rubocop:disable CodeReuse/ActiveRecord -- We are using .find_by here because the models are part of the Doorkeeper gem.
      device_grant = device_grant_model.find_by(user_code: user_code)
      # rubocop:enable CodeReuse/ActiveRecord
      @scopes = device_grant&.scopes || ''
      respond_to do |format|
        format.html do
          render "doorkeeper/device_authorization_grant/authorize"
        end
        format.json { head :no_content }
      end
    end
  end
end
==== /workspace/gitlab/app/controllers/omniauth_callbacks_controller.rb ====
# frozen_string_literal: true

class OmniauthCallbacksController < Devise::OmniauthCallbacksController
  include ActionView::Helpers::TextHelper
  include AuthenticatesWithTwoFactorForAdminMode
  include Devise::Controllers::Rememberable
  include AuthHelper
  include InitializesCurrentUserMode
  include KnownSignIn
  include AcceptsPendingInvitations
  include Onboarding::Redirectable
  include InternalRedirect
  include SafeFormatHelper
  include SynchronizeBroadcastMessageDismissals

  ACTIVE_SINCE_KEY = 'active_since'

  # Following https://www.rfc-editor.org/rfc/rfc3986.txt
  # to check for the present of reserved characters
  # in redirect_fragment
  INVALID_FRAGMENT_EXP = %r{[;/?:@&=+$,]+}

  InvalidFragmentError = Class.new(StandardError)

  after_action :verify_known_sign_in

  protect_from_forgery except: [:failure] + AuthHelper.saml_providers, with: :exception, prepend: true

  feature_category :system_access

  # To be used in ee version for raising error on user signup if user is from restricted country
  SignUpFromRestrictedCountyError = Class.new(StandardError)

  def handle_omniauth
    if ::AuthHelper.saml_providers.include?(oauth['provider'].to_sym)
      saml
    elsif ::AuthHelper.oidc_providers.include?(oauth['provider'].to_sym)
      openid_connect
    else
      omniauth_flow(Gitlab::Auth::OAuth)
    end
  end

  AuthHelper.providers_for_base_controller.each do |provider|
    alias_method provider, :handle_omniauth
  end

  # overridden in EE
  def openid_connect
    omniauth_flow(Gitlab::Auth::OAuth)
  end

  def jwt
    omniauth_flow(
      Gitlab::Auth::OAuth,
      identity_linker: Gitlab::Auth::Jwt::IdentityLinker.new(current_user, oauth, session)
    )
  end

  # Extend the standard implementation to also increment
  # the number of failed sign in attempts
  def failure
    update_login_counter_metric(failed_strategy.name, 'failed')
    log_saml_response if params['SAMLResponse']

    username = params[:username].to_s
    if username.present? && AuthHelper.form_based_provider?(failed_strategy.name)
      user = User.find_by_login(username)

      user&.increment_failed_attempts!
      log_failed_login(username, failed_strategy.name)
    end

    super
  end

  # Extend the standard message generation to accept our custom exception
  def failure_message
    exception = request.env["omniauth.error"]
    error = exception.error_reason if exception.respond_to?(:error_reason)
    error ||= exception.error        if exception.respond_to?(:error)
    error ||= exception.message      if exception.respond_to?(:message)
    error ||= request.env["omniauth.error.type"].to_s

    error.to_s.humanize if error
  end

  def saml
    log_saml_response
    omniauth_flow(Gitlab::Auth::Saml)
  rescue Gitlab::Auth::Saml::IdentityLinker::UnverifiedRequest
    redirect_unverified_saml_initiation
  end

  def auth0
    if oauth['uid'].blank?
      fail_auth0_login
    else
      handle_omniauth
    end
  end

  def salesforce
    if oauth.dig('extra', 'email_verified')
      handle_omniauth
    else
      fail_salesforce_login
    end
  end

  def atlassian_oauth2
    omniauth_flow(Gitlab::Auth::Atlassian)
  end

  private

  def verify_redirect_fragment(fragment)
    if URI.decode_uri_component(fragment).match(INVALID_FRAGMENT_EXP)
      raise InvalidFragmentError
    else
      fragment
    end
  end

  def track_event(user, provider, status)
    log_audit_event(user, with: provider)
    update_login_counter_metric(provider, status)
  end

  def update_login_counter_metric(provider, status)
    omniauth_login_counter.increment(omniauth_provider: provider, status: status)
  end

  def omniauth_login_counter
    Gitlab::Auth::OAuth::BeforeRequestPhaseOauthLoginCounterIncrement.counter
  end

  def log_failed_login(user, provider)
    # overridden in EE
  end

  def after_omniauth_failure_path_for(scope)
    if Gitlab::CurrentSettings.admin_mode
      return new_admin_session_path if current_user_mode.admin_mode_requested?
    end

    super
  end

  def store_redirect_to
    # overridden in EE
  end

  def omniauth_flow(auth_module, identity_linker: nil)
    if fragment = request.env.dig('omniauth.params', 'redirect_fragment').presence
      store_redirect_fragment(fragment)
    end

    store_redirect_to

    if current_user
      return render_403 unless link_provider_allowed?(oauth['provider'])

      set_session_active_since(oauth['provider']) if ::AuthHelper.saml_providers.include?(oauth['provider'].to_sym)
      track_event(current_user, oauth['provider'], 'succeeded')

      handle_step_up_auth

      if Gitlab::CurrentSettings.admin_mode
        return admin_mode_flow(auth_module::User) if current_user_mode.admin_mode_requested?
      end

      identity_linker ||= auth_module::IdentityLinker.new(current_user, oauth, session)
      return redirect_authorize_identity_link(identity_linker) if identity_linker.authorization_required?

      link_identity(identity_linker)

      current_auth_user = build_auth_user(auth_module::User)
      set_remember_me(current_user, current_auth_user)
      # We are also calling this here in the case that devise re-logins and current_user is set
      synchronize_broadcast_message_dismissals(current_user)

      store_idp_two_factor_status(current_auth_user.bypass_two_factor?)

      if identity_linker.changed?
        redirect_identity_linked
      elsif identity_linker.failed?
        redirect_identity_link_failed(identity_linker.error_message)
      else
        redirect_identity_exists
      end
    else
      sign_in_user_flow(auth_module::User)
    end
  rescue InvalidFragmentError
    fail_login_with_message("Invalid state")
  end

  def link_identity(identity_linker)
    identity_linker.link
  end

  def redirect_identity_exists
    redirect_to after_sign_in_path_for(current_user)
  end

  def redirect_identity_link_failed(error_message)
    redirect_to profile_account_path,
      notice: safe_format(_("Authentication failed: %{error_message}"), error_message: error_message)
  end

  def redirect_identity_linked
    redirect_to profile_account_path, notice: _('Authentication method updated')
  end

  def redirect_authorize_identity_link(identity_linker)
    state = SecureRandom.uuid
    session[:identity_link_state] = state
    session[:identity_link_provider] = identity_linker.provider
    session[:identity_link_extern_uid] = identity_linker.uid

    redirect_to new_user_settings_identities_path(state: state)
  end

  def build_auth_user(auth_user_class)
    strong_memoize_with(:build_auth_user, auth_user_class) do
      auth_user_class.new(oauth, build_auth_user_params)
    end
  end

  # Overridden in EE
  def build_auth_user_params
    { organization_id: Current.organization.id }
  end

  # Overridden in EE
  def set_session_active_since(id); end

  def sign_in_user_flow(auth_user_class)
    auth_user = build_auth_user(auth_user_class)
    new_user = allowed_new_user?(auth_user)
    @user = auth_user.find_and_update!

    if auth_user.valid_sign_in?
      # In this case the `#current_user` would not be set. So we can't fetch it
      # from that in `#context_user`. Pushing it manually here makes the information
      # available in the logs for this request.
      Gitlab::ApplicationContext.push(user: @user)
      track_event(@user, oauth['provider'], 'succeeded')
      Gitlab::Tracking.event(self.class.name, "#{oauth['provider']}_sso", user: @user) if new_user

      set_remember_me(@user, auth_user)
      set_session_active_since(oauth['provider']) if ::AuthHelper.saml_providers.include?(oauth['provider'].to_sym)

      if @user.two_factor_enabled? && !auth_user.bypass_two_factor?
        prompt_for_two_factor(@user)
        store_idp_two_factor_status(false)
      else
        if @user.deactivated?
          @user.activate
          flash[:notice] =
            _('Welcome back! Your account had been deactivated due to inactivity but is now reactivated.')
        end

        # session variable for storing bypass two-factor request from IDP
        store_idp_two_factor_status(auth_user.bypass_two_factor?)

        accept_pending_invitations(user: @user) if new_user
        synchronize_broadcast_message_dismissals(@user) unless new_user
        persist_accepted_terms_if_required(@user) if new_user

        perform_registration_tasks(@user, oauth['provider']) if new_user

        enqueue_after_sign_in_workers(@user, auth_user)

        sign_in_and_redirect_or_verify_identity(@user, auth_user, new_user)
      end
    else
      fail_login(@user)
    end
  rescue Gitlab::Auth::OAuth::User::IdentityWithUntrustedExternUidError
    handle_identity_with_untrusted_extern_uid
  rescue Gitlab::Auth::OAuth::User::SigninDisabledForProviderError
    handle_disabled_provider
  rescue Gitlab::Auth::OAuth::User::SignupDisabledError
    handle_signup_error
  rescue SignUpFromRestrictedCountyError
    handle_signup_from_restricted_country_error
  end

  def handle_signup_from_restricted_country_error
    sign_up_message = "Sign up with Jihu"
    jihu_url = ActionController::Base.helpers.link_to _(sign_up_message), "https://about.gitlab.com/pricing/faq-jihu/",
      class: 'gl-link'
    message = safe_format(_('It looks like you are visiting GitLab from Mainland China, Macau, or Hong Kong.' \
      'We advise you to %{jihu_url} before continuing.'), jihu_url: jihu_url)

    flash[:alert] = sanitize(message)

    redirect_to new_user_session_path
  end

  def handle_signup_error
    redirect_path = new_user_session_path
    label = Gitlab::Auth::OAuth::Provider.label_for(oauth['provider'])
    simple_url = Settings.gitlab.url.sub(%r{^https?://(www\.)?}i, '')
    message = [
      safe_format(_('Signing in using your %{label} account without a pre-existing ' \
        'account in %{simple_url} is not allowed.'), label: label, simple_url: simple_url)
    ]

    if Gitlab::CurrentSettings.allow_signup?
      redirect_path = new_user_registration_path
      doc_pair = tag_pair(view_context.link_to(
        '',
        help_page_path('user/profile/_index.md', anchor: 'sign-in-services')),
        :doc_start,
        :doc_end
      )
      message << safe_format(
        _('Create an account in %{simple_url} first, and then %{doc_start}connect it to ' \
          'your %{label} account%{doc_end}.'),
        doc_pair,
        label: label,
        simple_url: simple_url
      )
    end

    flash[:alert] = sanitize(message.join(' '))

    redirect_to redirect_path
  end

  def oauth
    @oauth ||= request.env['omniauth.auth']
  end

  def fail_login(user)
    log_failed_login(user.username, oauth['provider'])

    @provider = Gitlab::Auth::OAuth::Provider.label_for(params[:action])
    @error = user.errors.full_messages.to_sentence

    render 'errors/omniauth_error', layout: "oauth_error", status: :unprocessable_entity
  end

  def fail_auth0_login
    fail_login_with_message(_('Wrong extern UID provided. Make sure Auth0 is configured correctly.'))
  end

  def fail_salesforce_login
    fail_login_with_message(_('Email not verified. Please verify your email in Salesforce.'))
  end

  def fail_login_with_message(message)
    flash[:alert] = message

    redirect_to new_user_session_path
  end

  def redirect_unverified_saml_initiation
    redirect_to profile_account_path, notice: _('Request to link SAML account must be authorized')
  end

  def handle_identity_with_untrusted_extern_uid
    label = Gitlab::Auth::OAuth::Provider.label_for(oauth['provider'])
    flash[:alert] = safe_format(
      _('Signing in using your %{label} account has been disabled for security reasons. ' \
        'Please sign in to your GitLab account using another authentication method and ' \
        'reconnect to your %{label} account.'
       ),
      label: label
    )

    redirect_to new_user_session_path
  end

  def handle_disabled_provider
    label = Gitlab::Auth::OAuth::Provider.label_for(oauth['provider'])
    flash[:alert] = safe_format(_("Signing in using %{label} has been disabled"), label: label)

    redirect_to new_user_session_path
  end

  def log_audit_event(user, options = {}, name = 'authenticated_with_oauth')
    return if options[:with].blank?

    provider = options[:with]
    audit_context = {
      name: name,
      author: user,
      scope: user,
      target: user,
      message: "Signed in with #{provider.upcase} authentication",
      authentication_event: true,
      authentication_provider: provider,
      additional_details: {
        with: provider
      }
    }
    ::Gitlab::Audit::Auditor.audit(audit_context)
  end

  def set_remember_me(user, auth_user)
    return unless remember_me?

    if user.two_factor_enabled? && !auth_user.bypass_two_factor?
      params[:remember_me] = '1'
    else
      remember_me(user)
    end
  end

  def remember_me?
    request_params = request.env['omniauth.params']
    (request_params['remember_me'] == '1') if request_params.present?
  end

  def store_redirect_fragment(redirect_fragment)
    key = stored_location_key_for(:user)
    location = session[key]
    if uri = parse_uri(location)
      uri.fragment = verify_redirect_fragment(redirect_fragment)
      store_location_for(:user, uri.to_s)
    end
  end

  def handle_step_up_auth
    return if Feature.disabled?(:omniauth_step_up_auth_for_admin_mode, current_user)

    step_up_auth_flow =
      ::Gitlab::Auth::Oidc::StepUpAuthentication.build_flow(session: session, provider: oauth.provider)

    return unless step_up_auth_flow.enabled_by_config?
    return unless step_up_auth_flow.requested?

    step_up_auth_flow.evaluate!(oauth.extra.raw_info)
  end

  def admin_mode_flow(auth_user_class)
    auth_user = build_auth_user(auth_user_class)

    return fail_admin_mode_invalid_credentials unless omniauth_identity_matches_current_user?

    if current_user.two_factor_enabled? && !auth_user.bypass_two_factor?
      admin_mode_prompt_for_two_factor(current_user)
    else
      # Can only reach here if the omniauth identity matches current user
      # and current_user is an admin that requested admin mode
      current_user_mode.enable_admin_mode!(skip_password_validation: true)

      redirect_to stored_location_for(:redirect) || admin_root_path, notice: _('Admin mode enabled')
    end
  end

  def omniauth_identity_matches_current_user?
    current_user.matches_identity?(oauth['provider'], oauth['uid'])
  end

  def fail_admin_mode_invalid_credentials
    redirect_to new_admin_session_path, alert: _('Invalid login or password')
  end

  def persist_accepted_terms_if_required(user)
    return unless user.persisted?
    return unless Gitlab::CurrentSettings.current_application_settings.enforce_terms?

    terms = ApplicationSetting::Term.latest
    Users::RespondToTermsService.new(user, terms).execute(accepted: true)
  end

  def perform_registration_tasks(user, _provider)
    store_location_for(:user, after_sign_up_path(user))
  end

  def onboarding_status_presenter
    Onboarding::StatusPresenter
      .new(request.env.fetch('omniauth.params', {}).deep_symbolize_keys, session['user_return_to'], @user)
  end
  strong_memoize_attr :onboarding_status_presenter

  # overridden in EE
  def sign_in_and_redirect_or_verify_identity(user, _, _)
    sign_in_and_redirect(user, event: :authentication)
  end

  # overridden in specific EE class
  def enqueue_after_sign_in_workers(_user, _auth_user)
    true
  end

  # overridden in specific EE class
  def allowed_new_user?(auth_user)
    auth_user.new?
  end

  def store_idp_two_factor_status(bypass_2fa)
    session[:provider_2FA] = true if bypass_2fa
  end

  def log_saml_response
    ParameterFilters::SamlResponse.log(params['SAMLResponse'].dup)
  end
end

OmniauthCallbacksController.prepend_mod_with('OmniauthCallbacksController')
==== /workspace/gitlab/app/controllers/profiles/two_factor_auths_controller.rb ====
# frozen_string_literal: true

class Profiles::TwoFactorAuthsController < Profiles::ApplicationController
  skip_before_action :check_two_factor_requirement
  before_action :ensure_verified_primary_email, only: [:show, :create]
  before_action :validate_current_password,
    only: [:create, :codes, :destroy, :destroy_otp, :destroy_webauthn, :create_webauthn],
    if: :current_password_required?
  before_action :update_current_user_otp!, only: [:show]

  helper_method :current_password_required?

  feature_category :system_access

  include SafeFormatHelper

  def show
    setup_show_page
  end

  def create
    otp_validation_result =
      ::Users::ValidateManualOtpService.new(current_user).execute(params[:pin_code])
    validated = (otp_validation_result[:status] == :success)

    if validated && current_user.otp_backup_codes?
      ActiveSession.destroy_all_but_current(current_user, session)
      Users::UpdateService.new(current_user, user: current_user, otp_required_for_login: true).execute!
      redirect_to profile_two_factor_auth_path, notice: _("Your Time-based OTP device was registered!")
    elsif validated
      ActiveSession.destroy_all_but_current(current_user, session)

      Users::UpdateService.new(current_user, user: current_user, otp_required_for_login: true).execute! do |user|
        @codes = user.generate_otp_backup_codes!
      end

      helpers.dismiss_two_factor_auth_recovery_settings_check

      render 'create'
    else
      @otp_error = { message: _('Invalid pin code.') }
      @account_string = account_string

      setup_show_page

      render 'show'
    end
  end

  def create_webauthn
    @webauthn_registration = Webauthn::RegisterService.new(
      current_user,
      device_registration_params,
      session[:challenge]
    ).execute

    notice = _("Your WebAuthn device was registered!")
    if @webauthn_registration.persisted?
      session.delete(:challenge)

      if current_user.otp_backup_codes?
        redirect_to profile_two_factor_auth_path, notice: notice
      else

        Users::UpdateService.new(current_user, user: current_user).execute! do |user|
          @codes = current_user.generate_otp_backup_codes!
        end
        helpers.dismiss_two_factor_auth_recovery_settings_check
        flash[:notice] = notice
        render 'create'
      end
    else
      @qr_code = build_qr_code

      setup_webauthn_registration

      render :show
    end
  end

  def codes
    Users::UpdateService.new(current_user, user: current_user).execute! do |user|
      @codes = user.generate_otp_backup_codes!

      helpers.dismiss_two_factor_auth_recovery_settings_check
    end
  end

  def destroy
    result = TwoFactor::DestroyService.new(current_user, user: current_user).execute

    if result[:status] == :success
      redirect_to profile_account_path,
        status: :found,
        notice: _('Two-factor authentication has been disabled successfully!')
    else
      redirect_to profile_account_path, status: :found, alert: result[:message]
    end
  end

  def destroy_otp
    result = TwoFactor::DestroyOtpService.new(current_user, user: current_user).execute

    if result[:status] == :success
      redirect_to profile_two_factor_auth_path,
        status: :found,
        notice: _('One-time password authenticator has been deleted!')
    else
      redirect_to profile_two_factor_auth_path, status: :found, alert: result[:message]
    end
  end

  def destroy_webauthn
    Webauthn::DestroyService.new(current_user, current_user, params[:id]).execute

    redirect_to profile_two_factor_auth_path, status: :found, notice: _("Successfully deleted WebAuthn device.")
  end

  def skip
    if two_factor_grace_period_expired?
      redirect_to profile_two_factor_auth_url, alert: _('Cannot skip two factor authentication setup')
    else
      session[:skip_two_factor] = current_user.otp_grace_period_started_at + two_factor_grace_period.hours
      redirect_to root_url
    end
  end

  private

  def update_current_user_otp!
    current_user.update_otp_secret! if current_user.needs_new_otp_secret?

    unless current_user.otp_grace_period_started_at && two_factor_grace_period
      current_user.otp_grace_period_started_at = Time.current
    end

    Users::UpdateService.new(current_user, user: current_user).execute!
  end

  def validate_current_password
    return if current_user.valid_password?(params[:current_password])

    current_user.increment_failed_attempts!

    error_message = { message: _('You must provide a valid current password.') }
    if params[:action] == 'create_webauthn'
      @webauthn_error = error_message
    elsif params[:action] == 'create'
      @otp_error = error_message
    else
      @error = error_message
    end

    setup_show_page

    render 'show'
  end

  def current_password_required?
    !current_user.password_automatically_set? && current_user.allow_password_authentication_for_web?
  end

  def build_qr_code
    uri = current_user.otp_provisioning_uri(account_string, issuer: issuer_host)
    svg = RQRCode::QRCode.new(uri, level: :m).as_svg(
      shape_rendering: "crispEdges",
      module_size: 3
    )

    doc = Nokogiri::XML(svg)
    svg_node = doc.at('svg')
    title = Nokogiri::XML::Node.new('title', doc)
    title.content = _('Generated QR Code')
    svg_node.children.before(title)

    doc.to_xml
  end

  def account_string
    "#{issuer_host}:#{current_user.email}"
  end

  def issuer_host
    Gitlab.config.gitlab.host
  end

  def device_registration_params
    params.require(:device_registration).permit(:device_response, :name)
  end

  def setup_webauthn_registration
    @registrations = webauthn_registrations
    @webauthn_registration ||= WebauthnRegistration.new

    current_user.user_detail.update!(webauthn_xid: WebAuthn.generate_user_id) unless current_user.webauthn_xid

    options = webauthn_options
    session[:challenge] = options.challenge

    gon.push(webauthn: { options: options })
  end

  def webauthn_registrations
    current_user.webauthn_registrations.map do |webauthn_registration|
      {
        name: webauthn_registration.name,
        created_at: webauthn_registration.created_at,
        delete_path: destroy_webauthn_profile_two_factor_auth_path(webauthn_registration)
      }
    end
  end

  def webauthn_options
    WebAuthn::Credential.options_for_create(
      user: { id: current_user.webauthn_xid, name: current_user.username },
      exclude: current_user.webauthn_registrations.map(&:credential_xid),
      authenticator_selection: { user_verification: 'discouraged' },
      rp: { name: 'GitLab' }
    )
  end

  def groups_notification(groups)
    group_links = groups.map { |group| view_context.link_to group.full_name, group_path(group) }.to_sentence
    leave_group_links = groups.map do |group|
      view_context.link_to safe_format(s_("leave %{group_name}"), group_name: group.full_name),
        leave_group_members_path(group),
        remote: false, method: :delete
    end.to_sentence

    safe_format(s_(
      'The group settings for %{group_links} require you to enable Two-Factor Authentication for your account. ' \
        'You can %{leave_group_links}.'
    ), group_links: group_links.html_safe, leave_group_links: leave_group_links.html_safe)
  end

  def ensure_verified_primary_email
    unless current_user.two_factor_enabled? || current_user.primary_email_verified?
      redirect_to profile_emails_path,
        notice: s_('You need to verify your primary email first before enabling Two-Factor Authentication.')
    end
  end

  def setup_show_page
    if two_factor_authentication_required? && !current_user.two_factor_enabled?
      two_factor_auth_actions = {
        global: ->(_) do
          _('The global settings require you to enable Two-Factor Authentication for your account.')
        end,
        admin_2fa: ->(_) do
          _('Administrator users are required to enable Two-Factor Authentication for their account.')
        end,
        group: ->(groups) do
          groups_notification(groups)
        end
      }
      message = execute_action_for_2fa_reason(two_factor_auth_actions)
      message = append_configure_2fa_later(message) unless two_factor_grace_period_expired?
      flash.now[:alert] = message
    end

    @qr_code = build_qr_code
    @account_string = account_string

    setup_webauthn_registration
  end

  def append_configure_2fa_later(message)
    grace_period_deadline = current_user.otp_grace_period_started_at + two_factor_grace_period.hours
    render_to_string partial: 'configure_later_button',
      locals: { message: message, grace_period_deadline: grace_period_deadline }
  end
end
==== /workspace/gitlab/app/controllers/projects/google_cloud/revoke_oauth_controller.rb ====
# frozen_string_literal: true

class Projects::GoogleCloud::RevokeOauthController < Projects::GoogleCloud::BaseController
  before_action :validate_gcp_token!

  def create
    google_api_client = GoogleApi::CloudPlatform::Client.new(token_in_session, nil)
    response = google_api_client.revoke_authorizations

    if response.success?
      redirect_message = { notice: s_('GoogleCloud|Google OAuth2 token revocation requested') }
      track_event(:revoke_oauth)
    else
      redirect_message = { alert: s_('GoogleCloud|Google OAuth2 token revocation request failed') }
      track_event(:error)
    end

    session.delete(GoogleApi::CloudPlatform::Client.session_key_for_token)

    redirect_to project_google_cloud_configuration_path(project), redirect_message
  end
end
==== /workspace/gitlab/app/controllers/sessions_controller.rb ====
# frozen_string_literal: true

class SessionsController < Devise::SessionsController
  include InternalRedirect
  include AuthenticatesWithTwoFactor
  include CheckInitialSetup
  include Devise::Controllers::Rememberable
  include Recaptcha::Adapters::ViewMethods
  include Recaptcha::Adapters::ControllerMethods
  include RendersLdapServers
  include KnownSignIn
  include Gitlab::Utils::StrongMemoize
  include OneTrustCSP
  include BizibleCSP
  include VerifiesWithEmail
  include PreferredLanguageSwitcher
  include SkipsAlreadySignedInMessage
  include AcceptsPendingInvitations
  include SynchronizeBroadcastMessageDismissals
  extend ::Gitlab::Utils::Override

  skip_before_action :check_two_factor_requirement, only: [:destroy]
  skip_before_action :check_password_expiration, only: [:destroy]

  prepend_before_action :check_initial_setup, only: [:new]
  prepend_before_action :authenticate_with_two_factor,
    if: -> { action_name == 'create' && two_factor_enabled? }
  prepend_before_action :check_captcha, only: [:create]
  prepend_before_action :store_redirect_uri, only: [:new]
  prepend_before_action :require_no_authentication_without_flash, only: [:new, :create]
  prepend_before_action :ensure_password_authentication_enabled!,
    if: -> { action_name == 'create' && password_based_login? }
  before_action :auto_sign_in_with_provider, only: [:new]
  before_action :init_preferred_language, only: :new
  before_action :store_unauthenticated_sessions, only: [:new]
  before_action :save_failed_login, if: :action_new_and_failed_login?
  before_action :load_recaptcha
  before_action :set_invite_params, only: [:new]

  after_action :log_failed_login, if: :action_new_and_failed_login?
  after_action :verify_known_sign_in, only: [:create]

  helper_method :captcha_enabled?, :captcha_on_login_required?, :onboarding_status_tracking_label

  # protect_from_forgery is already prepended in ApplicationController but
  # authenticate_with_two_factor which signs in the user is prepended before
  # that here.
  # We need to make sure CSRF token is verified before authenticating the user
  # because Devise.clean_up_csrf_token_on_authentication is set to true by
  # default to avoid CSRF token fixation attacks. Authenticating the user first
  # would cause the CSRF token to be cleared and then
  # RequestForgeryProtection#verify_authenticity_token would fail because of
  # token mismatch.
  protect_from_forgery with: :exception, prepend: true, except: :destroy

  feature_category :system_access
  urgency :low

  CAPTCHA_HEADER = 'X-GitLab-Show-Login-Captcha'
  MAX_FAILED_LOGIN_ATTEMPTS = 5
  PRESERVE_COOKIES = %w[current_signin_tab preferred_language].freeze

  def new
    set_minimum_password_length

    super
  end

  def create
    super do |resource|
      # User has successfully signed in, so clear any unused reset token
      resource.update(reset_password_token: nil, reset_password_sent_at: nil) if resource.reset_password_token.present?

      if resource.deactivated?
        resource.activate
        flash[:notice] = _('Welcome back! Your account had been deactivated due to inactivity but is now reactivated.')
      else
        # hide the default signed-in notification
        flash[:notice] = nil
      end

      accept_pending_invitations

      synchronize_broadcast_message_dismissals(current_user)

      log_audit_event(current_user, resource, with: authentication_method)
      log_user_activity(current_user)
    end
  end

  def destroy
    headers['Clear-Site-Data'] = '"cache", "storage", "executionContexts", "clientHints"'
    Gitlab::AppLogger.info("User Logout: username=#{current_user.username} ip=#{request.remote_ip}")

    super

    # hide the signed_out notice
    flash[:notice] = nil

    # cookies must be deleted after super call
    # Warden sets some cookies for deletion, this will not override those settings
    cookies.each do |cookie|
      next if PRESERVE_COOKIES.include?(cookie[0])

      cookies.delete(cookie[0])
    end
  end

  private

  override :after_pending_invitations_hook
  def after_pending_invitations_hook
    member = resource.members.last

    store_location_for(:user, polymorphic_path(member.source)) if member
  end

  def captcha_enabled?
    request.headers[CAPTCHA_HEADER] && helpers.recaptcha_enabled?
  end

  def captcha_on_login_required?
    helpers.recaptcha_enabled_on_login? && unverified_anonymous_user?
  end

  # From https://github.com/plataformatec/devise/wiki/How-To:-Use-Recaptcha-with-Devise#devisepasswordscontroller
  def check_captcha
    return unless user_params[:password].present?
    return unless captcha_enabled? || captcha_on_login_required?
    return unless Gitlab::Recaptcha.load_configurations!

    if verify_recaptcha
      increment_successful_login_captcha_counter
    else
      increment_failed_login_captcha_counter

      self.resource = resource_class.new
      flash[:alert] = _('There was an error with the reCAPTCHA. Please solve the reCAPTCHA again.')
      flash.delete :recaptcha_error

      add_gon_variables

      respond_with_navigational(resource) { render :new }
    end
  end

  def increment_failed_login_captcha_counter
    Gitlab::Metrics.counter(
      :failed_login_captcha_total,
      'Number of failed CAPTCHA attempts for logins'
    ).increment
  end

  def increment_successful_login_captcha_counter
    Gitlab::Metrics.counter(
      :successful_login_captcha_total,
      'Number of successful CAPTCHA attempts for logins'
    ).increment
  end

  ##
  # We do have some duplication between lib/gitlab/auth/activity.rb here, but
  # leaving this method here because of backwards compatibility.
  #
  def login_counter
    @login_counter ||= Gitlab::Metrics.counter(:user_session_logins_total, 'User sign in count')
  end

  def log_failed_login
    Gitlab::AppLogger.info("Failed Login: username=#{user_params[:login]} ip=#{request.remote_ip}")
  end

  def action_new_and_failed_login?
    action_name == 'new' && failed_login?
  end

  def save_failed_login
    session[:failed_login_attempts] ||= 0
    session[:failed_login_attempts] += 1
  end

  def failed_login?
    (options = request.env["warden.options"]) && options[:action] == "unauthenticated"
  end

  # counting sessions per IP lets us check if there are associated multiple
  # anonymous sessions with one IP and prevent situations when there are
  # multiple attempts of logging in
  def store_unauthenticated_sessions
    return if current_user

    Gitlab::AnonymousSession.new(request.remote_ip).count_session_ip
  end

  # Handle an "initial setup" state, where there's only one user, it's an admin,
  # and they require a password change.
  def check_initial_setup
    return unless in_initial_setup_state?

    redirect_to new_admin_initial_setup_path
  end

  def ensure_password_authentication_enabled!
    render_403 unless Gitlab::CurrentSettings.password_authentication_enabled_for_web?
  end

  def password_based_login?
    user_params[:login].present? || user_params[:password].present?
  end

  def user_params
    params.require(:user).permit(:login, :password, :remember_me, :otp_attempt, :device_response)
  end

  def find_user
    strong_memoize(:find_user) do
      if session[:otp_user_id] && user_params[:login]
        User.by_login(user_params[:login]).find_by_id(session[:otp_user_id])
      elsif session[:otp_user_id]
        User.find(session[:otp_user_id])
      elsif user_params[:login]
        User.find_by_login(user_params[:login])
      end
    end
  end

  def stored_redirect_uri
    @redirect_to ||= stored_location_for(:redirect)
  end

  def store_redirect_uri
    redirect_uri =
      if request.referer.present? && (params['redirect_to_referer'] == 'yes')
        URI(request.referer)
      else
        URI(request.url)
      end

    # Prevent a 'you are already signed in' message directly after signing:
    # we should never redirect to '/users/sign_in' after signing in successfully.
    return true if redirect_uri.path == new_user_session_path

    redirect_to = redirect_uri.to_s if host_allowed?(redirect_uri)

    @redirect_to = redirect_to
    store_location_for(:redirect, redirect_to)
  end

  def two_factor_enabled?
    find_user&.two_factor_enabled?
  end

  def auto_sign_in_with_provider
    return unless Gitlab::Auth.omniauth_enabled?

    provider = Gitlab.config.omniauth.auto_sign_in_with_provider
    return unless provider.present?

    # If a "auto_sign_in" query parameter is set to a falsy value, don't auto sign-in.
    # Otherwise, the default is to auto sign-in.
    return if Gitlab::Utils.to_boolean(params[:auto_sign_in]) == false

    # Auto sign in with an Omniauth provider only if the standard "you need to sign-in" alert is
    # registered or no alert at all. In case of another alert (such as a blocked user), it is safer
    # to do nothing to prevent redirection loops with certain Omniauth providers.
    return unless flash[:alert].blank? || flash[:alert] == I18n.t('devise.failure.unauthenticated')

    # Prevent alert from popping up on the first page shown after authentication.
    flash[:alert] = nil

    @provider_path = omniauth_authorize_path(:user, provider)
    render 'devise/sessions/redirect_to_provider', layout: false
  end

  def valid_otp_attempt?(user)
    otp_validation_result =
      ::Users::ValidateManualOtpService.new(user).execute(user_params[:otp_attempt])
    return true if otp_validation_result[:status] == :success

    user.invalidate_otp_backup_code!(user_params[:otp_attempt])
  end

  def audit_event_name_for_authentication_method(method)
    case method
    when AuthenticationEvent::TWO_FACTOR
      'authenticated_with_two_factor'
    when AuthenticationEvent::TWO_FACTOR_WEBAUTHN
      'authenticated_with_webauthn'
    else
      'authenticated_with_password'
    end
  end

  def log_audit_event(user, resource, options = {})
    Gitlab::AppLogger.info(
      "Successful Login: username=#{resource.username} ip=#{request.remote_ip} " \
        "method=#{options[:with]} admin=#{resource.admin?}"
    )

    event_name = audit_event_name_for_authentication_method(options[:with] || AuthenticationEvent::STANDARD)
    audit_context = {
      name: event_name,
      author: user,
      scope: user,
      target: user,
      message: "Signed in with #{options[:with]} authentication",
      authentication_event: true,
      authentication_provider: options[:with],
      additional_details: {
        with: options[:with]
      }
    }
    ::Gitlab::Audit::Auditor.audit(audit_context)
  end

  def log_user_activity(user)
    login_counter.increment
    Users::ActivityService.new(author: user).execute
  end

  def load_recaptcha
    Gitlab::Recaptcha.load_configurations!
  end

  def unverified_anonymous_user?
    exceeded_failed_login_attempts? || exceeded_anonymous_sessions?
  end

  def exceeded_failed_login_attempts?
    session.fetch(:failed_login_attempts, 0) > MAX_FAILED_LOGIN_ATTEMPTS
  end

  def exceeded_anonymous_sessions?
    Gitlab::AnonymousSession.new(request.remote_ip).session_count >= MAX_FAILED_LOGIN_ATTEMPTS
  end

  def authentication_method
    if user_params[:otp_attempt]
      AuthenticationEvent::TWO_FACTOR
    elsif user_params[:device_response]
      AuthenticationEvent::TWO_FACTOR_WEBAUTHN
    else
      AuthenticationEvent::STANDARD
    end
  end

  def set_invite_params
    @invite_email = ActionController::Base.helpers.sanitize(params[:invite_email])
  end

  # overridden by EE module
  def onboarding_status_tracking_label; end
end

SessionsController.prepend_mod_with('SessionsController')
==== /workspace/gitlab/app/controllers/user_settings/active_sessions_controller.rb ====
# frozen_string_literal: true

module UserSettings
  class ActiveSessionsController < ApplicationController
    feature_category :system_access

    def index
      @sessions = ActiveSession.list(current_user).reject(&:is_impersonated)
    end

    def destroy
      # params[:id] can be an Rack::Session::SessionId#private_id
      ActiveSession.destroy_session(current_user, params[:id])
      current_user.invalidate_all_remember_tokens!

      respond_to do |format|
        format.html { redirect_to user_settings_active_sessions_url, status: :found }
        format.js { head :ok }
      end
    end
  end
end

UserSettings::ActiveSessionsController.prepend_mod
==== /workspace/gitlab/app/models/achievements/user_achievement.rb ====
# frozen_string_literal: true

module Achievements
  class UserAchievement < ApplicationRecord
    belongs_to :achievement, inverse_of: :user_achievements, optional: false
    belongs_to :user, inverse_of: :user_achievements, optional: false

    belongs_to :awarded_by_user,
      class_name: 'User',
      inverse_of: :awarded_user_achievements,
      optional: false
    belongs_to :revoked_by_user,
      class_name: 'User',
      inverse_of: :revoked_user_achievements,
      optional: true

    scope :not_revoked, -> { where(revoked_by_user_id: nil) }
    scope :shown_on_profile, -> { where(show_on_profile: true) }
    scope :order_by_priority_asc, -> {
      keyset_order = Gitlab::Pagination::Keyset::Order.build([
        Gitlab::Pagination::Keyset::ColumnOrderDefinition.new(
          attribute_name: 'priority',
          order_expression: ::Achievements::UserAchievement.arel_table[:priority].asc,
          nullable: :nulls_last
        ),
        Gitlab::Pagination::Keyset::ColumnOrderDefinition.new(
          attribute_name: 'id',
          order_expression: ::Achievements::UserAchievement.arel_table[:id].asc,
          nullable: :not_nullable
        )
      ])
      reorder(keyset_order)
    }
    scope :order_by_id_asc, -> { order(id: :asc) }

    validates :show_on_profile, inclusion: { in: [false, true] }

    def revoked?
      revoked_by_user_id.present?
    end
  end
end
==== /workspace/gitlab/app/models/active_session.rb ====
# frozen_string_literal: true

# Backing store for GitLab session data.
#
# The raw session information is stored by the Rails session store
# (config/initializers/session_store.rb). These entries are accessible by the
# rack_key_name class method and constitute the base of the session data
# entries. All other entries in the session store can be traced back to these
# entries.
#
# After a user logs in (config/initializers/warden.rb) a further entry is made
# in Redis. This entry holds a record of the user's logged in session. These
# are accessible with the key_name(user_id, session_id) class method. These
# entries will expire. Lookups to these entries are lazilly cleaned on future
# user access.
#
# There is a reference to all sessions that belong to a specific user. A
# user may login through multiple browsers/devices and thus record multiple
# login sessions. These are accessible through the lookup_key_name(user_id)
# class method.
#
class ActiveSession
  include ActiveModel::Model

  SESSION_BATCH_SIZE = 200
  ALLOWED_NUMBER_OF_ACTIVE_SESSIONS = 100

  ATTR_ACCESSOR_LIST = [
    :ip_address, :browser, :os,
    :device_name, :device_type,
    :is_impersonated, :session_id, :session_private_id,
    :admin_mode, :step_up_authenticated
  ].freeze
  ATTR_READER_LIST = [
    :created_at, :updated_at
  ].freeze

  attr_accessor(*ATTR_ACCESSOR_LIST)
  attr_reader(*ATTR_READER_LIST)

  def created_at=(time)
    @created_at = time.is_a?(String) ? Time.zone.parse(time) : time
  end

  def updated_at=(time)
    @updated_at = time.is_a?(String) ? Time.zone.parse(time) : time
  end

  def current?(rack_session)
    return false if session_private_id.nil? || rack_session.id.nil?

    # Rack v2.0.8+ added private_id, which uses the hash of the
    # public_id to avoid timing attacks.
    session_private_id == rack_session.id.private_id
  end

  def eql?(other)
    other.is_a?(self.class) && id == other.id
  end
  alias_method :==, :eql?

  def id
    session_private_id.presence || session_id
  end

  def ids
    [session_private_id, session_id].compact
  end

  def human_device_type
    device_type&.titleize
  end

  def self.set(user, request)
    Gitlab::Redis::Sessions.with do |redis|
      session_private_id = request.session.id.private_id
      client = Gitlab::SafeDeviceDetector.new(request.user_agent)
      timestamp = Time.current
      expiry = Settings.gitlab['session_expire_delay'] * 60

      active_user_session = new(
        ip_address: request.remote_ip,
        browser: client.name,
        os: client.os_name,
        device_name: client.device_name,
        device_type: client.device_type,
        created_at: user.current_sign_in_at || timestamp,
        updated_at: timestamp,
        session_private_id: session_private_id,
        is_impersonated: request.session[:impersonator_id].present?,
        admin_mode: Gitlab::Auth::CurrentUserMode.new(user, request.session).admin_mode?,
        step_up_authenticated:
          Feature.enabled?(:omniauth_step_up_auth_for_admin_mode, user) &&
            ::Gitlab::Auth::Oidc::StepUpAuthentication.succeeded?(request.session)
      )

      Gitlab::Instrumentation::RedisClusterValidator.allow_cross_slot_commands do
        redis.pipelined do |pipeline|
          pipeline.setex(
            key_name(user.id, session_private_id),
            expiry,
            active_user_session.dump
          )

          pipeline.sadd?(
            lookup_key_name(user.id),
            session_private_id
          )
        end
      end
    end
  end

  def self.list(user)
    Gitlab::Redis::Sessions.with do |redis|
      cleaned_up_lookup_entries(redis, user).map do |raw_session|
        load_raw_session(raw_session)
      end
    end
  end

  def self.cleanup(user)
    Gitlab::Redis::Sessions.with do |redis|
      clean_up_old_sessions(redis, user)
      cleaned_up_lookup_entries(redis, user)
    end
  end

  def self.destroy_sessions(redis, user, session_ids)
    return if session_ids.empty?

    key_names = session_ids.map { |session_id| key_name(user.id, session_id) }
    key_names += session_ids.map { |session_id| key_name_v1(user.id, session_id) }

    redis.srem(lookup_key_name(user.id), session_ids)

    session_keys = rack_session_keys(session_ids)
    Gitlab::Instrumentation::RedisClusterValidator.allow_cross_slot_commands do
      if Gitlab::Redis::ClusterUtil.cluster?(redis)
        Gitlab::Redis::ClusterUtil.batch_unlink(key_names, redis)
        Gitlab::Redis::ClusterUtil.batch_unlink(session_keys, redis)
      else
        redis.del(key_names)
        redis.del(session_keys)
      end
    end
  end

  def self.destroy_session(user, session_id)
    return unless session_id

    Gitlab::Redis::Sessions.with do |redis|
      destroy_sessions(redis, user, [session_id].compact)
    end
  end

  def self.destroy_all_but_current(user, current_rack_session)
    sessions = not_impersonated(user)
    sessions.reject! { |session| session.current?(current_rack_session) } if current_rack_session

    Gitlab::Redis::Sessions.with do |redis|
      session_ids = sessions.flat_map(&:ids)
      destroy_sessions(redis, user, session_ids) if session_ids.any?
    end
  end

  private_class_method def self.not_impersonated(user)
    list(user).reject(&:is_impersonated)
  end

  private_class_method def self.rack_key_name(session_id)
    "#{Gitlab::Redis::Sessions::SESSION_NAMESPACE}:#{session_id}"
  end

  def self.key_name(user_id, session_id = '*')
    "#{Gitlab::Redis::Sessions::USER_SESSIONS_NAMESPACE}::v2:#{user_id}:#{session_id}"
  end

  # Deprecated
  def self.key_name_v1(user_id, session_id = '*')
    "#{Gitlab::Redis::Sessions::USER_SESSIONS_NAMESPACE}:#{user_id}:#{session_id}"
  end

  def self.lookup_key_name(user_id)
    "#{Gitlab::Redis::Sessions::USER_SESSIONS_LOOKUP_NAMESPACE}:#{user_id}"
  end

  def self.list_sessions(user)
    sessions_from_ids(session_ids_for_user(user.id))
  end

  # Lists the relevant session IDs for the user.
  #
  # Returns an array of strings
  def self.session_ids_for_user(user_id)
    Gitlab::Redis::Sessions.with do |redis|
      redis.smembers(lookup_key_name(user_id))
    end
  end

  # Lists the session Hash objects for the given session IDs.
  #
  # session_ids - An array of strings
  #
  # Returns an array of ActiveSession objects
  def self.sessions_from_ids(session_ids)
    return [] if session_ids.empty?

    Gitlab::Redis::Sessions.with do |redis|
      session_keys = rack_session_keys(session_ids)

      session_keys.each_slice(SESSION_BATCH_SIZE).flat_map do |session_keys_batch|
        Gitlab::Instrumentation::RedisClusterValidator.allow_cross_slot_commands do
          raw_sessions = if Gitlab::Redis::ClusterUtil.cluster?(redis)
                           Gitlab::Redis::ClusterUtil.batch_get(session_keys_batch, redis)
                         else
                           redis.mget(session_keys_batch)
                         end

          raw_sessions.compact.map do |raw_session|
            load_raw_session(raw_session)
          end
        end
      end
    end
  end

  def dump
    "v2:#{Gitlab::Json.dump(self)}"
  end

  # Private:

  # raw_session - Raw bytes from Redis
  #
  # Returns an instance of this class
  private_class_method def self.load_raw_session(raw_session)
    return unless raw_session

    if raw_session.start_with?('v2:')
      session_data = Gitlab::Json.parse(raw_session[3..]).symbolize_keys
      # load only known attributes
      session_data.slice!(*ATTR_ACCESSOR_LIST.union(ATTR_READER_LIST))
      new(**session_data)
    else
      # Deprecated legacy format. To be removed in 15.0
      # See: https://gitlab.com/gitlab-org/gitlab/-/issues/30516
      # Explanation of why this Marshal.load call is OK:
      # https://gitlab.com/gitlab-com/gl-security/product-security/appsec/appsec-reviews/-/issues/124#note_744576714
      session_data = ActiveSupport::Cache::SerializerWithFallback[:marshal_7_1].load(raw_session)
      session_data.is_a?(ActiveSupport::Cache::Entry) ? session_data.value : session_data
    end
  end

  private_class_method def self.rack_session_keys(rack_session_ids)
    rack_session_ids.map { |session_id| rack_key_name(session_id) }
  end

  private_class_method def self.raw_active_session_entries(redis, session_ids, user_id)
    return {} if session_ids.empty?

    found = Gitlab::Instrumentation::RedisClusterValidator.allow_cross_slot_commands do
      entry_keys = session_ids.map { |session_id| key_name(user_id, session_id) }
      entries = if Gitlab::Redis::ClusterUtil.cluster?(redis)
                  Gitlab::Redis::ClusterUtil.batch_get(entry_keys, redis)
                else
                  redis.mget(entry_keys)
                end

      session_ids.zip(entries).to_h
    end

    found.compact!
    missing = session_ids - found.keys
    return found if missing.empty?

    fallbacks = Gitlab::Instrumentation::RedisClusterValidator.allow_cross_slot_commands do
      entry_keys = missing.map { |session_id| key_name_v1(user_id, session_id) }
      entries = if Gitlab::Redis::ClusterUtil.cluster?(redis)
                  Gitlab::Redis::ClusterUtil.batch_get(entry_keys, redis)
                else
                  redis.mget(entry_keys)
                end

      missing.zip(entries).to_h
    end

    fallbacks.merge(found.compact)
  end

  private_class_method def self.active_session_entries(session_ids, user_id, redis)
    return [] if session_ids.empty?

    raw_active_session_entries(redis, session_ids, user_id)
      .values
      .compact
      .map { load_raw_session(_1) }
  end

  private_class_method def self.clean_up_old_sessions(redis, user)
    session_ids = session_ids_for_user(user.id)

    return if session_ids.count <= ALLOWED_NUMBER_OF_ACTIVE_SESSIONS

    sessions = active_session_entries(session_ids, user.id, redis)
    sessions.sort_by!(&:updated_at).reverse!

    # remove sessions if there are more than ALLOWED_NUMBER_OF_ACTIVE_SESSIONS.
    destroyable_session_ids = sessions
      .drop(ALLOWED_NUMBER_OF_ACTIVE_SESSIONS)
      .flat_map(&:ids)

    destroy_sessions(redis, user, destroyable_session_ids)
  end

  # Cleans up the lookup set by removing any session IDs that are no longer present.
  #
  # Returns an array of marshalled ActiveModel objects that are still active.
  # Records removed keys in the optional `removed` argument array.
  def self.cleaned_up_lookup_entries(redis, user, removed = [])
    lookup_key = lookup_key_name(user.id)
    session_ids = session_ids_for_user(user.id)
    session_ids_and_entries = raw_active_session_entries(redis, session_ids, user.id)

    # remove expired keys.
    # only the single key entries are automatically expired by redis, the
    # lookup entries in the set need to be removed manually.
    redis.pipelined do |pipeline|
      session_ids_and_entries.each do |session_id, entry|
        next if entry

        pipeline.srem?(lookup_key, session_id)
      end
    end

    removed.concat(session_ids_and_entries.select { |_, v| v.nil? }.keys)

    session_ids_and_entries.values.compact
  end
end

ActiveSession.prepend_mod_with('ActiveSession')
==== /workspace/gitlab/app/models/alert_management/alert_user_mention.rb ====
# frozen_string_literal: true

module AlertManagement
  class AlertUserMention < UserMention
    belongs_to :alert, class_name: '::AlertManagement::Alert',
      foreign_key: :alert_management_alert_id,
      inverse_of: :user_mentions

    belongs_to :note
  end
end
==== /workspace/gitlab/app/models/anti_abuse/reports/user_mention.rb ====
# frozen_string_literal: true

module AntiAbuse
  module Reports
    class UserMention < UserMention
      self.table_name = 'abuse_report_user_mentions'

      belongs_to :abuse_report, optional: false
      belongs_to :note, optional: false
    end
  end
end
==== /workspace/gitlab/app/models/anti_abuse/user_trust_score.rb ====
# frozen_string_literal: true

module AntiAbuse
  class UserTrustScore
    MAX_EVENTS = 100
    SPAMCHECK_HAM_THRESHOLD = 0.5

    def initialize(user)
      @user = user
    end

    def spammer?
      spam_score > SPAMCHECK_HAM_THRESHOLD
    end

    def spam_score
      user_scores.spamcheck.average(:score) || 0.0
    end

    def telesign_score
      user_scores.telesign.order_created_at_desc.first&.score || 0.0
    end

    def arkose_global_score
      user_scores.arkose_global_score.order_created_at_desc.first&.score || 0.0
    end

    def arkose_custom_score
      user_scores.arkose_custom_score.order_created_at_desc.first&.score || 0.0
    end

    def trust_scores_for_source(source)
      user_scores.where(source: source)
    end

    def remove_old_scores(source)
      count = trust_scores_for_source(source).count
      return unless count > MAX_EVENTS

      AntiAbuse::TrustScore.delete(
        trust_scores_for_source(source)
        .order_created_at_asc
        .limit(count - MAX_EVENTS)
      )
    end

    private

    def user_scores
      AntiAbuse::TrustScore.where(user_id: @user.id)
    end
  end
end
==== /workspace/gitlab/app/models/atlassian/identity.rb ====
# frozen_string_literal: true

module Atlassian
  class Identity < ApplicationRecord
    include Gitlab::EncryptedAttribute

    self.table_name = 'atlassian_identities'

    belongs_to :user

    validates :extern_uid, presence: true, uniqueness: true
    validates :user, presence: true, uniqueness: true

    attr_encrypted :token,
      mode: :per_attribute_iv,
      key: :db_key_base_32,
      algorithm: 'aes-256-gcm',
      encode: false,
      encode_iv: false

    attr_encrypted :refresh_token,
      mode: :per_attribute_iv,
      key: :db_key_base_32,
      algorithm: 'aes-256-gcm',
      encode: false,
      encode_iv: false
  end
end
==== /workspace/gitlab/app/models/audit_events/user_audit_event.rb ====
# frozen_string_literal: true

module AuditEvents
  class UserAuditEvent < ApplicationRecord
    self.table_name = "user_audit_events"

    include AuditEvents::CommonModel

    validates :user_id, presence: true

    scope :by_user, ->(user_id) { where(user_id: user_id) }
    scope :by_username, ->(username) { where(user_id: find_user_id(username)) }
  end
end

AuditEvents::UserAuditEvent.prepend_mod
==== /workspace/gitlab/app/models/authentication_event.rb ====
# frozen_string_literal: true

class AuthenticationEvent < ApplicationRecord
  include UsageStatistics

  TWO_FACTOR = 'two-factor'
  TWO_FACTOR_WEBAUTHN = 'two-factor-via-webauthn-device'
  STANDARD = 'standard'
  STATIC_PROVIDERS = [TWO_FACTOR, TWO_FACTOR_WEBAUTHN, STANDARD].freeze

  belongs_to :user, optional: true

  validates :provider, :user_name, :result, presence: true
  validates :ip_address, ip_address: true

  enum :result, {
    failed: 0,
    success: 1
  }

  scope :for_provider, ->(provider) { where(provider: provider) }
  scope :ldap, -> { where('provider LIKE ?', 'ldap%') }
  scope :for_user, ->(user) { where(user: user) }
  scope :order_by_created_at_desc, -> { reorder(created_at: :desc) }

  def self.providers
    STATIC_PROVIDERS | Devise.omniauth_providers.map(&:to_s)
  end

  def self.initial_login_or_known_ip_address?(user, ip_address)
    !where(user_id: user).exists? ||
      where(user_id: user, ip_address: ip_address).success.exists?
  end

  def self.most_used_ip_address_for_user(user)
    select('mode() within group (order by ip_address) as ip_address').find_by(user: user).ip_address
  end
end
==== /workspace/gitlab/app/models/authn/personal_access_token_last_used_ip.rb ====
# frozen_string_literal: true

module Authn
  class PersonalAccessTokenLastUsedIp < ApplicationRecord
    self.table_name = 'personal_access_token_last_used_ips'
    belongs_to :personal_access_token
    belongs_to :organization, class_name: 'Organizations::Organization'
  end
end
==== /workspace/gitlab/app/models/commit_user_mention.rb ====
# frozen_string_literal: true

class CommitUserMention < UserMention
  belongs_to :note
end
==== /workspace/gitlab/app/models/concerns/bulk_users_by_email_load.rb ====
# frozen_string_literal: true

module BulkUsersByEmailLoad
  extend ActiveSupport::Concern

  included do
    def users_by_emails(emails)
      Gitlab::SafeRequestLoader.execute(resource_key: user_by_email_resource_key, resource_ids: emails) do |emails|
        # We have to consider all emails - even secondary, so use all_emails here to accomplish that.
        # The by_any_email method will search for lowercased emails only, which means the
        # private_commit_email values may not get cached properly due to it being able to be non-lowercased.
        # That is likely ok as the use of those in the current use of this construct is likely very rare.
        # Perhaps to be looked at more in https://gitlab.com/gitlab-org/gitlab/-/issues/461885
        grouped_users_by_email = User.by_any_email(emails, confirmed: true).preload(:emails).group_by(&:all_emails)

        grouped_users_by_email.each_with_object({}) do |(found_emails, users), h|
          found_emails.each do |e| # don't include all emails for an account, only the ones we want
            h[e] = users.first if emails.include?(e)
          end
        end
      end
    end

    private

    def user_by_email_resource_key
      "user_by_email_for_#{User.name.underscore.pluralize}:#{self.class}:#{self.id}"
    end
  end
end
==== /workspace/gitlab/app/models/concerns/encrypted_user_password.rb ====
# frozen_string_literal: true

# Support for both BCrypt and PBKDF2+SHA512 user passwords
# Meant to be used exclusively with User model but extracted
# to a concern for isolation and clarity.
module EncryptedUserPassword
  extend ActiveSupport::Concern

  BCRYPT_PREFIX = '$2a$'
  PBKDF2_SHA512_PREFIX = '$pbkdf2-sha512$'
  PBKDF2_SALT_LENGTH = 64

  BCRYPT_STRATEGY = :bcrypt
  PBKDF2_SHA512_STRATEGY = :pbkdf2_sha512

  # Use Devise DatabaseAuthenticatable#authenticatable_salt
  # unless encrypted password is PBKDF2+SHA512.
  def authenticatable_salt
    return super unless pbkdf2_password?

    Devise::Pbkdf2Encryptable::Encryptors::Pbkdf2Sha512.split_digest(encrypted_password)[:salt]
  end

  # Called by Devise during database authentication.
  # Also migrates the user password to the configured
  # encryption type (BCrypt or PBKDF2+SHA512), if needed.
  def valid_password?(password)
    return false unless password_matches?(password)

    migrate_password!(password)
  end

  def password=(new_password)
    @password = new_password # rubocop:disable Gitlab/ModuleWithInstanceVariables
    return unless new_password.present?

    # Use SafeRequestStore to cache the password hash during registration
    # This prevents redundant bcrypt operations when the same password is set on multiple
    # User objects during registration. Our analysis showed that two separate User objects
    # are created during registration (one by BuildService and another by Devise), and
    # both trigger expensive password hashing operations. By caching within the request,
    # we reduce registration time by ~31% while maintaining security.
    hash_key = "password_hash:#{Digest::SHA256.hexdigest(new_password.to_s)}"

    self.encrypted_password = Gitlab::SafeRequestStore.fetch(hash_key) do
      hash_this_password(new_password)
    end
  end

  private

  # Generates a hashed password for the configured encryption method
  # (BCrypt or PBKDF2+SHA512).
  # DOES NOT SAVE IT IN ANY WAY.
  def hash_this_password(password)
    if Gitlab::FIPS.enabled?
      Devise::Pbkdf2Encryptable::Encryptors::Pbkdf2Sha512.digest(
        password,
        Devise::Pbkdf2Encryptable::Encryptors::Pbkdf2Sha512::STRETCHES,
        Devise.friendly_token(PBKDF2_SALT_LENGTH))
    else
      Devise::Encryptor.digest(self.class, password)
    end
  end

  def password_strategy
    return BCRYPT_STRATEGY if encrypted_password.starts_with?(BCRYPT_PREFIX)
    return PBKDF2_SHA512_STRATEGY if encrypted_password.starts_with?(PBKDF2_SHA512_PREFIX)

    :unknown
  end

  def pbkdf2_password?
    password_strategy == PBKDF2_SHA512_STRATEGY
  end

  def bcrypt_password?
    password_strategy == BCRYPT_STRATEGY
  end

  def password_matches?(password)
    if bcrypt_password?
      Devise::Encryptor.compare(self.class, encrypted_password, password)
    elsif pbkdf2_password?
      Devise::Pbkdf2Encryptable::Encryptors::Pbkdf2Sha512.compare(encrypted_password, password)
    end
  end

  def migrate_password!(password)
    # A note on ordering here:
    # Other code expects to use this function to switch between pbkdf2 and bcrypt.
    # Hence, if password strategy != encryptor, we need to fail immediately and migrate.
    # Reversing this ordering will break tests in spec/models/concerns/encrypted_user_password_spec.rb.

    if password_strategy == encryptor
      if BCRYPT_STRATEGY == password_strategy
        return true if bcrypt_password_matches_current_stretches?
      elsif PBKDF2_SHA512_STRATEGY == password_strategy
        return true if pbkdf2_password_matches_salt_length?
      end
    end

    skip_password_change_notification!
    # We get some password_change emails even when
    # skip_password_change_notification! is set and update_attribute is used.
    # update_column skips callbacks: https://stackoverflow.com/a/14416455
    update_column(:encrypted_password, hash_this_password(password))
  end

  def bcrypt_password_matches_current_stretches?
    return false unless bcrypt_password?

    ::BCrypt::Password.new(encrypted_password).cost == self.class.stretches
  end

  def pbkdf2_password_matches_salt_length?
    return false unless pbkdf2_password?

    current_salt_length = Devise::Pbkdf2Encryptable::Encryptors::Pbkdf2Sha512
      .split_digest(encrypted_password)[:salt].length

    PBKDF2_SALT_LENGTH == current_salt_length
  end

  def encryptor
    return BCRYPT_STRATEGY unless Gitlab::FIPS.enabled?

    PBKDF2_SHA512_STRATEGY
  end
end
==== /workspace/gitlab/app/models/concerns/ghost_user.rb ====
# frozen_string_literal: true

module GhostUser
  extend ActiveSupport::Concern

  def ghost_user?
    user && user.ghost?
  end
end
==== /workspace/gitlab/app/models/concerns/has_user_type.rb ====
# frozen_string_literal: true

module HasUserType
  extend ActiveSupport::Concern

  USER_TYPES = {
    human: 0,
    support_bot: 1,
    alert_bot: 2,
    visual_review_bot: 3,
    service_user: 4,
    ghost: 5,
    project_bot: 6,
    migration_bot: 7,
    security_bot: 8,
    automation_bot: 9,
    security_policy_bot: 10,
    admin_bot: 11,
    suggested_reviewers_bot: 12,
    service_account: 13,
    llm_bot: 14,
    placeholder: 15,
    duo_code_review_bot: 16,
    import_user: 17
  }.with_indifferent_access.freeze

  BOT_USER_TYPES = %w[
    alert_bot
    project_bot
    support_bot
    visual_review_bot
    migration_bot
    security_bot
    automation_bot
    security_policy_bot
    admin_bot
    suggested_reviewers_bot
    service_account
    llm_bot
    duo_code_review_bot
  ].freeze

  # `service_account` allows instance/namespaces to configure a user for external integrations/automations
  # `service_user` is an internal, `gitlab-com`-specific user type for integrations like suggested reviewers
  # Changes to these types might have billing implications, https://docs.gitlab.com/ee/subscriptions/gitlab_com/#billable-users
  NON_INTERNAL_USER_TYPES = %w[human project_bot service_user service_account].freeze
  INTERNAL_USER_TYPES = (USER_TYPES.keys - NON_INTERNAL_USER_TYPES).freeze

  included do
    enum :user_type, USER_TYPES

    scope :bots, -> { where(user_type: BOT_USER_TYPES) }
    scope :without_bots, -> { where(user_type: USER_TYPES.keys - BOT_USER_TYPES) }
    scope :non_internal, -> { where(user_type: NON_INTERNAL_USER_TYPES) }
    scope :with_duo_code_review_bot, -> { where(user_type: NON_INTERNAL_USER_TYPES + ['duo_code_review_bot']) }
    scope :without_ghosts, -> { where(user_type: USER_TYPES.keys - ['ghost']) }
    scope :without_project_bot, -> { where(user_type: USER_TYPES.keys - ['project_bot']) }
    scope :without_humans, -> { where(user_type: USER_TYPES.keys - ['human']) }
    scope :human_or_service_user, -> { where(user_type: %i[human service_user]) }
    scope :resource_access_token_bot, -> { where(user_type: 'project_bot') }
    scope :service_accounts, -> { where(user_type: 'service_account') }
    scope :without_placeholders, -> { where.not(user_type: 'placeholder') }

    validates :user_type, presence: true
  end

  def bot?
    BOT_USER_TYPES.include?(user_type)
  end

  def internal?
    INTERNAL_USER_TYPES.include?(user_type)
  end

  def redacted_name(viewing_user)
    return self.name unless self.project_bot?

    return self.name if self.groups.any? && viewing_user&.can?(:read_group, self.groups.first)

    return self.name if viewing_user&.can?(:read_project, self.projects.first)

    # If the requester does not have permission to read the project bot name,
    # the API returns an arbitrary string. UI changes will be addressed in a follow up issue:
    # https://gitlab.com/gitlab-org/gitlab/-/issues/346058
    '****'
  end

  def resource_bot_resource
    return unless project_bot?

    projects&.first || groups&.first
  end

  def resource_bot_owners_and_maintainers
    return [] unless project_bot?

    resource = resource_bot_resource
    return [] unless resource

    return resource.owners_and_maintainers if resource.is_a?(Project)

    resource
      .owners
      .allow_cross_joins_across_databases(url: "https://gitlab.com/gitlab-org/gitlab/-/issues/436658")
  end
end
==== /workspace/gitlab/app/models/concerns/user_mention_behaviour.rb ====
# frozen_string_literal: true

module UserMentionBehaviour # rubocop:disable Gitlab/BoundedContexts -- Module is a functional mimic of an existing model
  extend ActiveSupport::Concern

  included do
    scope :for_notes, ->(notes) { where(note_id: notes) }
  end

  def has_mentions?
    mentioned_users_ids.present? || mentioned_groups_ids.present? || mentioned_projects_ids.present?
  end

  private

  def mentioned_users
    User.where(id: mentioned_users_ids)
  end

  def mentioned_groups
    Group.where(id: mentioned_groups_ids)
  end

  def mentioned_projects
    Project.where(id: mentioned_projects_ids)
  end
end
==== /workspace/gitlab/app/models/design_user_mention.rb ====
# frozen_string_literal: true

class DesignUserMention < UserMention
  belongs_to :design, class_name: 'DesignManagement::Design'
  belongs_to :note
end
==== /workspace/gitlab/app/models/directly_addressed_user.rb ====
# frozen_string_literal: true

class DirectlyAddressedUser
  class << self
    def reference_pattern
      User.reference_pattern
    end
  end
end
==== /workspace/gitlab/app/models/identity.rb ====
# frozen_string_literal: true

class Identity < ApplicationRecord
  include Sortable
  include CaseSensitivity

  belongs_to :user

  validates :provider, presence: true
  validates :extern_uid, allow_blank: true, uniqueness: {
    scope: UniquenessScopes.scopes,
    case_sensitive: false,
    message: "has already been taken. Please contact your administrator to generate a unique extern_uid / NameID"
  }

  validates :user, uniqueness: { scope: UniquenessScopes.scopes }

  before_save :ensure_normalized_extern_uid, if: :extern_uid_changed?
  after_destroy :clear_user_synced_attributes, if: :user_synced_attributes_metadata_from_provider?

  scope :for_user, ->(user) { where(user: user) }
  scope :for_user_ids, ->(user_ids) { where(user_id: user_ids) }
  scope :with_provider, ->(provider) { where(provider: provider) }
  scope :with_extern_uid, ->(provider, extern_uid) do
    iwhere(extern_uid: normalize_uid(provider, extern_uid)).with_provider(provider)
  end
  scope :with_any_extern_uid, ->(provider) do
    where.not(extern_uid: nil).with_provider(provider)
  end

  def ldap?
    Gitlab::Auth::OAuth::Provider.ldap_provider?(provider)
  end

  def self.normalize_uid(provider, uid)
    if Gitlab::Auth::OAuth::Provider.ldap_provider?(provider)
      Gitlab::Auth::Ldap::Person.normalize_dn(uid)
    else
      uid.to_s
    end
  end

  private

  def ensure_normalized_extern_uid
    return if extern_uid.nil?

    self.extern_uid = Identity.normalize_uid(self.provider, self.extern_uid)
  end

  def user_synced_attributes_metadata_from_provider?
    user.user_synced_attributes_metadata&.provider == provider
  end

  def clear_user_synced_attributes
    user.user_synced_attributes_metadata&.destroy
  end
end

Identity.prepend_mod_with('Identity')
==== /workspace/gitlab/app/models/import/namespace_import_user.rb ====
# frozen_string_literal: true

module Import
  class NamespaceImportUser < ApplicationRecord
    self.table_name = 'namespace_import_users'

    belongs_to :import_user, class_name: 'User', foreign_key: :user_id, inverse_of: :namespace_import_user
    belongs_to :namespace

    validates :namespace_id, :user_id, presence: true
  end
end
==== /workspace/gitlab/app/models/import/placeholder_user_detail.rb ====
# frozen_string_literal: true

module Import
  class PlaceholderUserDetail < ApplicationRecord
    self.table_name = 'import_placeholder_user_details'

    DELETION_RETRY_PERIOD = 2.days

    belongs_to :placeholder_user, class_name: 'User', inverse_of: :placeholder_user_detail
    belongs_to :namespace
    belongs_to :organization, class_name: 'Organizations::Organization'

    validates :deletion_attempts, numericality: { greater_than_or_equal_to: 0 }
    validates :placeholder_user, presence: true

    def self.eligible_for_deletion(max_attempts = PlaceholderUserCleanupWorker::MAX_ATTEMPTS)
      base_query = where(deletion_attempts: ...max_attempts, namespace_id: nil)

      never_attempted_records = base_query.where(last_deletion_attempt_at: nil)
      retry_eligible_records = base_query.where(last_deletion_attempt_at: ...DELETION_RETRY_PERIOD.ago)

      from(
        "(#{never_attempted_records.to_sql} UNION " \
          "#{retry_eligible_records.to_sql}) AS import_placeholder_user_details"
      ).select('import_placeholder_user_details.*')
    end

    def increment_deletion_attempt
      ::Import::PlaceholderUserDetail.increment_counter(:deletion_attempts, id, touch: :last_deletion_attempt_at)
    end
  end
end
==== /workspace/gitlab/app/models/import/source_user_placeholder_reference.rb ====
# frozen_string_literal: true

module Import
  class SourceUserPlaceholderReference < ApplicationRecord
    include BulkInsertSafe
    include EachBatch

    self.table_name = 'import_source_user_placeholder_references'

    belongs_to :source_user, class_name: 'Import::SourceUser'
    belongs_to :namespace

    validates :model, :namespace_id, :source_user_id, :user_reference_column, :alias_version, presence: true
    validates :numeric_key, numericality: { only_integer: true, greater_than: 0 }, allow_nil: true
    validates :composite_key,
      json_schema: { filename: 'import_source_user_placeholder_reference_composite_key' },
      allow_nil: true
    validate :validate_numeric_or_composite_key_present
    validate :validate_model_is_not_member

    attribute :composite_key, ::Gitlab::Database::Type::IndifferentJsonb.new

    scope :model_groups_for_source_user, ->(source_user) do
      where(source_user: source_user)
        .select(:model, :user_reference_column, :alias_version)
        .group(:model, :user_reference_column, :alias_version)
    end

    MODEL_BATCH_LIMIT = 500

    # If an element is ever added to this array, ensure that `.from_serialized` handles receiving
    # older versions of the array by filling in missing values with defaults. We'd keep that in place
    # for at least one release cycle to ensure backward compatibility.
    SERIALIZABLE_ATTRIBUTES = %w[
      composite_key
      model
      namespace_id
      numeric_key
      source_user_id
      user_reference_column
      alias_version
    ].freeze

    SerializationError = Class.new(StandardError)

    def aliased_model
      PlaceholderReferences::AliasResolver.aliased_model(model, version: alias_version)
    end

    def aliased_user_reference_column
      PlaceholderReferences::AliasResolver.aliased_column(model, user_reference_column, version: alias_version)
    end

    def aliased_composite_key
      composite_key.transform_keys do |key|
        PlaceholderReferences::AliasResolver.aliased_column(model, key, version: alias_version)
      end
    end

    def to_serialized
      Gitlab::Json.dump(attributes.slice(*SERIALIZABLE_ATTRIBUTES).to_h.values)
    end

    def model_record
      model_class = aliased_model

      model_relation = numeric_key? ? model_class.primary_key_in(numeric_key) : model_class.where(composite_key)
      model_relation.where({ aliased_user_reference_column => source_user.placeholder_user_id }).first
    end

    class << self
      def from_serialized(serialized_reference)
        deserialized = Gitlab::Json.parse(serialized_reference)

        raise SerializationError if deserialized.size != SERIALIZABLE_ATTRIBUTES.size

        attributes = SERIALIZABLE_ATTRIBUTES.zip(deserialized).to_h

        new(attributes.merge(created_at: Time.zone.now))
      end

      # Model relations are yielded in a block to ensure all relations will be batched, regardless of the model
      def model_relations_for_source_user_reference(model:, source_user:, user_reference_column:, alias_version:)
        aliased_model = PlaceholderReferences::AliasResolver.aliased_model(model, version: alias_version)
        aliased_user_reference_column = PlaceholderReferences::AliasResolver.aliased_column(
          model, user_reference_column, version: alias_version
        )
        primary_key = aliased_model.primary_key

        where(model:, source_user:, user_reference_column:, alias_version:).each_batch(of: MODEL_BATCH_LIMIT) do
          |placeholder_reference_batch|
          model_relation = nil

          # This is the simplest way to check for composite pkey for now. In Rails 7.1, composite primary keys will be
          # fully supported: https://guides.rubyonrails.org/7_1_release_notes.html#composite-primary-keys.
          # The `elseif primary_key.is_a?(Array)` block exists for Rails 7.1 support, so will not execute in Rails 7.0,
          # thus the code is not covered by specs and we can ignore underecoverage reports about it until we upgrade.
          # .pluck is used instead of .select to avoid CrossSchemaAccessErrors on CI tables
          # rubocop: disable Database/AvoidUsingPluckWithoutLimit -- plucking limited by placeholder batch
          if primary_key.nil?
            composite_keys = placeholder_reference_batch.pluck(:composite_key)

            model_relation = aliased_model.where(
              "#{composite_key_columns(composite_keys)} IN #{composite_key_values(composite_keys)}"
            )
          elsif primary_key.is_a?(Array)
            composite_keys = placeholder_reference_batch.pluck(:composite_key)
            key = composite_keys.first.keys
            values = composite_keys.map(&:values)
            model_relation = aliased_model.where({ key => values })
          else
            model_relation = aliased_model.primary_key_in(placeholder_reference_batch.pluck(:numeric_key))
          end
          # rubocop: enable Database/AvoidUsingPluckWithoutLimit

          model_relation = model_relation.where(aliased_user_reference_column => source_user.placeholder_user_id)

          next if model_relation.empty?

          yield([model_relation, placeholder_reference_batch])
        end
      end

      def composite_key_columns(composite_keys)
        composite_key_columns = composite_keys.first.keys
        tuple(composite_key_columns)
      end

      def composite_key_values(composite_keys)
        keys = composite_keys.map { |composite_key| tuple(composite_key.values) }
        tuple(keys)
      end

      def tuple(values)
        "(#{values.join(', ')})"
      end
    end

    private

    def validate_numeric_or_composite_key_present
      return if numeric_key.present? ^ composite_key.present?

      errors.add(:base, :blank, message: 'one of numeric_key or composite_key must be present')
    end

    # Membership data is handled in `Import::Placeholders::Membership` records instead.
    # Use `Import::PlaceholderMemberships::CreateService` to save the membership data.
    def validate_model_is_not_member
      model_class = model&.safe_constantize
      return unless model_class.present? && model_class.new.is_a?(Member)

      errors.add(:model, :invalid, message: 'cannot be a Member')
    end
  end
end
==== /workspace/gitlab/app/models/import/source_user.rb ====
# frozen_string_literal: true

module Import
  class SourceUser < ApplicationRecord
    include Gitlab::SQL::Pattern
    include EachBatch

    self.table_name = 'import_source_users'

    SORT_ORDERS = {
      source_name_asc: { order_by: 'source_name', sort: 'asc' },
      source_name_desc: { order_by: 'source_name', sort: 'desc' },
      status_asc: { order_by: 'status', sort: 'asc' },
      status_desc: { order_by: 'status', sort: 'desc' },
      id_asc: { order_by: 'id', sort: 'asc' },
      id_desc: { order_by: 'id', sort: 'desc' }
    }.freeze

    belongs_to :placeholder_user, class_name: 'User', optional: true
    belongs_to :reassign_to_user, class_name: 'User', optional: true
    belongs_to :reassigned_by_user, class_name: 'User', optional: true
    belongs_to :namespace

    validates :namespace_id, :import_type, :source_hostname, :source_user_identifier, :status, presence: true
    validates :source_user_identifier, uniqueness: { scope: [:namespace_id, :source_hostname, :import_type] }
    validates :placeholder_user_id, presence: true, unless: :completed?
    validates :reassignment_token, absence: true, unless: :awaiting_approval?
    validates :reassignment_token, length: { is: 32 }, if: :awaiting_approval?
    validates :reassign_to_user_id, presence: true, if: -> {
                                                          awaiting_approval? || reassignment_in_progress? || completed?
                                                        }
    validates :reassign_to_user_id, absence: true, if: -> { pending_reassignment? || keep_as_placeholder? }
    validates :reassign_to_user_id, uniqueness: {
      scope: [:namespace_id, :source_hostname, :import_type],
      allow_nil: true,
      message: ->(_object, _data) {
        s_('Import|already assigned to another placeholder')
      }
    }
    validate :validate_source_hostname, if: :source_hostname_changed?

    scope :for_namespace, ->(namespace_id) { where(namespace_id: namespace_id) }
    scope :by_source_hostname, ->(source_hostname) { where(source_hostname: source_hostname) }
    scope :by_import_type, ->(import_type) { where(import_type: import_type) }
    scope :for_placeholder_user, ->(user) { where(placeholder_user: user) }
    scope :by_statuses, ->(statuses) { where(status: statuses) }
    scope :awaiting_reassignment, -> { where(status: [0, 1, 2, 3, 4]) }
    scope :reassigned, -> { where(status: [5, 6]) }

    STATUSES = {
      pending_reassignment: 0,
      awaiting_approval: 1,
      reassignment_in_progress: 2,
      rejected: 3,
      failed: 4,
      completed: 5,
      keep_as_placeholder: 6
    }.freeze

    ACCEPTED_STATUSES = %i[reassignment_in_progress completed failed].freeze
    REASSIGNABLE_STATUSES = %i[pending_reassignment rejected].freeze
    CANCELABLE_STATUSES = %i[awaiting_approval rejected].freeze

    state_machine :status, initial: :pending_reassignment do
      STATUSES.each do |status_name, value|
        state status_name, value: value
      end

      before_transition awaiting_approval: any do |source_user|
        source_user.reassignment_token = nil
      end

      before_transition any => :awaiting_approval do |source_user|
        source_user.reassignment_token = SecureRandom.hex
      end

      event :reassign do
        transition REASSIGNABLE_STATUSES => :awaiting_approval
      end

      event :reassign_without_confirmation do
        transition REASSIGNABLE_STATUSES => :reassignment_in_progress, if: :bypass_placeholder_confirmation_allowed?
      end

      event :cancel_reassignment do
        transition CANCELABLE_STATUSES => :pending_reassignment
      end

      event :keep_as_placeholder do
        transition REASSIGNABLE_STATUSES => :keep_as_placeholder
      end

      event :accept do
        transition awaiting_approval: :reassignment_in_progress
      end

      event :reject do
        transition awaiting_approval: :rejected
      end

      event :complete do
        transition reassignment_in_progress: :completed
      end

      event :fail_reassignment do
        transition reassignment_in_progress: :failed
      end
    end

    class << self
      def find_source_user(source_user_identifier:, namespace:, source_hostname:, import_type:)
        return unless namespace

        find_by(
          source_user_identifier: source_user_identifier,
          namespace_id: namespace.id,
          source_hostname: source_hostname,
          import_type: import_type
        )
      end

      def search(query)
        return none unless query.is_a?(String)

        fuzzy_search(query, [:source_name, :source_username])
      end

      def sort_by_attribute(method)
        sort_order = SORT_ORDERS[method&.to_sym] || SORT_ORDERS[:source_name_asc]

        reorder(sort_order[:order_by] => sort_order[:sort])
      end

      def namespace_placeholder_user_count(namespace, limit:)
        for_namespace(namespace).distinct.limit(limit).count(:placeholder_user_id) -
          (namespace.namespace_import_user.present? ? 1 : 0)
      end

      def source_users_with_missing_information(namespace:, source_hostname:, import_type:)
        for_namespace(namespace)
          .by_source_hostname(source_hostname)
          .by_import_type(import_type)
          .and(
            where(source_name: nil).or(where(source_username: nil))
          )
      end
    end

    def mapped_user
      accepted_status? ? reassign_to_user : placeholder_user
    end

    def mapped_user_id
      accepted_status? ? reassign_to_user_id : placeholder_user_id
    end

    def accepted_status?
      STATUSES.slice(*ACCEPTED_STATUSES).value?(status)
    end

    def reassignable_status?
      STATUSES.slice(*REASSIGNABLE_STATUSES).value?(status)
    end

    def cancelable_status?
      STATUSES.slice(*CANCELABLE_STATUSES).value?(status)
    end

    def validate_source_hostname
      return unless source_hostname

      uri = Gitlab::Utils.parse_url(source_hostname)

      return if uri && uri.scheme && uri.host && uri.path.blank?

      errors.add(:source_hostname, :invalid, message: 'must contain scheme and host, and not path')
    end

    private

    def bypass_placeholder_confirmation_allowed?
      admin_bypass_placeholder_confirmation_allowed? || enterprise_bypass_placeholder_confirmation_allowed?
    end

    def admin_bypass_placeholder_confirmation_allowed?
      Import::UserMapping::AdminBypassAuthorizer.new(reassigned_by_user).allowed?
    end

    # rubocop:disable Gitlab/NoCodeCoverageComment -- method is tested in EE
    # :nocov:
    # Overridden in EE
    def enterprise_bypass_placeholder_confirmation_allowed?
      false
    end
    # :nocov:
    # rubocop:enable Gitlab/NoCodeCoverageComment
  end
end

Import::SourceUser.prepend_mod
==== /workspace/gitlab/app/models/integrations/beyond_identity.rb ====
# frozen_string_literal: true

module Integrations
  class BeyondIdentity < Integration
    validates :token, presence: true, if: :activated?

    field :token,
      type: :password,
      title: 'API token',
      help: -> {
              s_('BeyondIdentityService|API Token. User must have access to `git-commit-signing` endpoint.')
            },
      non_empty_password_title: -> { s_('ProjectService|Enter new API token') },
      non_empty_password_help: -> { s_('ProjectService|Leave blank to use your current API token.') },
      description: -> {
        s_('BeyondIdentityService|API Token. User must have access to `git-commit-signing` endpoint.')
      },
      required: true

    field :exclude_service_accounts,
      type: :checkbox,
      title: 'Exclude service accounts',
      help: -> {
        docs_link = ActionController::Base.helpers.link_to(
          _('service accounts'),
          Rails.application.routes.url_helpers.help_page_url('user/profile/service_accounts.md'),
          target: '_blank', rel: 'noopener noreferrer')

        format(s_(
          'BeyondIdentityService|If enabled, Beyond Identity will not check commits from %{docs_link}.'
        ).html_safe, docs_link: docs_link.html_safe) # rubocop:disable Rails/OutputSafety -- It is fine to call html_safe here
      },
      description: -> {
        s_('BeyondIdentityService|If enabled, Beyond Identity will not check commits from service accounts.')
      }

    def self.title
      'Beyond Identity'
    end

    def self.description
      s_('BeyondIdentity|Verify that GPG keys are authorized by Beyond Identity Authenticator.')
    end

    def self.help
      build_help_page_url(
        'user/project/integrations/beyond_identity.md',
        s_('Verify that GPG keys are authorized by Beyond Identity Authenticator.')
      )
    end

    def self.to_param
      'beyond_identity'
    end

    def self.supported_events
      %w[]
    end

    def self.activated_for_instance?
      !!::Integrations::BeyondIdentity.for_instance.first&.activated?
    end

    def self.instance_specific?
      true
    end

    def execute(params)
      ::Gitlab::BeyondIdentity::Client.new(self).execute(params)
    end
  end
end
==== /workspace/gitlab/app/models/issue_user_mention.rb ====
# frozen_string_literal: true

class IssueUserMention < UserMention
  belongs_to :issue
  belongs_to :note
end
==== /workspace/gitlab/app/models/list_user_preference.rb ====
# frozen_string_literal: true

class ListUserPreference < ApplicationRecord
  belongs_to :user
  belongs_to :list

  validates :user, presence: true
  validates :list, presence: true
  validates :user_id, uniqueness: { scope: :list_id, message: "should have only one list preference per user" }
end
==== /workspace/gitlab/app/models/merge_request/diff_commit_user.rb ====
# frozen_string_literal: true

class MergeRequest::DiffCommitUser < ApplicationRecord
  include SafelyChangeColumnDefault

  columns_changing_default :organization_id

  validates :name, length: { maximum: 512 }
  validates :email, length: { maximum: 512 }
  validates :name, presence: true, unless: :email
  validates :email, presence: true, unless: :name

  # Prepares a value to be inserted into a column in the table
  # `merge_request_diff_commit_users`. Values in this table are limited to
  # 512 characters.
  #
  # We treat empty strings as NULL values, as there's no point in (for
  # example) storing a row where both the name and Email are an empty
  # string. In addition, if we treated them differently we could end up with
  # two rows: one where field X is NULL, and one where field X is an empty
  # string. This is redundant, so we avoid storing such data.
  def self.prepare(value)
    value.present? ? value[0..511] : nil
  end

  # Creates a new row, or returns an existing one if a row already exists.
  def self.find_or_create(name, email, organization_id, with_organization: false)
    return find_or_create_by!(name: name, email: email) unless with_organization

    # Try to find exact match first
    result = find_by(name: name, email: email, organization_id: organization_id)

    # If not found, look for one with nil organization_id
    if !result && organization_id.present?
      result = find_by(name: name, email: email, organization_id: nil)
      result.update!(organization_id: organization_id) if result
    end

    # If still not found, try to create using find_or_create_by!
    result || find_or_create_by!(name: name, email: email, organization_id: organization_id)
  rescue ActiveRecord::RecordNotUnique
    retry
  end

  # Finds many (name, email) pairs or (name, email, organization_id) triples in bulk.
  def self.bulk_find(input, with_organization: false)
    queries = {}
    rows = []

    input.each do |item|
      if with_organization
        name, email, organization_id = item
        conditions = { name: name, email: email, organization_id: organization_id }
      else
        name, email = item
        conditions = { name: name, email: email }
      end

      queries[conditions.values] = where(conditions).to_sql
    end

    # We may end up having to query many users. To ensure we don't hit any
    # query size limits, we get a fixed number of users at a time.
    queries.values.each_slice(1_000).map do |slice|
      rows.concat(from("(#{slice.join("\nUNION ALL\n")}) #{table_name}").to_a)
    end

    rows
  end

  # Finds or creates rows for the given pairs of names and Emails or
  # triples of names, emails, and organization IDs.
  #
  # The input argument must be an Array/Set of pairs or triples like so:
  #
  #     [
  #       [name, email],                   # legacy format when with_organization: false
  #       [name, email, organization_id],  # new format when with_organization: true
  #       ...
  #     ]
  #
  # This method expects that the names and emails have already been trimmed to
  # at most 512 characters.
  #
  # The return value is a Hash that maps these pairs/triples to instances of this model.
  def self.bulk_find_or_create(input, with_organization: false)
    return bulk_find_or_create_legacy(input) unless with_organization

    mapping = {}
    ids_to_update = []

    # Extract organization_id - it's the same for all triples in this batch
    organization_id = input.first&.last

    # Find all existing records by (name, email) only
    existing_records = bulk_find(input, with_organization: false)

    existing_records.each do |row|
      ids_to_update << row.id if row.organization_id.nil?
      # Map all found records with the organization_id from input
      mapping[[row.name, row.email, organization_id]] = row
    end

    # Bulk update organization_ids for records that had nil
    if ids_to_update.any?
      where(id: ids_to_update).update_all(organization_id: organization_id)

      # Update the organization_id on the objects we already have
      existing_records.each do |row|
        row.organization_id = organization_id if ids_to_update.include?(row.id)
      end
    end

    # Create missing records
    create_missing_records(input, mapping)

    # Handle concurrent inserts
    handle_concurrent_inserts(input, mapping)

    mapping
  end

  def self.create_missing_records(input, mapping)
    create = []

    # Collect records that need to be created
    input.each do |(name, email, org_id)|
      next if mapping[[name, email, org_id]]

      create << { name: name, email: email, organization_id: org_id }
    end

    return if create.empty?

    # Bulk insert new records
    insert_all(create, returning: %w[id name email organization_id]).each do |row|
      mapping[[row['name'], row['email'], row['organization_id']]] =
        new(id: row['id'], name: row['name'], email: row['email'], organization_id: row['organization_id'])
    end
  end

  def self.handle_concurrent_inserts(input, mapping)
    # Find any records that were created concurrently
    missing_triples = input.reject { |(name, email, org_id)| mapping.key?([name, email, org_id]) }

    return if missing_triples.empty?

    bulk_find(missing_triples, with_organization: true).each do |row|
      mapping[[row.name, row.email, row.organization_id]] = row
    end
  end

  def self.bulk_find_or_create_legacy(input)
    mapping = {}
    create = []

    # Over time, fewer new rows need to be created. We take advantage of that
    # here by first finding all rows that already exist, using a limited number
    # of queries (in most cases only one query will be needed).
    bulk_find(input).each do |row|
      mapping[[row.name, row.email]] = row
    end

    input.each do |(name, email)|
      create << { name: name, email: email } unless mapping[[name, email]]
    end

    return mapping if create.empty?

    # Sometimes we may need to insert new users into the table. We do this in
    # bulk, so we only need one INSERT for all missing users.
    insert_all(create, returning: %w[id name email]).each do |row|
      mapping[[row['name'], row['email']]] =
        new(id: row['id'], name: row['name'], email: row['email'])
    end

    # It's possible for (name, email) pairs to be inserted concurrently,
    # resulting in the above insert not returning anything. Here we get any
    # remaining users that were created concurrently.
    bulk_find(input.reject { |pair| mapping.key?(pair) }).each do |row|
      mapping[[row.name, row.email]] = row
    end

    mapping
  end

  private_class_method :bulk_find_or_create_legacy,
    :create_missing_records,
    :handle_concurrent_inserts
end
==== /workspace/gitlab/app/models/merge_request_user_mention.rb ====
# frozen_string_literal: true

class MergeRequestUserMention < UserMention
  belongs_to :merge_request
  belongs_to :note
end
==== /workspace/gitlab/app/models/namespaces/user_namespace.rb ====
# frozen_string_literal: true

module Namespaces
  ####################################################################
  # PLEASE DO NOT OVERRIDE METHODS IN THIS CLASS!
  #
  # This class is a placeholder for STI. But we also want to ensure
  # tests using `:namespace` factory are still testing the same functionality.
  #
  # Many legacy tests use `:namespace` which has a slight semantic
  # mismatch as it always has been a User (personal) namespace.
  #
  # If you need to make a change here, please ping the
  # Tenant Scale group so we can ensure that the
  # changes do not break existing functionality.
  #
  # As Namespaces evolve we may be able to relax this restriction
  # but for now, please check in with us <3
  #
  # For details, see the discussion in
  # https://gitlab.com/gitlab-org/gitlab/-/merge_requests/74152
  ####################################################################

  class UserNamespace < Namespace
    self.allow_legacy_sti_class = true

    def self.sti_name
      'User'
    end

    def owners
      Array.wrap(owner)
    end

    def member?(user, min_access_level = Gitlab::Access::GUEST)
      return false unless user

      max_member_access_for_user(user) >= min_access_level
    end

    # Return the highest access level for a user
    #
    # A special case is handled here when the user is a GitLab admin
    # which implies it has "OWNER" access everywhere, but should not
    # officially appear as a member unless specifically added to it
    #
    # @param user [User]
    # @param only_concrete_membership [Bool] whether require admin concrete membership status
    def max_member_access_for_user(user, only_concrete_membership: false)
      return Gitlab::Access::NO_ACCESS unless user

      if !only_concrete_membership && (user.can_admin_all_resources? || user.can_admin_organization?(organization))
        return Gitlab::Access::OWNER
      end

      owner == user ? Gitlab::Access::OWNER : Gitlab::Access::NO_ACCESS
    end

    def crm_group
      nil
    end
  end
end
==== /workspace/gitlab/app/models/operations/feature_flags/strategy_user_list.rb ====
# frozen_string_literal: true

module Operations
  module FeatureFlags
    class StrategyUserList < ApplicationRecord
      self.table_name = 'operations_strategies_user_lists'

      belongs_to :strategy
      belongs_to :user_list
    end
  end
end
==== /workspace/gitlab/app/models/operations/feature_flags/user_list.rb ====
# frozen_string_literal: true

module Operations
  module FeatureFlags
    class UserList < ApplicationRecord
      include AtomicInternalId
      include IidRoutes
      include ::Gitlab::SQL::Pattern

      self.table_name = 'operations_user_lists'

      belongs_to :project
      has_many :strategy_user_lists
      has_many :strategies, through: :strategy_user_lists

      has_internal_id :iid, scope: :project, presence: true

      validates :project, presence: true
      validates :name,
        presence: true,
        uniqueness: { scope: :project_id },
        length: 1..255
      validates :user_xids, feature_flag_user_xids: true

      before_destroy :ensure_no_associated_strategies

      scope :for_name_like, ->(query) do
        fuzzy_search(query, [:name], use_minimum_char_limit: false)
      end

      def self.belongs_to?(project_id, user_list_ids)
        uniq_ids = user_list_ids.uniq
        where(id: uniq_ids, project_id: project_id).count == uniq_ids.count
      end

      private

      def ensure_no_associated_strategies
        if strategies.present?
          errors.add(:base, 'User list is associated with a strategy')
          throw :abort # rubocop: disable Cop/BanCatchThrow
        end
      end
    end
  end
end
==== /workspace/gitlab/app/models/organizations/organization_user_detail.rb ====
# frozen_string_literal: true

module Organizations
  class OrganizationUserDetail < ApplicationRecord
    include Referable

    belongs_to :organization, inverse_of: :organization_user_details, optional: false
    belongs_to :user, inverse_of: :organization_user_details, optional: false

    validates :username, presence: true, uniqueness: { scope: :organization_id }
    validates :display_name, presence: true

    validate :no_namespace_conflicts

    scope :for_references, -> { includes(:organization, :user) }
    scope :for_organization, ->(organization) { where(organization: organization) }
    scope :with_usernames, ->(*usernames) {
      uniq_usernames = usernames.flatten.compact.uniq
      return none if uniq_usernames.blank?

      downcase_usernames = uniq_usernames.map(&:downcase)

      where("LOWER(username) IN (?)", downcase_usernames)
    }

    # Referable methods should be the same as User
    def reference_prefix
      '@'
    end

    def reference_pattern
      @reference_pattern ||=
        %r{
          (?<!\w)
          #{Regexp.escape(reference_prefix)}
          (?<user>#{Gitlab::PathRegex::FULL_NAMESPACE_FORMAT_REGEX})
        }x
    end

    def to_reference(*)
      "#{reference_prefix}#{username}"
    end

    def no_namespace_conflicts
      return if username.blank?

      return unless Namespace.username_reserved_for_organization?(
        username,
        organization,
        excluding: user.namespace
      )

      errors.add(:username, _('has already been taken'))
    end
  end
end
==== /workspace/gitlab/app/models/organizations/organization_user.rb ====
# frozen_string_literal: true

module Organizations
  class OrganizationUser < ApplicationRecord
    include ActiveModel::Dirty

    belongs_to :organization, inverse_of: :organization_users, optional: false
    belongs_to :user, inverse_of: :organization_users, optional: false

    validates :user, uniqueness: { scope: :organization_id }
    validates :access_level, presence: true

    validate :last_owner_access_level_change, if: :access_level_changed?

    before_destroy :ensure_user_has_an_organization

    enum :access_level, {
      # Until we develop more access_levels, we really don't know if the default access_level will be what we think of
      # as a guest. For now, we'll set to same value as guest, but call it default to denote the current ambivalence.
      default: Gitlab::Access::GUEST,
      owner: Gitlab::Access::OWNER
    }

    scope :owners, -> { where(access_level: Gitlab::Access::OWNER) }
    scope :in_organization, ->(organization) { where(organization: organization) }
    scope :with_active_users, -> { joins(:user).merge(User.active) }
    scope :by_user, ->(user) { where(user: user) }

    def self.update_default_organization_record_for(user_id, user_is_admin:)
      find_or_initialize_by(
        user_id: user_id, organization_id: Organizations::Organization::DEFAULT_ORGANIZATION_ID
      ).tap do |record|
        record.access_level = default_organization_access_level(user_is_admin: user_is_admin)
        record.save!
      end
    # Remove this exception after we remove the dependency on default organization
    # https://gitlab.com/gitlab-org/gitlab/-/issues/446293
    rescue ActiveRecord::RecordInvalid => e
      return if e.record.errors.any? { |error| error.attribute.in?(%i[organization user]) && error.type == :blank }

      raise e
    end

    def self.default_organization_access_level(user_is_admin: false)
      if user_is_admin
        :owner
      else
        :default
      end
    end

    def self.create_organization_record_for(user_id, organization_id)
      # we try to find a record if it exists.
      find_by(user_id: user_id, organization_id: organization_id) ||

        # If not, we try to create it with `upsert`.
        # We use upsert for these reasons:
        #    - No subtransactions
        #    - Due to the use of `on_duplicate: :skip`, we are essentially issuing a `ON CONFLICT DO NOTHING`.
        #       - Postgres will take care of skipping the record without errors if a similar record was created
        #         by then in another thread.
        #       - There is no explicit error being thrown because we said "ON CONFLICT DO NOTHING".
        #         With this we avoid both the problems with subtransactions that could arise when we upgrade Rails,
        #         see https://gitlab.com/gitlab-org/gitlab/-/issues/439567, and also with race conditions.

        upsert(
          { organization_id: organization_id, user_id: user_id, access_level: :default },
          unique_by: [:organization_id, :user_id],
          on_duplicate: :skip # Do not change access_level, could make :owner :default
        )
    end

    def last_owner?
      return false unless owner?

      # Try to keep the last active user as owner
      return other_owners.with_active_users.empty? if user.active?

      other_owners.empty?
    end

    private

    def other_owners
      @other_owners ||= organization.organization_users.owners.id_not_in(id)
    end

    def ensure_user_has_an_organization
      return unless user

      return unless user.organization_users.id_not_in(id).empty?

      errors.add(:base, _('A user must associate with at least one organization'))
    end

    def last_owner_access_level_change
      return unless access_level_was == 'owner' && other_owners.empty?

      errors.add(:base, _('You cannot change the access of the last owner from the organization'))
    end
  end
end
==== /workspace/gitlab/app/models/personal_access_token.rb ====
# frozen_string_literal: true

class PersonalAccessToken < ApplicationRecord
  include Expirable
  include TokenAuthenticatable
  include Sortable
  include EachBatch
  include CreatedAtFilterable
  include Gitlab::SQL::Pattern
  include SafelyChangeColumnDefault

  extend ::Gitlab::Utils::Override

  NOTIFICATION_INTERVALS = {
    seven_days: 0..7,
    thirty_days: 8..30,
    sixty_days: 31..60
  }.freeze

  add_authentication_token_field :token,
    digest: true,
    format_with_prefix: :prefix_from_application_current_settings,
    routable_token: {
      payload: {
        o: ->(token_owner_record) { token_owner_record.organization_id },
        u: ->(token_owner_record) { token_owner_record.user_id }
      }
    }

  columns_changing_default :organization_id

  attribute :organization_id, default: -> { Organizations::Organization::DEFAULT_ORGANIZATION_ID }

  MAX_PERSONAL_ACCESS_TOKEN_LIFETIME_IN_DAYS_BUFFERED = 400
  MAX_PERSONAL_ACCESS_TOKEN_LIFETIME_IN_DAYS = 365

  serialize :scopes, type: Array # rubocop:disable Cop/ActiveRecordSerialize

  enum :user_type, HasUserType::USER_TYPES

  belongs_to :user
  belongs_to :group
  belongs_to :organization, class_name: 'Organizations::Organization'
  belongs_to :previous_personal_access_token, class_name: 'PersonalAccessToken'

  has_many :last_used_ips, class_name: 'Authn::PersonalAccessTokenLastUsedIp'

  after_initialize :set_default_scopes, if: :persisted?
  before_save :ensure_token

  scope :active, -> { not_revoked.not_expired }
  # this scope must use a string condition, otherwise Postgres will not use the correct indices
  scope :expiring_and_not_notified, ->(date) { where(["revoked = false AND expire_notification_delivered = false AND seven_days_notification_sent_at IS NULL AND expires_at >= CURRENT_DATE AND expires_at <= ?", date]) }
  scope :expired_today_and_not_notified, -> { where(["revoked = false AND expires_at = CURRENT_DATE AND after_expiry_notification_delivered = false"]) }
  scope :expired_after, ->(date) { expired.where(arel_table[:expires_at].gteq(date)) }
  scope :expires_before, ->(date) { where(arel_table[:expires_at].lt(date)) }
  scope :expires_after, ->(date) { where(arel_table[:expires_at].gteq(date)) }
  scope :inactive, -> { where("revoked = true OR expires_at < CURRENT_DATE") }
  scope :last_used_before_or_unused, ->(date) { where("personal_access_tokens.created_at < :date AND (last_used_at < :date OR last_used_at IS NULL)", date: date) }
  scope :with_impersonation, -> { where(impersonation: true) }
  scope :without_impersonation, -> { where(impersonation: false) }
  scope :revoked, -> { where(revoked: true) }
  scope :revoked_after, ->(date) { revoked.where(arel_table[:updated_at].gteq(date)) }
  scope :not_revoked, -> { where(revoked: [false, nil]) }
  scope :for_user, ->(user) { where(user: user) }
  scope :for_users, ->(users) { where(user: users) }
  scope :for_organization, ->(organization) { where(organization_id: organization) }
  scope :preload_users, -> { preload(:user) }
  scope :order_expires_at_asc_id_desc, -> { reorder(expires_at: :asc, id: :desc) }
  scope :order_expires_at_desc_id_desc, -> { reorder(expires_at: :desc, id: :desc) }
  scope :order_last_used_at_asc_id_desc, -> { reorder(last_used_at: :asc, id: :desc) }
  scope :order_last_used_at_desc_id_desc, -> { reorder(last_used_at: :desc, id: :desc) }
  scope :project_access_token, -> { includes(:user).references(:user).merge(User.project_bot) }
  scope :owner_is_human, -> { includes(:user).references(:user).merge(User.human) }
  scope :last_used_before, ->(date) { where("last_used_at <= ?", date) }
  scope :last_used_after, ->(date) { where("last_used_at >= ?", date) }
  scope :expiring_and_not_notified_without_impersonation, -> {
    expiring_and_not_notified(DAYS_TO_EXPIRE.days.from_now.to_date).without_impersonation
  }
  scope :with_token_digests, ->(digests) { where(token_digest: digests) }

  validates :name, :scopes, presence: true
  validates :expires_at, presence: true, on: :create, unless: :allow_expires_at_to_be_empty?

  validate :validate_scopes
  validate :expires_at_before_instance_max_expiry_date, on: :create

  def revoke!
    if persisted?
      update_columns(revoked: true, updated_at: Time.zone.now)
    else
      self.revoked = true
    end
  end

  def active?
    !revoked? && !expired?
  end

  override :simple_sorts
  def self.simple_sorts
    super.merge(
      {
        'expires_asc' => -> { order_expires_at_asc_id_desc },
        'expires_at_asc_id_desc' => -> { order_expires_at_asc_id_desc }, # Keep for backward compatibility
        'expires_desc' => -> { order_expires_at_desc_id_desc },
        'last_used_asc' => -> { order_last_used_at_asc_id_desc },
        'last_used_desc' => -> { order_last_used_at_desc_id_desc }
      }
    )
  end

  def self.token_prefix
    Gitlab::CurrentSettings.current_application_settings.personal_access_token_prefix
  end

  def self.search(query)
    fuzzy_search(query, [:name])
  end

  def self.notification_interval(interval)
    NOTIFICATION_INTERVALS.fetch(interval).max
  end

  def self.scope_for_notification_interval(interval, min_expires_at: nil, max_expires_at: nil)
    interval_range = NOTIFICATION_INTERVALS.fetch(interval).minmax
    min_expiry_date, max_expiry_date = interval_range.map { |range| Date.current + range }
    min_expiry_date = min_expires_at if min_expires_at
    max_expiry_date = max_expires_at if max_expires_at
    interval_attr = "#{interval}_notification_sent_at"

    sql_string = <<~SQL
      revoked = FALSE
      AND #{interval_attr} IS NULL
      AND expire_notification_delivered = FALSE
      AND expires_at BETWEEN ? AND ?
    SQL

    # this scope must use a string condition rather than activerecord syntax,
    # otherwise Postgres will not use the correct indices
    where(sql_string, min_expiry_date, max_expiry_date).without_impersonation
  end

  def self.max_expiration_lifetime_in_days
    if ::Feature.enabled?(:buffered_token_expiration_limit) # rubocop:disable Gitlab/FeatureFlagWithoutActor -- Group setting but checked at user
      MAX_PERSONAL_ACCESS_TOKEN_LIFETIME_IN_DAYS_BUFFERED
    else
      MAX_PERSONAL_ACCESS_TOKEN_LIFETIME_IN_DAYS
    end
  end

  def hook_attrs
    Gitlab::HookData::ResourceAccessTokenBuilder.new(self).build
  end

  protected

  def validate_scopes
    unless revoked || scopes.all? { |scope| Gitlab::Auth.all_available_scopes.include?(scope.to_sym) }
      errors.add :scopes, "can only contain available scopes"
    end
  end

  def set_default_scopes
    # When only loading a select set of attributes, for example using `EachBatch`,
    # the `scopes` attribute is not present, so we can't initialize it.
    return unless has_attribute?(:scopes)

    self.scopes = Gitlab::Auth::DEFAULT_SCOPES if self.scopes.empty?
  end

  def user_admin?
    user.admin? # rubocop: disable Cop/UserAdmin
  end

  def prefix_from_application_current_settings
    self.class.token_prefix
  end

  def allow_expires_at_to_be_empty?
    !Gitlab::CurrentSettings.require_personal_access_token_expiry?
  end

  def max_expiration_lifetime_in_days
    self.class.max_expiration_lifetime_in_days
  end

  def expires_at_before_instance_max_expiry_date
    return unless expires_at

    return unless Gitlab::CurrentSettings.require_personal_access_token_expiry?

    max_expiry_date = Date.current.advance(days: max_expiration_lifetime_in_days)
    return unless expires_at > max_expiry_date

    errors.add(
      :expires_at,
      format(_("must be before %{expiry_date}"), expiry_date: max_expiry_date)
    )
  end
end

PersonalAccessToken.prepend_mod_with('PersonalAccessToken')
==== /workspace/gitlab/app/models/preloaders/user_max_access_level_in_groups_preloader.rb ====
# frozen_string_literal: true

module Preloaders
  # This class preloads the max access level (role) for the user within the given groups and
  # stores the values in requests store.
  class UserMaxAccessLevelInGroupsPreloader
    def initialize(groups, user)
      @groups = groups
      @user = user
    end

    def execute
      return unless @user

      preload_with_traversal_ids
    end

    private

    def preload_with_traversal_ids
      # Diagrammatic representation of this step:
      # https://gitlab.com/gitlab-org/gitlab/-/merge_requests/111157#note_1271550140
      max_access_levels = GroupMember.from_union(all_memberships)
                            .joins("INNER JOIN (#{traversal_join_sql}) as hierarchy ON members.source_id = hierarchy.traversal_id")
                            .group('hierarchy.id')
                            .maximum(:access_level)

      @groups.each do |group|
        max_access_level = max_access_levels[group.id] || Gitlab::Access::NO_ACCESS
        group.merge_value_to_request_store(User, @user.id, max_access_level)
      end
    end

    def all_memberships
      [
        direct_memberships.select(*GroupMember.cached_column_list),
        memberships_from_group_shares
      ]
    end

    def direct_memberships
      GroupMember.active_without_invites_and_requests.where(user: @user)
    end

    def memberships_from_group_shares
      alter_direct_memberships_to_make_it_act_like_memberships_in_shared_groups
    end

    def alter_direct_memberships_to_make_it_act_like_memberships_in_shared_groups
      group_group_link_table = GroupGroupLink.arel_table
      group_member_table = GroupMember.arel_table

      altered_columns = GroupMember.column_names.map do |column_name|
        case column_name
        when 'access_level'
          # Consider the limiting effect of group share's access level
          smallest_value_arel([group_group_link_table[:group_access], group_member_table[:access_level]], 'access_level')
        when 'source_id'
          # Alter the `source_id` of the `Member` record that is currently pointing to the `shared_with_group`
          # such that this record would now behave like a `Member` record of this user pointing to the `shared_group` group.
          Arel::Nodes::As.new(group_group_link_table[:shared_group_id], Arel::Nodes::SqlLiteral.new('source_id'))
        else
          group_member_table[column_name]
        end
      end

      direct_memberships_in_groups_that_have_been_shared_with_other_groups.select(*altered_columns)
    end

    def direct_memberships_in_groups_that_have_been_shared_with_other_groups
      direct_memberships.joins(
        "INNER JOIN group_group_links ON members.source_id = group_group_links.shared_with_group_id"
      )
    end

    def smallest_value_arel(args, column_alias)
      Arel::Nodes::As.new(
        Arel::Nodes::NamedFunction.new('LEAST', args),
        Arel::Nodes::SqlLiteral.new(column_alias))
    end

    def traversal_join_sql
      Namespace.select('id, unnest(traversal_ids) as traversal_id').where(id: @groups.map(&:id)).to_sql
    end
  end
end
==== /workspace/gitlab/app/models/preloaders/user_max_access_level_in_projects_preloader.rb ====
# frozen_string_literal: true

module Preloaders
  # This class preloads the max access level (role) for the user within the given projects and
  # stores the values in requests store via the ProjectTeam class.
  class UserMaxAccessLevelInProjectsPreloader
    def initialize(projects, user)
      @projects = if projects.is_a?(Array)
                    Project.id_in(projects)
                  else
                    # Push projects base query in to a sub-select to avoid
                    # table name clashes. Performs better than aliasing.
                    Project.id_in(projects.subquery(:id))
                  end

      @user = user
    end

    def execute
      return unless @user

      project_authorizations = ProjectAuthorization.arel_table

      auths = @projects
                .select(
                  Project.default_select_columns,
                  project_authorizations[:user_id],
                  project_authorizations[:access_level]
                )
                .joins(project_auth_join)

      auths.each do |project|
        access_level = project.access_level || Gitlab::Access::NO_ACCESS
        ProjectTeam.new(project).write_member_access_for_user_id(@user.id, access_level)
      end
    end

    private

    def project_auth_join
      project_authorizations = ProjectAuthorization.arel_table
      projects = Project.arel_table

      projects
        .join(
          project_authorizations.as(project_authorizations.name),
          Arel::Nodes::OuterJoin
        )
        .on(
          project_authorizations[:project_id].eq(projects[:id])
          .and(project_authorizations[:user_id].eq(@user.id))
        )
        .join_sources
    end
  end
end
==== /workspace/gitlab/app/models/preloaders/users_max_access_level_by_project_preloader.rb ====
# frozen_string_literal: true

module Preloaders
  # This class preloads the max access level (role) for the users within the given projects and
  # stores the values in requests store via the ProjectTeam class.
  class UsersMaxAccessLevelByProjectPreloader
    include Gitlab::Utils::StrongMemoize

    def initialize(project_users:)
      @project_users = project_users.transform_values { |users| Array.wrap(users) }
    end

    def execute
      return unless @project_users.present?

      all_users = @project_users.values.flatten.uniq
      preload_users_namespace_bans(all_users)

      @project_users.each do |project, users|
        users.each do |user|
          access_level = access_levels.fetch([project.id, user.id], Gitlab::Access::NO_ACCESS)
          project.team.write_member_access_for_user_id(user.id, access_level)
        end
      end
    end

    private

    def access_levels
      query = ProjectAuthorization.none

      @project_users.each do |project, users|
        query = query.or(
          ProjectAuthorization
            .where(project_id: project.id, user_id: users.map(&:id))
        )
      end

      query
        .group(:project_id, :user_id)
        .maximum(:access_level)
    end
    strong_memoize_attr :access_levels

    def preload_users_namespace_bans(_users)
      # overridden in EE
    end
  end
end

Preloaders::UsersMaxAccessLevelByProjectPreloader.prepend_mod
==== /workspace/gitlab/app/models/snippet_user_mention.rb ====
# frozen_string_literal: true

class SnippetUserMention < UserMention
  belongs_to :snippet
  belongs_to :note
end
==== /workspace/gitlab/app/models/user_agent_detail.rb ====
# frozen_string_literal: true

class UserAgentDetail < ApplicationRecord
  belongs_to :subject, polymorphic: true # rubocop:disable Cop/PolymorphicAssociations

  validates :user_agent, :ip_address, :subject_id, :subject_type, presence: true

  def submittable?
    !submitted?
  end
end
==== /workspace/gitlab/app/models/user_custom_attribute.rb ====
# frozen_string_literal: true

class UserCustomAttribute < ApplicationRecord
  belongs_to :user

  validates :user_id, :key, :value, presence: true
  validates :key, uniqueness: { scope: [:user_id] }

  scope :by_key, ->(key) { where(key: key) }
  scope :by_user_id, ->(user_id) { where(user_id: user_id) }
  scope :by_updated_at, ->(updated_at) { where(updated_at: updated_at) }
  scope :arkose_sessions, -> { by_key(ARKOSE_SESSION) }
  scope :trusted_with_spam, -> { by_key(TRUSTED_BY) }

  BLOCKED_BY = 'blocked_by'
  UNBLOCKED_BY = 'unblocked_by'
  ARKOSE_RISK_BAND = 'arkose_risk_band'
  ARKOSE_SESSION = 'arkose_session'
  AUTO_BANNED_BY_ABUSE_REPORT_ID = 'auto_banned_by_abuse_report_id'
  AUTO_BANNED_BY_SPAM_LOG_ID = 'auto_banned_by_spam_log_id'
  TRUSTED_BY = 'trusted_by'
  AUTO_BANNED_BY = 'auto_banned_by'
  IDENTITY_VERIFICATION_PHONE_EXEMPT = 'identity_verification_phone_exempt'
  IDENTITY_VERIFICATION_EXEMPT = 'identity_verification_exempt'
  DELETED_OWN_ACCOUNT_AT = 'deleted_own_account_at'
  SKIPPED_ACCOUNT_DELETION_AT = 'skipped_account_deletion_at'
  DEEP_CLEAN_CI_USAGE_WHEN_BANNED = 'deep_clean_ci_usage_when_banned'

  class << self
    def upsert_custom_attributes(custom_attributes)
      created_at = DateTime.now
      updated_at = DateTime.now

      custom_attributes.map! do |custom_attribute|
        custom_attribute.merge({ created_at: created_at, updated_at: updated_at })
      end
      upsert_all(custom_attributes, unique_by: [:user_id, :key])
    end

    def sessions
      return none if blocked_users.empty?

      arkose_sessions
        .by_user_id(blocked_users.map(&:user_id))
        .select(:value)
    end

    def set_banned_by_abuse_report(abuse_report)
      return unless abuse_report

      upsert_custom_attribute(
        user_id: abuse_report.user.id,
        key: AUTO_BANNED_BY_ABUSE_REPORT_ID,
        value: abuse_report.id
      )
    end

    def set_banned_by_spam_log(spam_log)
      return unless spam_log

      upsert_custom_attribute(user_id: spam_log.user_id, key: AUTO_BANNED_BY_SPAM_LOG_ID, value: spam_log.id)
    end

    def set_auto_banned_by(user:, reason:)
      upsert_custom_attribute(user_id: user.id, key: AUTO_BANNED_BY, value: reason)
    end

    def set_trusted_by(user:, trusted_by:)
      return unless user && trusted_by

      upsert_custom_attribute(
        user_id: user.id,
        key: UserCustomAttribute::TRUSTED_BY,
        value: "#{trusted_by.username}/#{trusted_by.id}+#{Time.current}"
      )
    end

    def set_deleted_own_account_at(user)
      return unless user

      upsert_custom_attribute(user_id: user.id, key: DELETED_OWN_ACCOUNT_AT, value: Time.zone.now.to_s)
    end

    def set_skipped_account_deletion_at(user)
      return unless user

      upsert_custom_attribute(user_id: user.id, key: SKIPPED_ACCOUNT_DELETION_AT, value: Time.zone.now.to_s)
    end

    def upsert_custom_attribute(user_id:, key:, value:)
      return unless user_id && key && value

      custom_attribute = {
        user_id: user_id,
        key: key,
        value: value
      }

      upsert_custom_attributes([custom_attribute])
    end

    private

    def blocked_users
      by_key('blocked_at').by_updated_at(Date.yesterday.all_day)
    end
  end
end
==== /workspace/gitlab/app/models/user_detail.rb ====
# frozen_string_literal: true

class UserDetail < ApplicationRecord
  extend ::Gitlab::Utils::Override

  belongs_to :user
  belongs_to :bot_namespace, class_name: 'Namespace', optional: true, inverse_of: :bot_user_details

  validates :pronouns, length: { maximum: 50 }
  validates :pronunciation, length: { maximum: 255 }
  validates :job_title, length: { maximum: 200 }
  validates :bio, length: { maximum: 255 }, allow_blank: true

  validates :email_otp, length: { is: 64 }, allow_nil: true
  validates :email_otp_last_sent_to, length: { maximum: 511 }, allow_nil: true

  validate :bot_namespace_user_type, if: :bot_namespace_id_changed?

  ignore_column :registration_objective, remove_after: '2025-08-22', remove_with: '18.4'
  ignore_column :skype, remove_after: '2025-09-18', remove_with: '18.4'

  DEFAULT_FIELD_LENGTH = 500

  # specification for bluesky identifier https://web.plc.directory/spec/v0.1/did-plc
  BLUESKY_VALIDATION_REGEX = /
    \A            # beginning of string
    did:plc:      # beginning of bluesky id
    [a-z0-9]{24}  # 24 characters of word or digit
    \z            # end of string
  /x

  MASTODON_VALIDATION_REGEX = /
    \A            # beginning of string
    @?\b          # optional leading at
    ([\w\d.%+-]+) # character group to pick up words in user portion of username
    @             # separator between user and host
    (             # beginning of character group for host portion
      [\w\d.-]+   # character group to pick up words in host portion of username
      \.\w{2,}    # pick up tld of host domain, 2 chars or more
    )\b           # end of character group to pick up words in host portion of username
    \z            # end of string
  /x

  ORCID_VALIDATION_REGEX = /
    \A            # beginning of string
    (             #
      [0-9]{4}-   # 4 digits spaced by dash
    ){3}          # 3 times
    (             #
    [0-9]{3}      # end with 3 digits
    )             #
    [0-9X]        # followed by a fourth digit or an X
    \z            # end of string
  /x

  validates :discord, length: { maximum: DEFAULT_FIELD_LENGTH }, allow_blank: true
  validate :discord_format
  validates :linkedin, length: { maximum: DEFAULT_FIELD_LENGTH }, allow_blank: true
  validates :location, length: { maximum: DEFAULT_FIELD_LENGTH }, allow_blank: true
  validates :bluesky,
    allow_blank: true,
    format: { with: UserDetail::BLUESKY_VALIDATION_REGEX,
              message: proc { s_('Profiles|must contain only a bluesky did:plc identifier.') } }
  validates :mastodon, length: { maximum: DEFAULT_FIELD_LENGTH }, allow_blank: true
  validate :mastodon_format
  validates :orcid, length: { maximum: DEFAULT_FIELD_LENGTH }, allow_blank: true
  validate :orcid_format
  validates :organization, length: { maximum: DEFAULT_FIELD_LENGTH }, allow_blank: true
  validates :twitter, length: { maximum: DEFAULT_FIELD_LENGTH }, allow_blank: true
  validates :website_url, length: { maximum: DEFAULT_FIELD_LENGTH }, url: true, allow_blank: true, if: :website_url_changed?
  validates :onboarding_status, json_schema: { filename: 'user_detail_onboarding_status' }
  validates :github, length: { maximum: DEFAULT_FIELD_LENGTH }, allow_blank: true

  before_validation :sanitize_attrs
  before_save :prevent_nil_fields

  def sanitize_attrs
    %i[bluesky discord linkedin mastodon orcid twitter website_url github].each do |attr|
      value = self[attr]
      self[attr] = Sanitize.clean(value) if value.present?
    end
    %i[location organization].each do |attr|
      value = self[attr]
      self[attr] = Sanitize.clean(value).gsub('&amp;', '&') if value.present?
    end
  end

  # Exclude the hashed email_otp attribute
  def serializable_hash(options = nil)
    options = options.try(:dup) || {}
    options[:except] = Array(options[:except]).dup
    options[:except].concat [:email_otp]

    super
  end

  private

  def prevent_nil_fields
    self.bluesky = '' if bluesky.nil?
    self.bio = '' if bio.nil?
    self.discord = '' if discord.nil?
    self.linkedin = '' if linkedin.nil?
    self.location = '' if location.nil?
    self.mastodon = '' if mastodon.nil?
    self.organization = '' if organization.nil?
    self.orcid = '' if orcid.nil?
    self.twitter = '' if twitter.nil?
    self.website_url = '' if website_url.nil?
    self.github = '' if github.nil?
  end

  def bot_namespace_user_type
    return if user.bot?
    return if bot_namespace_id.nil?

    errors.add(:bot_namespace, _('must only be set for bot user types'))
  end
end

def discord_format
  return if discord.blank? || discord =~ %r{\A\d{17,20}\z}

  errors.add(:discord, _('must contain only a discord user ID.'))
end

def mastodon_format
  return if mastodon.blank? || mastodon =~ UserDetail::MASTODON_VALIDATION_REGEX

  errors.add(:mastodon, _('must contain only a mastodon handle.'))
end

def orcid_format
  return if orcid.blank? || orcid =~ UserDetail::ORCID_VALIDATION_REGEX

  errors.add(:orcid, _('must contain only a valid ORCID.'))
end

UserDetail.prepend_mod_with('UserDetail')
==== /workspace/gitlab/app/models/user_highest_role.rb ====
# frozen_string_literal: true

class UserHighestRole < ApplicationRecord
  belongs_to :user, optional: false

  validates :highest_access_level, allow_nil: true, inclusion: { in: ->(_) { self.allowed_values } }

  scope :with_highest_access_level, ->(highest_access_level) { where(highest_access_level: highest_access_level) }

  def self.allowed_values
    Gitlab::Access.all_values
  end
end

UserHighestRole.prepend_mod
==== /workspace/gitlab/app/models/user_mention.rb ====
# frozen_string_literal: true

class UserMention < ApplicationRecord
  self.abstract_class = true

  include UserMentionBehaviour
end
==== /workspace/gitlab/app/models/user_preference.rb ====
# frozen_string_literal: true

class UserPreference < ApplicationRecord
  include SafelyChangeColumnDefault
  include IgnorableColumns

  ignore_columns(:home_organization_id, remove_with: '18.5', remove_after: '2025-09-20')

  # We could use enums, but Rails 4 doesn't support multiple
  # enum options with same name for multiple fields, also it creates
  # extra methods that aren't really needed here.
  NOTES_FILTERS = { all_notes: 0, only_comments: 1, only_activity: 2 }.freeze
  TIME_DISPLAY_FORMATS = { system: 0, non_iso_format: 1, iso_format: 2 }.freeze

  belongs_to :user

  columns_changing_default :text_editor_type

  scope :with_user, -> { joins(:user) }
  scope :gitpod_enabled, -> { where(gitpod_enabled: true) }

  validates :dark_color_scheme_id, allow_nil: true, inclusion: {
    in: Gitlab::ColorSchemes.valid_ids,
    message: ->(*) { format(_("%{placeholder} is not a valid color scheme"), { placeholder: '%{value}' }) }
  }
  validates :issue_notes_filter, :merge_request_notes_filter, inclusion: { in: NOTES_FILTERS.values }, presence: true
  validates :tab_width, numericality: {
    only_integer: true,
    greater_than_or_equal_to: Gitlab::TabWidth::MIN,
    less_than_or_equal_to: Gitlab::TabWidth::MAX
  }
  validates :diffs_deletion_color, :diffs_addition_color,
    format: { with: ColorsHelper::HEX_COLOR_PATTERN },
    allow_blank: true
  validate :timezone_valid, if: -> { timezone_changed? }

  validates :time_display_relative, allow_nil: false, inclusion: { in: [true, false] }
  validates :render_whitespace_in_code, allow_nil: false, inclusion: { in: [true, false] }
  validates :pass_user_identities_to_ci_jwt, allow_nil: false, inclusion: { in: [true, false] }
  validates :pinned_nav_items, json_schema: { filename: 'pinned_nav_items' }

  validates :time_display_format, inclusion: { in: TIME_DISPLAY_FORMATS.values }, presence: true
  validates :extensions_marketplace_opt_in_url, length: { maximum: 512 }

  validates :work_items_display_settings, json_schema: { filename: 'user_preference_work_items_display_settings' }

  attribute :dark_color_scheme_id, default: -> { Gitlab::CurrentSettings.default_dark_syntax_highlighting_theme }
  attribute :tab_width, default: -> { Gitlab::TabWidth::DEFAULT }
  attribute :time_display_relative, default: true
  attribute :time_display_format, default: 0
  attribute :render_whitespace_in_code, default: false
  attribute :project_shortcut_buttons, default: true
  attribute :keyboard_shortcuts_enabled, default: true
  attribute :dpop_enabled, default: false
  attribute :text_editor_type, default: 2

  enum :visibility_pipeline_id_type, { id: 0, iid: 1 }, scopes: false

  enum :text_editor_type, { not_set: 0, plain_text_editor: 1, rich_text_editor: 2 }
  enum :extensions_marketplace_opt_in_status, Enums::WebIde::ExtensionsMarketplaceOptInStatus.statuses
  enum :organization_groups_projects_display, { projects: 0, groups: 1 }

  enum :merge_request_dashboard_list_type, { action_based: 0, role_based: 1 }

  class << self
    def notes_filters
      {
        s_('Notes|Show all activity') => NOTES_FILTERS[:all_notes],
        s_('Notes|Show comments only') => NOTES_FILTERS[:only_comments],
        s_('Notes|Show history only') => NOTES_FILTERS[:only_activity]
      }
    end
  end

  def set_notes_filter(filter_id, issuable)
    # No need to update the column if the value is already set.
    if filter_id && NOTES_FILTERS.value?(filter_id)
      field = notes_filter_field_for(issuable)
      self[field] = filter_id

      save if attribute_changed?(field)
    end

    notes_filter_for(issuable)
  end

  # Returns the current discussion filter for a given issuable
  # or issuable type.
  def notes_filter_for(resource)
    self[notes_filter_field_for(resource)]
  end

  class << self
    def time_display_formats
      {
        s_('Time Display|System') => TIME_DISPLAY_FORMATS[:system],
        s_('Time Display|12-hour: 2:34 PM') => TIME_DISPLAY_FORMATS[:non_iso_format],
        s_('Time Display|24-hour: 14:34') => TIME_DISPLAY_FORMATS[:iso_format]
      }
    end
  end

  def early_access_event_tracking?
    early_access_program_participant? && early_access_program_tracking?
  end

  def extensions_marketplace_opt_in_url
    # To support existing records, this can be `nil` and it defaults to `https://open-vsx.org`
    super || 'https://open-vsx.org'
  end

  def dpop_enabled=(value)
    if value.nil?
      default = self.class.column_defaults['dpop_enabled']
      super(default)
    else
      super(value)
    end
  end

  def text_editor
    text_editor_type
  end

  def text_editor=(value)
    self.text_editor_type = value
  end

  def default_text_editor_enabled
    text_editor == "rich_text_editor" || text_editor == "plain_text_editor"
  end

  def default_text_editor_enabled=(value)
    self.text_editor = value ? "rich_text_editor" : "not_set"
  end

  def timezone=(value)
    value = nil if value == ''

    super(value)
  end

  private

  def notes_filter_field_for(resource)
    field_key =
      if resource.is_a?(Issuable)
        resource.model_name.param_key
      else
        resource
      end

    "#{field_key}_notes_filter"
  end

  def timezone_valid
    return if timezone.nil?

    return if ActiveSupport::TimeZone[timezone].present?

    errors.add(:timezone, "timezone is not valid")
  end
end

UserPreference.prepend_mod_with('UserPreference')
==== /workspace/gitlab/app/models/user.rb ====
# frozen_string_literal: true

require 'carrierwave/orm/activerecord'

class User < ApplicationRecord
  extend Gitlab::ConfigHelper

  include Gitlab::ConfigHelper
  include Gitlab::SQL::Pattern
  include AfterCommitQueue
  include Avatarable
  include Referable
  include Sortable
  include CaseSensitivity
  include TokenAuthenticatable
  include FeatureGate
  include CreatedAtFilterable
  include BulkMemberAccessLoad
  include BlocksUnsafeSerialization
  include WithUploads
  include OptionallySearch
  include FromUnion
  include BatchDestroyDependentAssociations
  include BatchDeleteDependentAssociations
  include BatchNullifyDependentAssociations
  include UpdateHighestRole
  include HasUserType
  include Gitlab::Auth::Otp::Fortinet
  include Gitlab::Auth::Otp::DuoAuth
  include RestrictedSignup
  include StripAttribute
  include EachBatch
  include IgnorableColumns
  include UseSqlFunctionForPrimaryKeyLookups
  include Todoable
  include Gitlab::InternalEventsTracking
  include SafelyChangeColumnDefault

  columns_changing_default :organization_id

  ignore_column %i[role skype], remove_after: '2025-09-18', remove_with: '18.4'

  DEFAULT_NOTIFICATION_LEVEL = :participating

  INSTANCE_ACCESS_REQUEST_APPROVERS_TO_BE_NOTIFIED_LIMIT = 10

  BLOCKED_PENDING_APPROVAL_STATE = 'blocked_pending_approval'

  COUNT_CACHE_VALIDITY_PERIOD = 24.hours

  OTP_SECRET_LENGTH = 32
  OTP_SECRET_TTL = 2.minutes

  MAX_USERNAME_LENGTH = 255
  MIN_USERNAME_LENGTH = 2

  SECONDARY_EMAIL_ATTRIBUTES = [
    :commit_email,
    :notification_email,
    :public_email
  ].freeze

  FORBIDDEN_SEARCH_STATES = %w[blocked banned ldap_blocked].freeze

  INCOMING_MAIL_TOKEN_PREFIX = 'glimt-'
  FEED_TOKEN_PREFIX = 'glft-'

  FIRST_GROUP_PATHS_LIMIT = 200

  SERVICE_ACCOUNT_PREFIX = 'service_account'
  NOREPLY_EMAIL_DOMAIN = "noreply.#{Gitlab.config.gitlab.host}".freeze

  CI_PROJECT_RUNNERS_BATCH_SIZE = 15_000
  CI_RUNNERS_PROJECT_COUNT_LIMIT = 10_000

  # lib/tasks/tokens.rake needs to be updated when changing mail and feed tokens
  add_authentication_token_field :incoming_email_token, insecure: true, token_generator: -> { self.generate_incoming_mail_token } # rubocop:disable Gitlab/TokenWithoutPrefix -- wontfix: the prefix is in the generator
  add_authentication_token_field :feed_token, insecure: true, format_with_prefix: :prefix_for_feed_token
  # TODO: https://gitlab.com/gitlab-org/gitlab/-/issues/439294
  add_authentication_token_field :static_object_token, encrypted: :optional # rubocop:todo Gitlab/TokenWithoutPrefix -- https://gitlab.com/gitlab-org/gitlab/-/issues/439294

  attribute :admin, default: false
  attribute :external, default: -> { Gitlab::CurrentSettings.user_default_external }
  attribute :can_create_group, default: -> { Gitlab::CurrentSettings.can_create_group }
  attribute :private_profile, default: -> { Gitlab::CurrentSettings.user_defaults_to_private_profile }
  attribute :can_create_team, default: false
  attribute :hide_no_ssh_key, default: false
  attribute :hide_no_password, default: false
  attribute :project_view, default: :files
  attribute :notified_of_own_activity, default: false
  attribute :preferred_language, default: -> { Gitlab::CurrentSettings.default_preferred_language }
  attribute :theme_id, default: -> { gitlab_config.default_theme }
  attribute :color_scheme_id, default: -> { Gitlab::CurrentSettings.default_syntax_highlighting_theme }
  attribute :color_mode_id, default: -> { Gitlab::ColorModes::APPLICATION_DEFAULT }
  attribute :organization_id, default: -> { Organizations::Organization::DEFAULT_ORGANIZATION_ID }

  attr_encrypted :otp_secret,
    key: Gitlab::Application.credentials.otp_key_base,
    mode: :per_attribute_iv_and_salt,
    insecure_mode: true,
    algorithm: 'aes-256-cbc'

  devise :two_factor_authenticatable,
    otp_secret_encryption_key: Gitlab::Application.credentials.otp_key_base

  devise :two_factor_backupable, otp_number_of_backup_codes: 10
  devise :two_factor_backupable_pbkdf2
  serialize :otp_backup_codes, coder: JSON # rubocop:disable Cop/ActiveRecordSerialize

  devise :lockable, :recoverable, :rememberable, :trackable,
    :validatable, :omniauthable, :confirmable, :registerable

  # Must be included after `devise`
  include EncryptedUserPassword
  include RecoverableByAnyEmail

  include AdminChangedPasswordNotifier

  # This module adds async behaviour to Devise emails
  # and should be added after Devise modules are initialized.
  include AsyncDeviseEmail
  include ForcedEmailConfirmation
  include RequireEmailVerification

  MINIMUM_DAYS_CREATED = 7

  # Override Devise::Models::Trackable#update_tracked_fields!
  # to limit database writes to at most once every hour
  # rubocop: disable CodeReuse/ServiceClass
  def update_tracked_fields!(request)
    return if Gitlab::Database.read_only?

    update_tracked_fields(request)

    Gitlab::ExclusiveLease.throttle(id) do
      ::Ability.forgetting(/admin/) do
        Users::UpdateService.new(self, user: self).execute(validate: false)
      end
    end
  end
  # rubocop: enable CodeReuse/ServiceClass

  attr_accessor :force_random_password

  # Virtual attribute for authenticating by either username or email
  attr_accessor :login

  # Virtual attribute for impersonator
  attr_accessor :impersonator

  #
  # Relations
  #

  # Namespace for personal projects
  has_one :namespace,
    -> { where(type: Namespaces::UserNamespace.sti_name) },
    required: false,
    dependent: :destroy, # rubocop:disable Cop/ActiveRecordDependent
    foreign_key: :owner_id,
    inverse_of: :owner,
    autosave: true

  # Profile
  has_many :keys, -> { regular_keys }, dependent: :destroy # rubocop:disable Cop/ActiveRecordDependent
  has_many :expired_today_and_unnotified_keys, -> { expired_today_and_not_notified }, class_name: 'Key'
  has_many :expiring_soon_and_unnotified_keys, -> { expiring_soon_and_not_notified }, class_name: 'Key'
  has_many :deploy_keys, -> { where(type: 'DeployKey') }, dependent: :nullify # rubocop:disable Cop/ActiveRecordDependent
  has_many :group_deploy_keys
  has_many :gpg_keys

  has_many :emails
  has_many :personal_access_tokens, dependent: :destroy # rubocop:disable Cop/ActiveRecordDependent
  has_many :expiring_soon_and_unnotified_personal_access_tokens, -> { expiring_and_not_notified_without_impersonation }, class_name: 'PersonalAccessToken'

  has_many :identities, dependent: :destroy, autosave: true # rubocop:disable Cop/ActiveRecordDependent
  has_many :webauthn_registrations
  has_many :chat_names, dependent: :destroy # rubocop:disable Cop/ActiveRecordDependent
  has_many :saved_replies, class_name: '::Users::SavedReply'
  has_one :user_synced_attributes_metadata, autosave: true
  has_one :aws_role, class_name: 'Aws::Role'

  # Ghost User Migration
  has_one :ghost_user_migration, class_name: 'Users::GhostUserMigration'

  # Followers
  has_many :followed_users, foreign_key: :follower_id, class_name: 'Users::UserFollowUser'
  has_many :followees, -> { active }, through: :followed_users

  has_many :following_users, foreign_key: :followee_id, class_name: 'Users::UserFollowUser'
  has_many :followers, -> { active }, through: :following_users

  # Namespaces
  has_many :members
  has_many :member_namespaces, through: :members
  has_many :namespace_deletion_schedules, class_name: '::Namespaces::DeletionSchedule', inverse_of: :deleting_user

  # Groups
  has_many :group_members, -> { where(requested_at: nil).where("access_level >= ?", Gitlab::Access::GUEST) }, class_name: 'GroupMember'
  has_many :groups, through: :group_members
  has_many :groups_with_active_memberships, -> { where(members: { state: ::Member::STATE_ACTIVE }) }, through: :group_members, source: :group
  has_many :owned_groups, -> { where(members: { access_level: Gitlab::Access::OWNER }) }, through: :group_members, source: :group
  has_many :maintainers_groups, -> { where(members: { access_level: Gitlab::Access::MAINTAINER }) }, through: :group_members, source: :group
  has_many :developer_groups, -> { where(members: { access_level: ::Gitlab::Access::DEVELOPER }) }, through: :group_members, source: :group
  has_many :owned_or_maintainers_groups,
    -> { where(members: { access_level: [Gitlab::Access::MAINTAINER, Gitlab::Access::OWNER] }) },
    through: :group_members,
    source: :group
  has_many :developer_maintainer_owned_groups,
    -> { where(members: { access_level: [Gitlab::Access::DEVELOPER, Gitlab::Access::MAINTAINER, Gitlab::Access::OWNER] }) },
    through: :group_members,
    source: :group
  has_many :reporter_developer_maintainer_owned_groups,
    -> { where(members: { access_level: [Gitlab::Access::REPORTER, Gitlab::Access::DEVELOPER, Gitlab::Access::MAINTAINER, Gitlab::Access::OWNER] }) },
    through: :group_members,
    source: :group
  has_many :minimal_access_group_members, -> { where(access_level: [Gitlab::Access::MINIMAL_ACCESS]) }, class_name: 'GroupMember'
  has_many :minimal_access_groups, through: :minimal_access_group_members, source: :group

  # Projects
  has_many :groups_projects,          through: :groups, source: :projects
  has_many :personal_projects,        through: :namespace, source: :projects
  has_many :project_members, -> { where(requested_at: nil) }
  has_many :projects, through: :project_members
  has_many :created_projects, foreign_key: :creator_id, class_name: 'Project', dependent: :nullify # rubocop:disable Cop/ActiveRecordDependent
  has_many :created_namespace_details, foreign_key: :creator_id, class_name: 'Namespace::Detail'
  has_many :projects_with_active_memberships, -> { where(members: { state: ::Member::STATE_ACTIVE }) }, through: :project_members, source: :project
  has_many :users_star_projects, dependent: :destroy # rubocop:disable Cop/ActiveRecordDependent
  has_many :starred_projects, through: :users_star_projects, source: :project
  has_many :project_authorizations, dependent: :delete_all # rubocop:disable Cop/ActiveRecordDependent
  has_many :authorized_projects, through: :project_authorizations, source: :project

  has_many :snippets,                 dependent: :destroy, foreign_key: :author_id # rubocop:disable Cop/ActiveRecordDependent
  has_many :notes,                    dependent: :destroy, foreign_key: :author_id # rubocop:disable Cop/ActiveRecordDependent
  has_many :issues,                   dependent: :destroy, foreign_key: :author_id # rubocop:disable Cop/ActiveRecordDependent
  has_many :legacy_assigned_merge_requests, class_name: 'MergeRequest', dependent: :nullify, foreign_key: :assignee_id # rubocop:disable Cop/ActiveRecordDependent
  has_many :merged_merge_requests, class_name: 'MergeRequest::Metrics', dependent: :nullify, foreign_key: :merged_by_id # rubocop:disable Cop/ActiveRecordDependent
  has_many :closed_merge_requests, class_name: 'MergeRequest::Metrics', dependent: :nullify, foreign_key: :latest_closed_by_id # rubocop:disable Cop/ActiveRecordDependent
  has_many :updated_merge_requests, class_name: 'MergeRequest', dependent: :nullify, foreign_key: :updated_by_id # rubocop:disable Cop/ActiveRecordDependent
  has_many :updated_issues, class_name: 'Issue', dependent: :nullify, foreign_key: :updated_by_id # rubocop:disable Cop/ActiveRecordDependent
  has_many :closed_issues, class_name: 'Issue', dependent: :nullify, foreign_key: :closed_by_id # rubocop:disable Cop/ActiveRecordDependent
  has_many :merge_requests,           dependent: :destroy, foreign_key: :author_id # rubocop:disable Cop/ActiveRecordDependent
  has_many :events,                   dependent: :delete_all, foreign_key: :author_id # rubocop:disable Cop/ActiveRecordDependent
  has_many :releases,                 dependent: :nullify, foreign_key: :author_id # rubocop:disable Cop/ActiveRecordDependent
  has_many :subscriptions,            dependent: :destroy # rubocop:disable Cop/ActiveRecordDependent
  has_many :oauth_applications, class_name: 'Doorkeeper::Application', as: :owner, dependent: :destroy # rubocop:disable Cop/ActiveRecordDependent
  has_many :abuse_reports, dependent: :nullify, foreign_key: :user_id, inverse_of: :user # rubocop:disable Cop/ActiveRecordDependent
  has_many :admin_abuse_report_assignees, class_name: "Admin::AbuseReportAssignee"
  has_many :assigned_abuse_reports, class_name: "AbuseReport", through: :admin_abuse_report_assignees, source: :abuse_report
  has_many :reported_abuse_reports,   dependent: :nullify, foreign_key: :reporter_id, class_name: "AbuseReport", inverse_of: :reporter # rubocop:disable Cop/ActiveRecordDependent
  has_many :resolved_abuse_reports,   foreign_key: :resolved_by_id, class_name: "AbuseReport", inverse_of: :resolved_by
  has_many :abuse_events,             foreign_key: :user_id, class_name: 'AntiAbuse::Event', inverse_of: :user
  has_many :spam_logs,                dependent: :destroy # rubocop:disable Cop/ActiveRecordDependent
  has_many :abuse_trust_scores,       class_name: 'AntiAbuse::TrustScore', foreign_key: :user_id
  has_many :builds,                   class_name: 'Ci::Build'
  has_many :pipelines,                class_name: 'Ci::Pipeline'
  has_many :todos,                    dependent: :delete_all # rubocop:disable Cop/ActiveRecordDependent -- legacy behavior
  has_many :authored_todos, class_name: 'Todo', dependent: :destroy, foreign_key: :author_id # rubocop:disable Cop/ActiveRecordDependent
  has_many :notification_settings
  has_many :award_emoji, dependent: :destroy # rubocop:disable Cop/ActiveRecordDependent
  has_many :triggers, -> { Feature.enabled?(:trigger_token_expiration) ? not_expired : self }, class_name: 'Ci::Trigger', foreign_key: :owner_id
  has_many :audit_events, foreign_key: :author_id, inverse_of: :user
  has_many :uploaded_uploads, class_name: 'Upload', foreign_key: :uploaded_by_user_id

  has_many :alert_assignees, class_name: '::AlertManagement::AlertAssignee', inverse_of: :assignee
  has_many :issue_assignees, inverse_of: :assignee
  has_many :merge_request_assignees, inverse_of: :assignee, dependent: :destroy # rubocop:disable Cop/ActiveRecordDependent
  has_many :merge_request_reviewers, inverse_of: :reviewer, dependent: :destroy # rubocop:disable Cop/ActiveRecordDependent
  has_many :assigned_issues, class_name: "Issue", through: :issue_assignees, source: :issue
  has_many :assigned_merge_requests, class_name: "MergeRequest", through: :merge_request_assignees, source: :merge_request
  has_many :created_custom_emoji, class_name: 'CustomEmoji', inverse_of: :creator

  has_many :bulk_imports
  has_one :namespace_import_user, class_name: 'Import::NamespaceImportUser', inverse_of: :import_user
  has_one :placeholder_user_detail, class_name: 'Import::PlaceholderUserDetail', foreign_key: :placeholder_user_id, inverse_of: :placeholder_user

  has_many :custom_attributes, class_name: 'UserCustomAttribute'
  has_one  :trusted_with_spam_attribute, -> { UserCustomAttribute.trusted_with_spam }, class_name: 'UserCustomAttribute'
  has_many :callouts, class_name: 'Users::Callout'
  has_many :group_callouts, class_name: 'Users::GroupCallout'
  has_many :project_callouts, class_name: 'Users::ProjectCallout'
  has_many :term_agreements
  belongs_to :accepted_term, class_name: 'ApplicationSetting::Term'
  belongs_to :created_by, class_name: 'User', optional: true
  belongs_to :organization, class_name: 'Organizations::Organization'

  has_many :organization_users, class_name: 'Organizations::OrganizationUser', inverse_of: :user
  has_many :organization_user_details, class_name: 'Organizations::OrganizationUserDetail', inverse_of: :user

  has_many :organizations, through: :organization_users, class_name: 'Organizations::Organization', inverse_of: :users,
    disable_joins: true
  has_many :owned_organizations, -> { where(organization_users: { access_level: Gitlab::Access::OWNER }) },
    through: :organization_users, source: :organization, class_name: 'Organizations::Organization'

  has_one :status, class_name: 'UserStatus'
  has_one :user_preference
  has_one :user_detail
  has_one :user_highest_role
  has_one :credit_card_validation, class_name: '::Users::CreditCardValidation'
  has_one :phone_number_validation, class_name: '::Users::PhoneNumberValidation'
  has_one :atlassian_identity, class_name: 'Atlassian::Identity'
  has_one :banned_user, class_name: '::Users::BannedUser'

  has_many :reviews, foreign_key: :author_id, inverse_of: :author

  has_many :timelogs

  has_many :resource_label_events, dependent: :nullify # rubocop:disable Cop/ActiveRecordDependent
  has_many :resource_state_events, dependent: :nullify # rubocop:disable Cop/ActiveRecordDependent
  has_many :issue_assignment_events, class_name: 'ResourceEvents::IssueAssignmentEvent', dependent: :nullify # rubocop:disable Cop/ActiveRecordDependent
  has_many :merge_request_assignment_events, class_name: 'ResourceEvents::MergeRequestAssignmentEvent', dependent: :nullify # rubocop:disable Cop/ActiveRecordDependent
  has_many :authored_events, class_name: 'Event', dependent: :destroy, foreign_key: :author_id # rubocop:disable Cop/ActiveRecordDependent
  has_many :early_access_program_tracking_events, class_name: 'EarlyAccessProgram::TrackingEvent', inverse_of: :user
  has_many :namespace_commit_emails, class_name: 'Users::NamespaceCommitEmail'
  has_many :user_achievements, class_name: 'Achievements::UserAchievement', inverse_of: :user
  has_many :awarded_user_achievements, class_name: 'Achievements::UserAchievement', foreign_key: 'awarded_by_user_id', inverse_of: :awarded_by_user
  has_many :revoked_user_achievements, class_name: 'Achievements::UserAchievement', foreign_key: 'revoked_by_user_id', inverse_of: :revoked_by_user
  has_many :achievements, through: :user_achievements, class_name: 'Achievements::Achievement', inverse_of: :users
  has_many :vscode_settings, class_name: 'VsCode::Settings::VsCodeSetting', inverse_of: :user

  has_many :broadcast_message_dismissals, class_name: 'Users::BroadcastMessageDismissal'

  #
  # Validations
  #
  # Note: devise :validatable above adds validations for :email and :password
  validates :username,
    presence: true,
    exclusion: { in: Gitlab::PathRegex::TOP_LEVEL_ROUTES, message: N_('%{value} is a reserved name') }
  validates :username, uniqueness: true, unless: :namespace
  validate :username_not_assigned_to_pages_unique_domain, if: :username_changed?
  validates :name, presence: true, length: { maximum: 255 }
  validates :first_name, length: { maximum: 127 }
  validates :last_name, length: { maximum: 127 }
  validates :email, confirmation: true, devise_email: true
  validates :notification_email, devise_email: true, allow_blank: true
  validates :public_email, uniqueness: true, devise_email: true, allow_blank: true
  validates :commit_email, devise_email: true, allow_blank: true, unless: ->(user) { user.commit_email == Gitlab::PrivateCommitEmail::TOKEN }
  validates :projects_limit,
    presence: true,
    numericality: { greater_than_or_equal_to: 0, less_than_or_equal_to: Gitlab::Database::MAX_INT_VALUE }
  validate  :check_password_weakness, if: :encrypted_password_changed?

  validates :namespace, presence: true, unless: :optional_namespace?
  validate :namespace_move_dir_allowed, if: :username_changed?, unless: :new_record?

  validate :unique_email, if: :email_changed?
  validates_with AntiAbuse::UniqueDetumbledEmailValidator, if: :email_changed?
  validate :notification_email_verified, if: :notification_email_changed?
  validate :public_email_verified, if: :public_email_changed?
  validate :commit_email_verified, if: :commit_email_changed?
  validate :email_allowed_by_restrictions, if: ->(user) { user.new_record? ? !user.created_by_id : user.email_changed? }
  validate :check_username_format, if: :username_changed?

  validates :theme_id, allow_nil: true, inclusion: { in: Gitlab::Themes.valid_ids,
                                                     message: ->(*) { _("%{placeholder} is not a valid theme") % { placeholder: '%{value}' } } }
  validates :color_mode_id, allow_nil: true, inclusion: { in: Gitlab::ColorModes.valid_ids,
                                                          message: ->(*) { _("%{placeholder} is not a valid color mode") % { placeholder: '%{value}' } } }
  validates :color_scheme_id, allow_nil: true, inclusion: { in: Gitlab::ColorSchemes.valid_ids,
                                                            message: ->(*) { _("%{placeholder} is not a valid color scheme") % { placeholder: '%{value}' } } }
  validates :hide_no_ssh_key, allow_nil: false, inclusion: { in: [true, false] }
  validates :hide_no_password, allow_nil: false, inclusion: { in: [true, false] }
  validates :notified_of_own_activity, allow_nil: false, inclusion: { in: [true, false] }
  validates :project_view, presence: true
  validates :composite_identity_enforced, inclusion: { in: [false] }, unless: -> { service_account? }

  after_initialize :set_projects_limit
  # Ensures we get a user_detail on all new user records.
  # We are not able to fully guard against all possible places where User.new
  # is created, so we rely on the callback here at the model layer for our best
  # chance at ensuring the user_detail is created.
  # However, we need to skip all non-new records as after_initialize is called on basic finders as well.
  after_initialize :build_default_user_detail, if: :new_record?
  before_validation :sanitize_attrs
  before_validation :ensure_namespace_correct
  after_validation :set_username_errors
  before_save :ensure_incoming_email_token
  before_save :ensure_user_rights_and_limits, if: ->(user) { user.new_record? || user.external_changed? }
  before_save :skip_reconfirmation!, if: ->(user) { user.email_changed? && user.read_only_attribute?(:email) }
  before_save :check_for_verified_email, if: ->(user) { user.email_changed? && !user.new_record? }
  before_save :ensure_namespace_correct # in case validation is skipped
  after_update :username_changed_hook, if: :saved_change_to_username?
  after_destroy :post_destroy_hook
  after_destroy :remove_key_cache
  after_save if: -> { (saved_change_to_email? || saved_change_to_confirmed_at?) && confirmed? } do
    email_to_confirm = self.emails.find_by(email: self.email)

    if email_to_confirm.present?
      if skip_confirmation_period_expiry_check
        email_to_confirm.force_confirm
      else
        email_to_confirm.confirm
      end
    else
      ignore_cross_database_tables_if_factory_bot(%w[emails]) do
        add_primary_email_to_emails!
      end
    end
  end
  after_commit(on: :update) do
    update_invalid_gpg_signatures if previous_changes.key?('email')
  end
  after_update_commit :update_default_organization_user, if: -> { saved_change_to_admin }

  # User's Layout preference
  enum :layout, { fixed: 0, fluid: 1 }

  # User's Dashboard preference
  enum :dashboard, {
    projects: 0,
    stars: 1,
    member_projects: 11,
    your_activity: 10,
    project_activity: 2,
    starred_project_activity: 3,
    groups: 4,
    todos: 5,
    issues: 6,
    merge_requests: 7,
    operations: 8,
    followed_user_activity: 9,
    homepage: 12
  }

  # User's Project preference
  enum :project_view, { readme: 0, activity: 1, files: 2, wiki: 3 }

  # User's role
  enum :role, { software_developer: 0, development_team_lead: 1, devops_engineer: 2, systems_administrator: 3, security_analyst: 4, data_analyst: 5, product_manager: 6, product_designer: 7, other: 8 }, suffix: true

  delegate :notes_filter_for,
    :set_notes_filter,
    :first_day_of_week, :first_day_of_week=,
    :timezone, :timezone=,
    :time_display_relative, :time_display_relative=,
    :time_display_format, :time_display_format=,
    :show_whitespace_in_diffs, :show_whitespace_in_diffs=,
    :view_diffs_file_by_file, :view_diffs_file_by_file=,
    :pass_user_identities_to_ci_jwt, :pass_user_identities_to_ci_jwt=,
    :dark_color_scheme_id, :dark_color_scheme_id=,
    :tab_width, :tab_width=,
    :sourcegraph_enabled, :sourcegraph_enabled=,
    :gitpod_enabled, :gitpod_enabled=,
    :extensions_marketplace_opt_in_status, :extensions_marketplace_opt_in_status=,
    :extensions_marketplace_opt_in_url, :extensions_marketplace_opt_in_url=,
    :organization_groups_projects_sort, :organization_groups_projects_sort=,
    :organization_groups_projects_display, :organization_groups_projects_display=,
    :project_shortcut_buttons, :project_shortcut_buttons=,
    :keyboard_shortcuts_enabled, :keyboard_shortcuts_enabled=,
    :render_whitespace_in_code, :render_whitespace_in_code=,
    :markdown_surround_selection, :markdown_surround_selection=,
    :markdown_automatic_lists, :markdown_automatic_lists=,
    :markdown_maintain_indentation, :markdown_maintain_indentation=,
    :diffs_deletion_color, :diffs_deletion_color=,
    :diffs_addition_color, :diffs_addition_color=,
    :use_new_navigation, :use_new_navigation=,
    :pinned_nav_items, :pinned_nav_items=,
    :achievements_enabled, :achievements_enabled=,
    :enabled_following, :enabled_following=,
    :dpop_enabled, :dpop_enabled=,
    :use_work_items_view, :use_work_items_view=,
    :text_editor, :text_editor=,
    :default_text_editor_enabled, :default_text_editor_enabled=,
    :merge_request_dashboard_list_type, :merge_request_dashboard_list_type=,
    to: :user_preference

  delegate :path, to: :namespace, allow_nil: true, prefix: true
  delegate :job_title, :job_title=, to: :user_detail, allow_nil: true
  delegate :bio, :bio=, to: :user_detail, allow_nil: true
  delegate :webauthn_xid, :webauthn_xid=, to: :user_detail, allow_nil: true
  delegate :pronouns, :pronouns=, to: :user_detail, allow_nil: true
  delegate :pronunciation, :pronunciation=, to: :user_detail, allow_nil: true
  delegate :bluesky, :bluesky=, to: :user_detail, allow_nil: true
  delegate :orcid, :orcid=, to: :user_detail, allow_nil: true
  delegate :mastodon, :mastodon=, to: :user_detail, allow_nil: true
  delegate :linkedin, :linkedin=, to: :user_detail, allow_nil: true
  delegate :twitter, :twitter=, to: :user_detail, allow_nil: true
  delegate :website_url, :website_url=, to: :user_detail, allow_nil: true
  delegate :location, :location=, to: :user_detail, allow_nil: true
  delegate :organization, :organization=, to: :user_detail, prefix: true, allow_nil: true
  delegate :discord, :discord=, to: :user_detail, allow_nil: true
  delegate :github, :github=, to: :user_detail, allow_nil: true
  delegate :project_authorizations_recalculated_at, :project_authorizations_recalculated_at=, to: :user_detail, allow_nil: true
  delegate :bot_namespace, :bot_namespace=, to: :user_detail, allow_nil: true
  delegate :email_otp, :email_otp=, to: :user_detail, allow_nil: true
  delegate :email_otp_required_after, :email_otp_required_after=, to: :user_detail, allow_nil: true
  delegate :email_otp_last_sent_at, :email_otp_last_sent_at=, to: :user_detail, allow_nil: true
  delegate :email_otp_last_sent_to, :email_otp_last_sent_to=, to: :user_detail, allow_nil: true

  accepts_nested_attributes_for :user_preference, update_only: true
  accepts_nested_attributes_for :user_detail, update_only: true
  accepts_nested_attributes_for :credit_card_validation, update_only: true, allow_destroy: true
  accepts_nested_attributes_for :organization_users, update_only: true

  state_machine :state, initial: :active do
    # state_machine uses this method at class loading time to fetch the default
    # value for the `state` column but in doing so it also evaluates all other
    # columns default values which could trigger the recursive generation of
    # ApplicationSetting records. We're setting it to `nil` here because we
    # don't have a database default for the `state` column.
    #
    def owner_class_attribute_default; end

    event :block do
      transition active: :blocked
      transition deactivated: :blocked
      transition ldap_blocked: :blocked
      transition blocked_pending_approval: :blocked
    end

    event :ldap_block do
      transition active: :ldap_blocked
      transition deactivated: :ldap_blocked
    end

    # aliasing system_block to set ldap_blocked statuses
    # ldap_blocked is used for LDAP, SAML, and SCIM blocked users
    # Issue for improving this naming:
    # https://gitlab.com/gitlab-org/gitlab/-/issues/388487
    event :system_block do
      transition active: :ldap_blocked
      transition deactivated: :ldap_blocked
    end

    event :activate do
      transition deactivated: :active
      transition blocked: :active
      transition ldap_blocked: :active
      transition blocked_pending_approval: :active
      transition banned: :active
    end

    event :block_pending_approval do
      transition active: :blocked_pending_approval
    end

    event :ban do
      transition active: :banned
    end

    event :unban do
      transition banned: :active
    end

    event :deactivate do
      # Any additional changes to this event should be also
      # reflected in app/workers/users/deactivate_dormant_users_worker.rb
      transition active: :deactivated
    end

    state :blocked, :ldap_blocked, :blocked_pending_approval, :banned do
      def blocked?
        true
      end
    end

    before_transition do
      !Gitlab::Database.read_only?
    end

    # rubocop: disable CodeReuse/ServiceClass
    after_transition any => :blocked do |user|
      user.run_after_commit do
        Ci::DropPipelinesAndDisableSchedulesForUserService.new.execute(
          user,
          reason: :user_blocked,
          include_owned_projects_and_groups: false
        )
      end
    end

    after_transition any => :deactivated do |user|
      next unless Gitlab::CurrentSettings.user_deactivation_emails_enabled

      user.run_after_commit do
        NotificationService.new.user_deactivated(user.name, user.notification_email_or_default)
      end
    end

    after_transition active: :banned do |user|
      user.create_banned_user

      user.invalidate_authored_todo_user_pending_todo_cache_counts

      if Gitlab.com? # rubocop:disable Gitlab/AvoidGitlabInstanceChecks -- this is always necessary on GitLab.com
        user.run_after_commit do
          deep_clean_ci = user.custom_attributes.by_key(UserCustomAttribute::DEEP_CLEAN_CI_USAGE_WHEN_BANNED).exists?

          Ci::DropPipelinesAndDisableSchedulesForUserService.new.execute(
            user,
            reason: :user_banned,
            include_owned_projects_and_groups: deep_clean_ci
          )
        end
      end
    end
    # rubocop: enable CodeReuse/ServiceClass

    after_transition banned: :active do |user|
      user.banned_user&.destroy
      user.invalidate_authored_todo_user_pending_todo_cache_counts
    end

    after_transition any => :active do |user|
      user.starred_projects.update_counters(star_count: 1)
    end

    after_transition active: any do |user|
      user.starred_projects.where('star_count > 0').update_counters(star_count: -1)
    end
  end

  # Scopes
  scope :admins, -> { where(admin: true) }
  scope :instance_access_request_approvers_to_be_notified, -> { admins.active.order_recent_sign_in.limit(INSTANCE_ACCESS_REQUEST_APPROVERS_TO_BE_NOTIFIED_LIMIT) }
  scope :blocked, -> { with_states(:blocked, :ldap_blocked) }
  scope :blocked_pending_approval, -> { with_states(:blocked_pending_approval) }
  scope :banned, -> { with_states(:banned) }
  scope :external, -> { where(external: true) }
  scope :non_external, -> { where(external: false) }
  scope :confirmed, -> { where.not(confirmed_at: nil) }
  scope :active, -> { with_state(:active).non_internal }
  scope :without_active, -> { without_state(:active) }
  scope :active_without_ghosts, -> { with_state(:active).without_ghosts }
  scope :all_without_ghosts, -> { without_ghosts }
  scope :deactivated, -> { with_state(:deactivated).non_internal }
  scope :without_projects, -> do
    joins('LEFT JOIN project_authorizations ON users.id = project_authorizations.user_id')
    .where(project_authorizations: { user_id: nil })
    .allow_cross_joins_across_databases(url: 'https://gitlab.com/gitlab-org/gitlab/-/issues/422045')
  end
  scope :by_username, ->(usernames) { iwhere(username: Array(usernames).map(&:to_s)) }
  scope :by_name, ->(names) { iwhere(name: Array(names)) }
  scope :by_login, ->(login) do
    return none if login.blank?

    login.include?('@') ? iwhere(email: login) : iwhere(username: login)
  end
  scope :by_user_email, ->(emails) { iwhere(email: Array(emails)) }
  scope :by_emails, ->(emails) { joins(:emails).where(emails: { email: Array(emails).map(&:downcase) }) }
  scope :by_detumbled_emails, ->(detumbled_emails) do
    joins(:emails).where(emails: { detumbled_email: Array(detumbled_emails) })
  end
  scope :for_todos, ->(todos) { where(id: todos.select(:user_id).distinct) }
  scope :with_emails, -> { preload(:emails) }
  scope :with_dashboard, ->(dashboard) { where(dashboard: dashboard) }
  scope :with_public_profile, -> { where(private_profile: false) }
  scope :with_personal_access_tokens_expired_today, -> do
    where('EXISTS (?)', ::PersonalAccessToken
      .select(1)
      .where('personal_access_tokens.user_id = users.id')
      .without_impersonation
      .expired_today_and_not_notified
    )
  end

  scope :with_ssh_key_expiring_soon, -> do
    includes(:expiring_soon_and_unnotified_keys)
      .where('EXISTS (?)', ::Key
        .select(1)
        .where('keys.user_id = users.id')
        .expiring_soon_and_not_notified)
  end

  scope :with_personal_access_tokens_expiring_soon, -> do
    includes(:expiring_soon_and_unnotified_personal_access_tokens)
  end

  scope :order_recent_sign_in, -> { reorder(arel_table[:current_sign_in_at].desc.nulls_last) }
  scope :order_oldest_sign_in, -> { reorder(arel_table[:current_sign_in_at].asc.nulls_last) }
  scope :order_recent_last_activity, -> { reorder(arel_table[:last_activity_on].desc.nulls_last, arel_table[:id].asc) }
  scope :order_oldest_last_activity, -> { reorder(arel_table[:last_activity_on].asc.nulls_first, arel_table[:id].desc) }
  scope :ordered_by_id_desc, -> { reorder(arel_table[:id].desc) }
  scope :ordered_by_name_asc_id_desc, -> { order(name: :asc, id: :desc) }

  scope :dormant, -> { with_state(:active).human_or_service_user.where('last_activity_on <= ?', Gitlab::CurrentSettings.deactivate_dormant_users_period.day.ago.to_date) }
  scope :with_no_activity, -> { with_state(:active).human_or_service_user.where(last_activity_on: nil).where('created_at <= ?', MINIMUM_DAYS_CREATED.day.ago.to_date) }
  scope :by_provider_and_extern_uid, ->(provider, extern_uid) { joins(:identities).merge(Identity.with_extern_uid(provider, extern_uid)) }
  scope :ldap, -> { joins(:identities).where('identities.provider LIKE ?', 'ldap%') }
  scope :by_ids, ->(ids) { where(id: ids) }
  scope :by_ids_or_usernames, ->(ids, usernames) { where(username: usernames).or(where(id: ids)) }
  scope :without_forbidden_states, -> { where.not(state: FORBIDDEN_SEARCH_STATES) }
  scope :trusted, -> do
    where('EXISTS (?)', ::UserCustomAttribute
      .select(1)
      .where('user_id = users.id')
      .trusted_with_spam)
  end

  # This scope to be used only for bot_users since for
  # regular users this may lead to memory allocation issues
  scope :with_personal_access_tokens_and_resources, -> do
    includes(:personal_access_tokens)
    .includes(:groups)
    .includes(:projects)
  end

  scope :with_organization_user_details, -> do
    includes(organization_user_details: [:organization])
  end

  scope :left_join_user_detail, -> { left_joins(:user_detail) }
  scope :preload_user_detail, -> { preload(:user_detail) }

  scope :by_bot_namespace_ids, ->(namespace_ids) do
    project_bot.joins(:user_detail).where(user_detail: { bot_namespace_id: namespace_ids })
  end

  scope :with_incoming_email_token, ->(token_values) do
    where(incoming_email_token: Array.wrap(token_values))
  end

  scope :with_feed_token, ->(token_values) do
    where(feed_token: Array.wrap(token_values))
  end

  def self.supported_keyset_orderings
    {
      id: [:asc, :desc],
      name: [:asc, :desc],
      username: [:asc, :desc],
      created_at: [:asc, :desc],
      updated_at: [:asc, :desc]
    }
  end

  strip_attributes! :name

  def preferred_language
    read_attribute('preferred_language').presence || Gitlab::CurrentSettings.default_preferred_language
  end

  def active_for_authentication?
    return false unless super

    check_ldap_if_ldap_blocked!

    can?(:log_in)
  end

  # The messages for these keys are defined in `devise.en.yml`
  def inactive_message
    if blocked_pending_approval?
      :blocked_pending_approval
    elsif blocked?
      :blocked
    elsif internal?
      :forbidden
    else
      super
    end
  end

  def self.with_visible_profile(user)
    return with_public_profile if user.nil?

    if user.admin?
      all
    else
      with_public_profile.or(where(id: user.id))
    end
  end

  # Limits the users to those that have TODOs, optionally in the given state.
  #
  # user - The user to get the todos for.
  #
  # with_todos - If we should limit the result set to users that are the
  #              authors of todos.
  #
  # todo_state - An optional state to require the todos to be in.
  def self.limit_to_todo_authors(user: nil, with_todos: false, todo_state: nil)
    if user && with_todos
      where(id: Todo.where(user: user, state: todo_state).select(:author_id))
    else
      all
    end
  end

  # Returns a relation that optionally includes the given user.
  #
  # user_id - The ID of the user to include.
  def self.union_with_user(user_id = nil)
    if user_id.present?
      # We use "unscoped" here so that any inner conditions are not repeated for
      # the outer query, which would be redundant.
      User.unscoped.from_union([all, User.unscoped.where(id: user_id)])
    else
      all
    end
  end

  def self.with_two_factor
    where(otp_required_for_login: true)
      .or(where_exists(WebauthnRegistration.where(WebauthnRegistration.arel_table[:user_id].eq(arel_table[:id]))))
  end

  def self.without_two_factor
    where
      .missing(:webauthn_registrations)
      .where(otp_required_for_login: false)
  end

  #
  # Class methods
  #
  class << self
    # Devise method overridden to allow support for dynamic password lengths
    def password_length
      Gitlab::CurrentSettings.minimum_password_length..Devise.password_length.max
    end

    # Generate a random password that conforms to the current password length settings
    def random_password
      Devise.friendly_token(password_length.max)
    end

    # Devise method overridden to allow sign in with email or username
    def find_for_database_authentication(warden_conditions)
      conditions = warden_conditions.dup
      if login = conditions.delete(:login)
        where(conditions).find_by("lower(username) = :value OR lower(email) = :value", value: login.downcase.strip)
      else
        find_by(conditions)
      end
    end

    def sort_by_attribute(method)
      order_method = method || 'id_desc'

      case order_method.to_s
      when 'recent_sign_in' then order_recent_sign_in
      when 'oldest_sign_in' then order_oldest_sign_in
      when 'last_activity_on_desc' then order_recent_last_activity
      when 'last_activity_on_asc' then order_oldest_last_activity
      else
        order_by(order_method)
      end
    end

    # Find a User by their primary email or any associated confirmed secondary email
    def find_by_any_email(email, confirmed: false)
      return unless email

      by_any_email(email, confirmed: confirmed).take
    end

    # Returns a relation containing all found users by their primary email
    # or any associated confirmed secondary email
    #
    # @param emails [String, Array<String>] email addresses to check
    # @param confirmed [Boolean] Only return users where the primary email is confirmed
    def by_any_email(emails, confirmed: false)
      return none if Array(emails).all?(&:nil?)

      from_users = by_user_email(emails)
      from_users = from_users.confirmed if confirmed

      from_emails = by_emails(emails).merge(Email.confirmed)
      from_emails = from_emails.confirmed if confirmed

      items = [from_users, from_emails]

      # TODO: https://gitlab.com/gitlab-org/gitlab/-/issues/461885
      # What about private commit emails with capitalized username, we'd never find them and
      # since the private_commit_email derives from the username, it can
      # be uppercase in parts. So we'll never find an existing user during the invite
      # process by email if that is true as we are case sensitive in this case.
      user_ids = Gitlab::PrivateCommitEmail.user_ids_for_emails(Array(emails).map(&:downcase))
      items << where(id: user_ids) if user_ids.present?

      from_union(items)
    end

    def find_by_private_commit_email(email)
      user_id = Gitlab::PrivateCommitEmail.user_id_for_email(email)

      find_by(id: user_id)
    end

    def filter_items(filter_name)
      case filter_name
      when 'blocked', 'blocked_pending_approval', 'banned',
           'deactivated', 'active'
        filter_by_state(filter_name)
      when 'admins'
        admins
      when 'two_factor_disabled'
        without_two_factor
      when 'two_factor_enabled'
        with_two_factor
      when 'wop'
        without_projects
      when 'external'
        external
      when 'trusted'
        trusted
      when 'placeholder'
        placeholder
      when 'without_placeholders'
        without_placeholders
      when 'ldap_sync'
        ldap
      when "without_bots"
        without_bots
      when "bots"
        bots
      else
        all_without_ghosts
      end
    end

    def filter_by_state(filter_name)
      case filter_name
      when 'blocked'
        blocked
      when 'blocked_pending_approval'
        blocked_pending_approval
      when 'banned'
        banned
      when 'deactivated'
        deactivated
      when 'active'
        active_without_ghosts
      end
    end

    # Searches users matching the given query.
    #
    # This method uses ILIKE on PostgreSQL.
    #
    # query - The search query as a String
    # with_private_emails - include private emails in search
    # partial_email_search - only for admins to preserve email privacy. Only for self-managed instances.
    #
    # Returns an ActiveRecord::Relation.
    def search(query, **options)
      return none unless query.is_a?(String)

      query = query&.delete_prefix('@')
      return none if query.blank?

      query = query.downcase

      order = <<~SQL
        CASE
          WHEN LOWER(users.public_email) = :query THEN 0
          WHEN LOWER(users.username) = :query THEN 1
          WHEN LOWER(users.name) = :query THEN 2
          ELSE 3
        END
      SQL

      sanitized_order_sql = Arel.sql(sanitize_sql_array([order, { query: query }]))

      use_minimum_char_limit = options[:use_minimum_char_limit]

      scope =
        if options[:with_private_emails]
          with_primary_or_secondary_email(
            query, use_minimum_char_limit: use_minimum_char_limit, partial_email_search: options[:partial_email_search]
          )
        else
          with_public_email(query)
        end

      scope = scope.or(search_by_name_or_username(query, use_minimum_char_limit: use_minimum_char_limit))

      order = Gitlab::Pagination::Keyset::Order.build(
        [
          Gitlab::Pagination::Keyset::ColumnOrderDefinition.new(
            attribute_name: 'users_match_priority',
            order_expression: sanitized_order_sql.asc,
            add_to_projections: true
          ),
          Gitlab::Pagination::Keyset::ColumnOrderDefinition.new(
            attribute_name: 'users_name',
            order_expression: arel_table[:name].asc,
            add_to_projections: true,
            nullable: :not_nullable
          ),
          Gitlab::Pagination::Keyset::ColumnOrderDefinition.new(
            attribute_name: 'users_id',
            order_expression: arel_table[:id].asc,
            add_to_projections: true,
            nullable: :not_nullable
          )
        ])
      scope.reorder(order)
    end

    # This should be kept in sync with the frontend filtering in
    # https://gitlab.com/gitlab-org/gitlab/-/blob/5d34e3488faa3982d30d7207773991c1e0b6368a/app/assets/javascripts/gfm_auto_complete.js#L68 and
    # https://gitlab.com/gitlab-org/gitlab/-/blob/5d34e3488faa3982d30d7207773991c1e0b6368a/app/assets/javascripts/gfm_auto_complete.js#L1053
    def gfm_autocomplete_search(query)
      where(
        "REPLACE(users.name, ' ', '') ILIKE :pattern OR users.username ILIKE :pattern",
        pattern: "%#{sanitize_sql_like(query)}%"
      ).order(
        Arel.sql(sanitize_sql(
          [
            "CASE WHEN REPLACE(users.name, ' ', '') ILIKE :prefix_pattern OR users.username ILIKE :prefix_pattern THEN 1 ELSE 2 END",
            { prefix_pattern: "#{sanitize_sql_like(query)}%" }
          ]
        )),
        :username,
        :id
      )
    end

    # Limits the result set to users _not_ in the given query/list of IDs.
    #
    # users - The list of users to ignore. This can be an
    #         `ActiveRecord::Relation`, or an Array.
    def where_not_in(users = nil)
      users ? where.not(id: users) : all
    end

    def reorder_by_name
      reorder(:name)
    end

    # searches user by given pattern
    # it compares name and username fields with given pattern
    # This method uses ILIKE on PostgreSQL.
    def search_by_name_or_username(query, use_minimum_char_limit: nil)
      use_minimum_char_limit = user_search_minimum_char_limit if use_minimum_char_limit.nil?

      where(
        fuzzy_arel_match(:name, query, use_minimum_char_limit: use_minimum_char_limit)
          .or(fuzzy_arel_match(:username, query, use_minimum_char_limit: use_minimum_char_limit))
      )
    end

    def with_public_email(email_address)
      where(public_email: email_address)
    end

    def with_primary_or_secondary_email(query, use_minimum_char_limit: true, partial_email_search: false)
      email_table = Email.arel_table

      if partial_email_search
        email_table_matched_by_email = Email.fuzzy_arel_match(:email, query, use_minimum_char_limit: use_minimum_char_limit)
        matched_by_email = User.fuzzy_arel_match(:email, query, use_minimum_char_limit: use_minimum_char_limit)
      else
        email_table_matched_by_email = email_table[:email].eq(query)
        matched_by_email = arel_table[:email].eq(query)
      end

      matched_by_email_user_id = email_table
        .project(email_table[:user_id])
        .where(email_table_matched_by_email)
        .where(email_table[:confirmed_at].not_eq(nil))
        .take(1) # at most 1 record as there is a unique constraint

      where(
        matched_by_email
        .or(arel_table[:id].eq(matched_by_email_user_id))
      )
    end

    # This method is overridden in JiHu.
    # https://gitlab.com/gitlab-org/gitlab/-/issues/348509
    def user_search_minimum_char_limit
      true
    end

    def find_by_login(login)
      by_login(login).take
    end

    def find_by_username(username)
      by_username(username).take
    end

    def find_by_username!(username)
      by_username(username).take!
    end

    # Returns a user for the given SSH key. Deploy keys are excluded.
    def find_by_ssh_key_id(key_id)
      find_by('EXISTS (?)', Key.select(1).where('keys.user_id = users.id').auth.regular_keys.where(id: key_id))
    end

    def find_by_full_path(path, follow_redirects: false)
      namespace = Namespace.user_namespaces.find_by_full_path(path, follow_redirects: follow_redirects)
      namespace&.owner
    end

    def reference_prefix
      '@'
    end

    # Pattern used to extract `@user` user references from text
    def reference_pattern
      @reference_pattern ||=
        %r{
          (?<!\w)
          #{Regexp.escape(reference_prefix)}
          (?<user>#{Gitlab::PathRegex::FULL_NAMESPACE_FORMAT_REGEX})
        }x
    end

    # Return true if there is only single non-internal user in the deployment,
    # ghost user is ignored.
    def single_user?
      User.non_internal.limit(2).count == 1
    end

    def single_user
      User.non_internal.first if single_user?
    end

    def get_ids_by_ids_or_usernames(ids, usernames)
      by_ids_or_usernames(ids, usernames).pluck(:id)
    end

    def generate_incoming_mail_token
      "#{prefix_for_incoming_mail_token}#{SecureRandom.hex.to_i(16).to_s(36)}"
    end

    def prefix_for_incoming_mail_token
      return INCOMING_MAIL_TOKEN_PREFIX unless Feature.enabled?(:custom_prefix_for_all_token_types, :instance)

      ::Authn::TokenField::PrefixHelper.prepend_instance_prefix(INCOMING_MAIL_TOKEN_PREFIX)
    end

    def username_exists?(username)
      exists?(username: username)
    end

    def id_exists?(id)
      exists?(id: id)
    end

    def ends_with_reserved_file_extension?(username)
      Mime::EXTENSION_LOOKUP.keys.any? { |type| username.end_with?(".#{type}") }
    end
  end

  #
  # Instance methods
  #

  def full_path
    username
  end

  def to_param
    username
  end

  def build_default_user_detail
    # We will need to ensure we keep checking to see if it exists logic since this runs from
    # an after_initialize.
    # In cases where user_detail params are added during a `User.new` or create call with user_detail
    # attributes set through delegation of setters, we will already have some user_detail
    # attributes created from a built user_detail that will then be removed by an
    # initialization of a new user_detail.
    # We can see one case of that in the Users::BuildService where it assigns user attributes that can
    # have delegated user_detail attributes added by classes that inherit this class and add
    # to the user attributes hash.
    # Therefore, we need to check for presence of an existing built user_detail here.
    user_detail || build_user_detail
  end

  def to_reference(_from = nil, target_container: nil, full: nil)
    "#{self.class.reference_prefix}#{username}"
  end

  def readable_by?(user)
    id == user.id
  end

  def skip_confirmation=(bool)
    skip_confirmation! if bool
  end

  def skip_reconfirmation=(bool)
    skip_reconfirmation! if bool
  end

  def generate_reset_token
    @reset_token, enc = Devise.token_generator.generate(self.class, :reset_password_token)

    self.reset_password_token   = enc
    self.reset_password_sent_at = Time.current.utc

    @reset_token
  end

  def recently_sent_password_reset?
    reset_password_sent_at.present? && reset_password_sent_at >= 1.minute.ago
  end

  # Overwrites valid_password? from Devise::Models::DatabaseAuthenticatable
  # In constant-time, check both that the password isn't on a denylist AND
  # that the password is the user's password
  def valid_password?(password)
    return false unless password_allowed?(password)
    return false if password_automatically_set?
    return false unless allow_password_authentication?

    super
  end

  def generate_otp_backup_codes!
    if Gitlab::FIPS.enabled?
      generate_otp_backup_codes_pbkdf2!
    else
      super
    end
  end

  def invalidate_otp_backup_code!(code)
    if Gitlab::FIPS.enabled? && pbkdf2?
      invalidate_otp_backup_code_pdkdf2!(code)
    else
      super(code)
    end
  end

  # See https://gitlab.com/gitlab-org/security/gitlab/-/issues/638
  DISALLOWED_PASSWORDS = %w[123qweQWE!@#000000000].freeze

  def password_allowed?(password)
    password_allowed = true

    DISALLOWED_PASSWORDS.each do |disallowed_password|
      password_allowed = false if Devise.secure_compare(password, disallowed_password)
    end

    password_allowed
  end

  # Override Devise Rememberable#remember_me!
  #
  # In Devise this method sets `remember_created_at` and writes the session token
  # to the session cookie. When remember me is disabled this method ensures these
  # values aren't set.
  def remember_me!
    super if ::Gitlab::Database.read_write? && ::Gitlab::CurrentSettings.allow_user_remember_me?
  end

  def forget_me!
    super if ::Gitlab::Database.read_write?
  end

  # This is a copy of #forget_me! without the check for `expire_all_remember_me_on_sign_out`
  # https://github.com/heartcombo/devise/blob/v4.9.4/lib/devise/models/rememberable.rb#L58-L63
  #
  # We need a separate method because we disabled that setting but we also need to be able to
  # manually expire these tokens when a session is manually destroyed
  def invalidate_all_remember_tokens!
    return unless persisted?

    self.remember_token = nil if respond_to?(:remember_token)
    self.remember_created_at = nil
    save(validate: false)
  end

  # Override Devise Rememberable#remember_me?
  #
  # In Devise this method compares the remember me token received from the user session
  # and compares to the stored value. When remember me is disabled this method ensures
  # the upstream comparison does not happen.
  def remember_me?(token, generated_at)
    return false unless ::Gitlab::CurrentSettings.allow_user_remember_me?

    super
  end

  def disable_two_factor!
    transaction do
      self.disable_webauthn!
      self.disable_two_factor_otp!
      self.reset_backup_codes!
    end
  end

  def disable_two_factor_otp!
    update!(
      otp_required_for_login: false,
      encrypted_otp_secret: nil,
      encrypted_otp_secret_iv: nil,
      encrypted_otp_secret_salt: nil,
      otp_grace_period_started_at: nil,
      otp_secret_expires_at: nil
    )
  end

  def disable_webauthn!
    self.webauthn_registrations.destroy_all # rubocop:disable Cop/DestroyAll
  end

  def reset_backup_codes!
    update(otp_backup_codes: nil)
  end

  def two_factor_enabled?
    two_factor_otp_enabled? || two_factor_webauthn_enabled?
  end

  def two_factor_otp_enabled?
    otp_required_for_login? ||
      forti_authenticator_enabled?(self) ||
      forti_token_cloud_enabled?(self) ||
      duo_auth_enabled?(self)
  end

  def two_factor_webauthn_enabled?
    (webauthn_registrations.loaded? && webauthn_registrations.any?) || (!webauthn_registrations.loaded? && webauthn_registrations.exists?)
  end

  def needs_new_otp_secret?
    !two_factor_otp_enabled? && otp_secret_expired?
  end

  def otp_secret_expired?
    return true unless otp_secret_expires_at

    otp_secret_expires_at.past?
  end

  def update_otp_secret!
    self.otp_secret = User.generate_otp_secret(OTP_SECRET_LENGTH)
    self.otp_secret_expires_at = Time.current + OTP_SECRET_TTL
  end

  def namespace_move_dir_allowed
    if namespace&.any_project_has_container_registry_tags?
      errors.add(:username, _('cannot be changed if a personal project has container registry tags.'))
    end
  end

  # will_save_change_to_attribute? is used by Devise to check if it is necessary
  # to clear any existing reset_password_tokens before updating an authentication_key
  # and login in our case is a virtual attribute to allow login by username or email.
  def will_save_change_to_login?
    will_save_change_to_username? || will_save_change_to_email?
  end

  def unique_email
    email_taken = errors.added?(:email, _('has already been taken'))

    if !email_taken && Email.where.not(user: self).where(email: email).exists?
      errors.add(:email, _('has already been taken'))
      email_taken = true
    end

    if email_taken &&
        ::Gitlab::CurrentSettings.delay_user_account_self_deletion &&
        User.find_by_any_email(email)&.deleted_own_account?

      help_page_url = Rails.application.routes.url_helpers.help_page_url(
        'user/profile/account/delete_account.md',
        anchor: 'delete-your-own-account'
      )

      errors.add(:email, _('is linked to an account pending deletion.'), help_page_url: help_page_url)
    end
  end

  def commit_email_or_default
    if self.commit_email == Gitlab::PrivateCommitEmail::TOKEN
      return private_commit_email
    end

    # The commit email is the same as the primary email if undefined
    self.commit_email.presence || self.email
  end

  def notification_email_or_default
    # The notification email is the same as the primary email if undefined
    self.notification_email.presence || self.email
  end

  def private_commit_email
    Gitlab::PrivateCommitEmail.for_user(self)
  end

  # see if the new email is already a verified secondary email
  def check_for_verified_email
    skip_reconfirmation! if emails.confirmed.where(email: self.email).any?
  end

  def update_invalid_gpg_signatures
    gpg_keys.each(&:update_invalid_gpg_signatures)
  end

  # Returns the groups a user has access to, either through direct or inherited membership or a project authorization
  def authorized_groups
    Group.unscoped do
      direct_groups_cte = Gitlab::SQL::CTE.new(:direct_groups, groups)
      direct_groups_cte_alias = direct_groups_cte.table.alias(Group.table_name)

      groups_from_authorized_projects = Group.id_in(authorized_projects.select(:namespace_id)).self_and_ancestors
      groups_from_shares = Group.joins(:shared_with_group_links)
                             .where(group_group_links: { shared_with_group_id: Group.from(direct_groups_cte_alias) })
                             .self_and_descendants

      Group
        .with(direct_groups_cte.to_arel)
        .from_union([
          Group.from(direct_groups_cte_alias).self_and_descendants,
          groups_from_authorized_projects,
          groups_from_shares
        ])
    end
  end

  # Used to search on the user's authorized_groups effeciently by using a CTE
  def search_on_authorized_groups(query, use_minimum_char_limit: true)
    authorized_groups_cte = Gitlab::SQL::CTE.new(:authorized_groups, authorized_groups)
    authorized_groups_cte_alias = authorized_groups_cte.table.alias(Group.table_name)
    Group
      .with(authorized_groups_cte.to_arel)
      .from(authorized_groups_cte_alias)
      .search(query, use_minimum_char_limit: use_minimum_char_limit)
  end

  # Returns the groups a user is a member of, either directly or through a parent group
  def membership_groups
    groups.self_and_descendants
  end

  # Returns a relation of groups the user has access to, including their parent
  # and child groups (recursively).
  def all_expanded_groups
    return groups if groups.empty?

    Gitlab::ObjectHierarchy.new(groups).all_objects
  end

  def expanded_groups_requiring_two_factor_authentication
    all_expanded_groups.where(require_two_factor_authentication: true)
  end

  def source_groups_of_two_factor_authentication_requirement
    Gitlab::ObjectHierarchy.new(expanded_groups_requiring_two_factor_authentication)
      .all_objects
      .where(id: groups)
  end

  def direct_groups_with_route
    groups.with_route.order_id_asc
  end

  def first_group_paths
    first_groups = direct_groups_with_route.take(FIRST_GROUP_PATHS_LIMIT + 1)

    return if first_groups.count > FIRST_GROUP_PATHS_LIMIT

    first_groups.map(&:full_path).sort!
  end

  # rubocop: disable CodeReuse/ServiceClass
  def refresh_authorized_projects(source: nil)
    Users::RefreshAuthorizedProjectsService.new(self, source: source).execute
  end
  # rubocop: enable CodeReuse/ServiceClass

  def authorized_projects(min_access_level = nil)
    # We're overriding an association, so explicitly call super with no
    # arguments or it would be passed as `force_reload` to the association
    projects = super()

    if min_access_level
      projects = projects
        .where('project_authorizations.access_level >= ?', min_access_level)
    end

    projects
  end

  def authorized_project?(project, min_access_level = nil)
    authorized_projects(min_access_level).exists?(id: project.id)
  end

  # Typically used in conjunction with projects table to get projects
  # a user has been given access to.
  # The param `related_project_column` is the column to compare to the
  # project_authorizations. By default is projects.id
  #
  # Example use:
  # `Project.where('EXISTS(?)', user.authorizations_for_projects)`
  def authorizations_for_projects(min_access_level: nil, related_project_column: 'projects.id')
    authorizations = project_authorizations
                      .select(1)
                      .where("project_authorizations.project_id = #{related_project_column}")

    return authorizations unless min_access_level.present?

    authorizations.where('project_authorizations.access_level >= ?', min_access_level)
  end

  def owned_projects
    @owned_projects ||= Project.from_union(
      [
        Project.where(namespace: namespace),
        Project.joins(:project_authorizations)
          .where.not('projects.namespace_id' => namespace.id)
          .where(project_authorizations: { user_id: id, access_level: Gitlab::Access::OWNER })
      ],
      remove_duplicates: false
    )
  end

  # Returns projects which user can admin issues on (for example to move an issue to that project).
  #
  # This logic is duplicated from `Ability#project_abilities` into a SQL form.
  def projects_where_can_admin_issues
    authorized_projects(Gitlab::Access::PLANNER).non_archived.with_issues_enabled
  end

  # rubocop: disable CodeReuse/ServiceClass
  def require_ssh_key?
    count = Users::KeysCountService.new(self).count

    count == 0 && Gitlab::ProtocolAccess.allowed?('ssh')
  end
  # rubocop: enable CodeReuse/ServiceClass

  def require_password_creation_for_web?
    allow_password_authentication_for_web? && password_automatically_set?
  end

  def require_password_creation_for_git?
    allow_password_authentication_for_git? && password_automatically_set?
  end

  def require_personal_access_token_creation_for_git_auth?
    return false if allow_password_authentication_for_git? || password_based_omniauth_user?

    PersonalAccessTokensFinder.new(user: self, impersonation: false, state: 'active').execute.none?
  end

  def require_extra_setup_for_git_auth?
    require_password_creation_for_git? || require_personal_access_token_creation_for_git_auth?
  end

  def allow_password_authentication?
    allow_password_authentication_for_web? || allow_password_authentication_for_git?
  end

  def allow_password_authentication_for_web?
    return false if ldap_user?
    return false if disable_password_authentication_for_sso_users?

    Gitlab::CurrentSettings.password_authentication_enabled_for_web?
  end

  def allow_password_authentication_for_git?
    return false if password_based_omniauth_user?
    return false if disable_password_authentication_for_sso_users?

    Gitlab::CurrentSettings.password_authentication_enabled_for_git?
  end

  def can_change_username?
    gitlab_config.username_changing_enabled
  end

  def can_create_project?
    projects_limit_left > 0 && allow_user_to_create_group_and_project?
  end

  def allow_user_to_create_group_and_project?
    return true if Gitlab::CurrentSettings.allow_project_creation_for_guest_and_below
    return true if can_admin_all_resources?

    highest_role > Gitlab::Access::GUEST
  end

  def can_create_group?
    can?(:create_group)
  end

  def can_leave_group?(group)
    can?(:destroy_group_member, group.member(self))
  end

  def can_select_namespace?
    has_groups_allowing_project_creation? || admin
  end

  def can?(action, subject = :global, **opts)
    Ability.allowed?(self, action, subject, **opts)
  end

  def confirm_deletion_with_password?
    !password_automatically_set? && allow_password_authentication?
  end

  def first_name
    read_attribute(:first_name) || begin
      name.split(' ').first unless name.blank?
    end
  end

  def last_name
    read_attribute(:last_name) || begin
      name.split(' ').drop(1).join(' ') unless name.blank?
    end
  end

  def color_mode_id
    return Gitlab::ColorModes::APPLICATION_DARK if theme_id == 11

    read_attribute(:color_mode_id)
  end

  def projects_limit_left
    projects_limit - personal_projects_count
  end

  # rubocop: disable CodeReuse/ServiceClass
  def recent_push(project = nil)
    service = Users::LastPushEventService.new(self)

    if project
      service.last_event_for_project(project)
    else
      service.last_event_for_user
    end
  end
  # rubocop: enable CodeReuse/ServiceClass

  def namespace_id
    namespace.try :id
  end

  def already_forked?(project)
    !!fork_of(project)
  end

  def fork_of(project)
    namespace.find_fork_of(project)
  end

  def password_based_omniauth_user?
    ldap_user? || crowd_user?
  end

  def crowd_user?
    if identities.loaded?
      identities.find { |identity| identity.provider == 'crowd' && identity.extern_uid.present? }
    else
      identities.with_any_extern_uid('crowd').exists?
    end
  end

  def ldap_user?
    if identities.loaded?
      identities.find { |identity| Gitlab::Auth::OAuth::Provider.ldap_provider?(identity.provider) && !identity.extern_uid.nil? }
    else
      identities.exists?(["provider LIKE ? AND extern_uid IS NOT NULL", "ldap%"])
    end
  end

  def ldap_identity
    @ldap_identity ||= identities.find_by(["provider LIKE ?", "ldap%"])
  end

  def matches_identity?(provider, extern_uid)
    identities.with_extern_uid(provider, extern_uid).exists?
  end

  def project_deploy_keys
    @project_deploy_keys ||= DeployKey.in_projects(authorized_projects.select(:id)).distinct(:id)
  end

  def highest_role
    user_highest_role&.highest_access_level || Gitlab::Access::NO_ACCESS
  end

  def credit_card_validated_at
    credit_card_validation&.credit_card_validated_at
  end

  def accessible_deploy_keys
    DeployKey.from_union(
      [
        DeployKey.where(id: project_deploy_keys.select(:deploy_key_id)),
        DeployKey.are_public
      ])
  end

  def sanitize_attrs
    sanitize_name
  end

  def sanitize_name
    return unless self.name

    self.name = self.name.gsub(%r{(?:</?[^>]*>|<|>)}, '-')
  end

  def unset_secondary_emails_matching_deleted_email!(deleted_email)
    secondary_email_attribute_changed = false
    SECONDARY_EMAIL_ATTRIBUTES.each do |attribute|
      if read_attribute(attribute) == deleted_email
        self.write_attribute(attribute, nil)
        secondary_email_attribute_changed = true
      end
    end
    save if secondary_email_attribute_changed
  end

  def admin_unsubscribe!
    update_column :admin_email_unsubscribed_at, Time.current
  end

  def set_projects_limit
    # `User.select(:id)` raises
    # `ActiveModel::MissingAttributeError: missing attribute: projects_limit`
    # without this safeguard!
    return unless has_attribute?(:projects_limit) && projects_limit.nil?

    self.projects_limit = Gitlab::CurrentSettings.default_projects_limit
  end

  def requires_ldap_check?
    if !Gitlab.config.ldap.enabled
      false
    elsif ldap_user?
      !last_credential_check_at || (last_credential_check_at + ldap_sync_time).past?
    else
      false
    end
  end

  def ldap_sync_time
    # This number resides in this method so it can be redefined in EE.
    1.hour
  end

  def try_obtain_ldap_lease
    # After obtaining this lease LDAP checks will be blocked for 600 seconds
    # (10 minutes) for this user.
    lease = Gitlab::ExclusiveLease.new("user_ldap_check:#{id}", timeout: 600)
    lease.try_obtain
  end

  def solo_owned_groups
    # For each owned group, count the owners found in self and ancestors.
    counts = GroupMember
      .from('unnest(namespaces.traversal_ids) AS ancestors(ancestor_id), members')
      .where('members.source_id = ancestors.ancestor_id')
      .all_by_access_level(GroupMember::OWNER)
      .having('count(members.user_id) = 1')

    Group
      .from(owned_groups, :namespaces)
      .where_exists(counts)
  end

  # All organizations that are owned by this user, and only this user.
  def solo_owned_organizations
    ownerships_cte = Gitlab::SQL::CTE.new(:ownerships, organization_users.owners, materialized: false)

    owned_orgs_from_cte = Organizations::Organization
      .joins('INNER JOIN ownerships ON ownerships.organization_id = organizations.id')

    counts = Organizations::OrganizationUser
      .owners
      .where('organization_users.organization_id = organizations.id')
      .group(:organization_id)
      .having('count(organization_users.user_id) = 1')

    Organizations::Organization
      .with(ownerships_cte.to_arel)
      .from(owned_orgs_from_cte, :organizations)
      .where_exists(counts)
  end

  def can_leave_project?(project)
    project.namespace != namespace &&
      project.member(self)
  end

  def full_website_url
    return "http://#{website_url}" unless %r{\Ahttps?://}.match?(website_url)

    website_url
  end

  def short_website_url
    website_url.sub(%r{\Ahttps?://}, '')
  end

  def all_ssh_keys
    keys.map(&:publishable_key)
  end

  def temp_oauth_email?
    email.start_with?('temp-email-for-oauth')
  end

  # rubocop: disable CodeReuse/ServiceClass
  def avatar_url(size: nil, scale: 2, **args)
    GravatarService.new.execute(email, size, scale, username: username)
  end
  # rubocop: enable CodeReuse/ServiceClass

  def primary_email_verified?
    return false unless confirmed? && !temp_oauth_email?

    !email_changed? || new_record?
  end

  def accept_pending_invitations!
    pending_invitations.select do |member|
      member.accept_invite!(self)
    end
  end

  def pending_invitations
    Members::PendingInvitationsFinder.new(verified_emails).execute
  end

  def all_emails(include_private_email: true)
    all_emails = []
    all_emails << email unless temp_oauth_email?
    all_emails << private_commit_email if include_private_email
    all_emails.concat(emails.filter_map { |email| email.email if email.confirmed? })
    all_emails.uniq
  end

  def verified_emails(include_private_email: true)
    verified_emails = []
    verified_emails << email if primary_email_verified?
    verified_emails << private_commit_email if include_private_email
    verified_emails.concat(
      emails.loaded? ? emails.select(&:confirmed?).pluck(:email) : emails.confirmed.pluck(:email)
    )
    verified_emails.uniq
  end

  def verified_detumbled_emails
    emails.distinct.confirmed.pluck(:detumbled_email).compact
  end

  def public_verified_emails
    strong_memoize(:public_verified_emails) do
      emails = verified_emails(include_private_email: false)
      emails << email unless temp_oauth_email?
      emails.uniq
    end
  end

  def any_email?(check_email)
    downcased = check_email.downcase

    # handle the outdated private commit email case
    return true if persisted? &&
      id == Gitlab::PrivateCommitEmail.user_id_for_email(downcased)

    all_emails.include?(check_email.downcase)
  end

  def verified_email?(check_email)
    downcased = check_email.downcase

    # handle the outdated private commit email case
    return true if persisted? &&
      id == Gitlab::PrivateCommitEmail.user_id_for_email(downcased)

    verified_emails.include?(check_email.downcase)
  end

  def hook_attrs
    {
      id: id,
      name: name,
      username: username,
      avatar_url: avatar_url(only_path: false),
      email: webhook_email
    }
  end

  def ensure_namespace_correct
    if namespace
      namespace.path = username if username_changed?
      namespace.name = name if name_changed?
    end
  end

  def assign_personal_namespace(organization)
    return namespace if namespace

    namespace_attributes = { path: username, name: name }

    if organization
      namespace_attributes[:organization] = organization
      namespace_attributes[:visibility_level] = organization.visibility_level
    end

    build_namespace(namespace_attributes)
    namespace.build_namespace_settings

    namespace
  end

  def set_username_errors
    namespace_path_errors = self.errors.delete(:"namespace.path")

    return unless namespace_path_errors&.any?

    if namespace_path_errors.include?('has already been taken') && !User.exists?(username: username)
      self.errors.add(:base, :username_exists_as_a_different_namespace)
    else
      namespace_path_errors.each do |msg|
        # Already handled by username validation.
        next if msg.ends_with?('is a reserved name')

        self.errors.add(:username, msg)
      end
    end
  end

  def username_changed_hook
    system_hook_service.execute_hooks_for(self, :rename)
  end

  def post_destroy_hook
    log_info("User \"#{name}\" (#{email})  was removed")

    system_hook_service.execute_hooks_for(self, :destroy)
  end

  # rubocop: disable CodeReuse/ServiceClass
  def remove_key_cache
    Users::KeysCountService.new(self).delete_cache
  end
  # rubocop: enable CodeReuse/ServiceClass

  DELETION_DELAY_IN_DAYS = 7.days

  def delete_async(deleted_by:, params: {})
    if should_delay_delete?(deleted_by)
      new_note = format(_("User deleted own account on %{timestamp}"), timestamp: Time.zone.now)
      self.note = "#{new_note}\n#{note}".strip
      UserCustomAttribute.set_deleted_own_account_at(self)

      block_or_ban
      DeleteUserWorker.perform_in(DELETION_DELAY_IN_DAYS, deleted_by.id, id, params.to_h)

      return
    end

    block if params[:hard_delete]

    DeleteUserWorker.perform_async(deleted_by.id, id, params.to_h)
  end

  # rubocop: disable CodeReuse/ServiceClass
  def notification_service
    NotificationService.new
  end
  # rubocop: enable CodeReuse/ServiceClass

  def log_info(message)
    Gitlab::AppLogger.info message
  end

  # rubocop: disable CodeReuse/ServiceClass
  def system_hook_service
    SystemHooksService.new
  end
  # rubocop: enable CodeReuse/ServiceClass

  def starred?(project)
    starred_projects.exists?(project.id)
  end

  def toggle_star(project)
    UsersStarProject.transaction do
      user_star_project = users_star_projects
          .where(project: project, user: self).lock(true).first

      if user_star_project
        user_star_project.destroy
      else
        UsersStarProject.create!(project: project, user: self)
      end
    end
  end

  def following?(user)
    self.followees.exists?(user.id)
  end

  def followed_by?(user)
    self.followers.include?(user)
  end

  def follow(user)
    return false unless following_users_allowed?(user)

    begin
      followee = Users::UserFollowUser.create(follower_id: self.id, followee_id: user.id)
      self.followees.reset if followee.persisted?
      followee
    rescue ActiveRecord::RecordNotUnique
      nil
    end
  end

  def following_users_allowed?(user)
    return false if self.id == user.id

    enabled_following && user.enabled_following
  end

  def has_groups_allowing_project_creation?
    groups_allowing_project_creation.exists?
  end

  def forkable_namespaces
    strong_memoize(:forkable_namespaces) do
      personal_namespace = Namespace.where(id: namespace_id)

      Namespace.from_union(
        [
          groups_allowing_project_creation,
          personal_namespace
        ])
    end
  end

  def manageable_groups(include_groups_with_developer_access: false)
    owned_and_maintainer_group_hierarchy = owned_or_maintainers_groups.self_and_descendants

    if include_groups_with_developer_access
      union_sql = ::Gitlab::SQL::Union.new(
        [owned_and_maintainer_group_hierarchy,
          groups_with_developer_project_access]).to_sql

      ::Group.from("(#{union_sql}) #{::Group.table_name}")
    else
      owned_and_maintainer_group_hierarchy
    end
  end

  def namespaces(owned_only: false)
    user_groups = owned_only ? owned_groups : groups
    personal_namespace = Namespace.where(id: namespace.id)

    Namespace.from_union([user_groups, personal_namespace])
  end

  def oauth_authorized_tokens
    OauthAccessToken.where(resource_owner_id: id, revoked_at: nil)
  end

  # Returns the projects a user contributed to in the last year.
  #
  # This method relies on a subquery as this performs significantly better
  # compared to a JOIN when coupled with, for example,
  # `Project.visible_to_user`. That is, consider the following code:
  #
  #     some_user.contributed_projects.visible_to_user(other_user)
  #
  # If this method were to use a JOIN the resulting query would take roughly 200
  # ms on a database with a similar size to GitLab.com's database. On the other
  # hand, using a subquery means we can get the exact same data in about 40 ms.
  def contributed_projects
    events = Event.select(:project_id)
      .contributions.where(author_id: self)
      .created_after(Time.current - 1.year)
      .distinct
      .reorder(nil)

    Project.where(id: events).not_aimed_for_deletion
  end

  # Returns true if the user can be removed, false otherwise.
  # A user can be removed if they do not own any groups or organizations where they are the sole owner
  # Method `none?` is used to ensure faster retrieval, See https://gitlab.com/gitlab-org/gitlab/-/issues/417105

  def can_be_removed?
    return solo_owned_groups.none? && solo_owned_organizations.none? if Feature.enabled?(:ui_for_organizations)

    solo_owned_groups.none?
  end

  def can_remove_self?
    true
  end

  def authorized_project_mirrors(level)
    projects = Ci::ProjectMirror.by_project_id(ci_project_ids_for_project_members(level))

    namespace_projects = Ci::ProjectMirror.by_namespace_id(ci_namespace_mirrors_for_group_members(level).select(:namespace_id))

    Ci::ProjectMirror.from_union([projects, namespace_projects])
  end

  # Lists runners that are available to the user
  # (group runners assigned to groups where the user has owner access to
  # and project runners assigned to projects the user has maintainer access to)
  def ci_available_runners
    @ci_available_runners ||=
      if Feature.enabled?(:optimize_ci_owned_project_runners_query, self)
        Ci::Runner.from_union([ci_available_project_runners, ci_available_group_runners])
      else
        Ci::Runner.from_union([
          ci_available_project_runners_from_project_members,
          ci_available_project_runners_from_group_members,
          ci_available_group_runners
        ])
      end
  end

  def notification_email_for(notification_group)
    # Return group-specific email address if present, otherwise return global notification email address
    group_email = if notification_settings.loaded?
                    closest_notification_email_in_group_hierarchy(notification_group)
                  elsif notification_group && notification_group.respond_to?(:notification_email_for)
                    notification_group.notification_email_for(self)
                  end

    group_email || notification_email_or_default
  end

  def notification_settings_for(source, inherit: false)
    if notification_settings.loaded?
      notification_setting_find_by_source(source)
    else
      notification_setting_find_or_initialize_by_source(source, inherit)
    end
  end

  def notification_settings_for_groups(groups)
    ids = groups.is_a?(ActiveRecord::Relation) ? groups.select(:id) : groups.map(&:id)
    notification_settings.for_groups.where(source_id: ids)
  end

  # Lazy load global notification setting
  # Initializes User setting with Participating level if setting not persisted
  def global_notification_setting
    return @global_notification_setting if defined?(@global_notification_setting)

    # lookup in preloaded notification settings first, before making another query
    if notification_settings.loaded?
      @global_notification_setting = notification_settings.find do |notification|
        notification.source_id.nil? && notification.source_type.nil?
      end

      return @global_notification_setting if @global_notification_setting.present?
    end

    @global_notification_setting = notification_settings.find_or_initialize_by(source: nil)
    @global_notification_setting.update(level: NotificationSetting.levels[DEFAULT_NOTIFICATION_LEVEL]) unless @global_notification_setting.persisted?

    @global_notification_setting
  end

  # Returns the notification_setting of the lowest group in hierarchy with non global level
  def closest_non_global_group_notification_setting(group)
    return unless group

    notification_level = NotificationSetting.levels[:global]

    if notification_settings.loaded?
      group.self_and_ancestors_asc.find do |group|
        notification_setting = notification_setting_find_by_source(group)

        next unless notification_setting
        next if NotificationSetting.levels[notification_setting&.level] == notification_level
        break notification_setting if notification_setting.present?
      end
    else
      group.notification_settings(hierarchy_order: :asc).where(user: self).where.not(level: notification_level).first
    end
  end

  def merge_request_dashboard_enabled?
    Feature.enabled?(:merge_request_dashboard, self, type: :beta)
  end

  def assigned_open_merge_requests_count(force: false, cached_only: false)
    Rails.cache.fetch(['users', id, 'assigned_open_merge_requests_count', merge_request_dashboard_enabled?], force: force, expires_in: COUNT_CACHE_VALIDITY_PERIOD, skip_nil: true) do
      return if cached_only # rubocop:disable Cop/AvoidReturnFromBlocks -- return from method to prevent caching nil when only reading cache

      params = { state: 'opened', non_archived: true }

      if merge_request_dashboard_enabled?
        params = params.merge(include_assigned: true, author_id: id, or: { reviewer_wildcard: 'none', review_states: %w[reviewed requested_changes], only_reviewer_username: ::Users::Internal.duo_code_review_bot.username })
      else
        params[:assignee_id] = id
      end

      begin
        MergeRequestsFinder.new(self, params).execute.count
      # rubocop:disable Database/RescueStatementTimeout, Database/RescueQueryCanceled -- Expensive query can throw 500 error, temporary while the query gets improved
      rescue ActiveRecord::StatementTimeout, ActiveRecord::QueryCanceled => e
        # rubocop:enable Database/RescueStatementTimeout, Database/RescueQueryCanceled
        Gitlab::AppLogger.error(
          message: 'Timeout counting assigned merge requests',
          user_id: id,
          error: e.message
        )

        nil
      end
    end
  end

  def review_requested_open_merge_requests_count(force: false, cached_only: false)
    Rails.cache.fetch(['users', id, 'review_requested_open_merge_requests_count', merge_request_dashboard_enabled?], force: force, expires_in: COUNT_CACHE_VALIDITY_PERIOD) do
      return if cached_only # rubocop:disable Cop/AvoidReturnFromBlocks -- return from method to prevent caching nil when only reading cache

      params = { reviewer_id: id, state: 'opened', non_archived: true }
      params[:review_states] = %w[unapproved unreviewed review_started] if merge_request_dashboard_enabled?

      MergeRequestsFinder.new(self, params).execute.count
    end
  end

  def assigned_open_issues_count(force: false)
    Rails.cache.fetch(['users', id, 'assigned_open_issues_count'], force: force, expires_in: COUNT_CACHE_VALIDITY_PERIOD) do
      IssuesFinder.new(self, assignee_id: self.id, state: 'opened', non_archived: true).execute.count
    end
  end

  def todos_pending_count(force: false)
    Rails.cache.fetch(['users', id, 'todos_pending_count'], force: force, expires_in: COUNT_CACHE_VALIDITY_PERIOD) do
      TodosFinder.new(users: self, state: :pending).execute.count
    end
  end

  def personal_projects_count(force: false)
    Rails.cache.fetch(['users', id, 'personal_projects_count'], force: force, expires_in: 24.hours, raw: true) do
      personal_projects.count
    end.to_i
  end

  def update_todos_count_cache
    todos_pending_count(force: true)
  end

  def invalidate_cache_counts
    invalidate_issue_cache_counts
    invalidate_merge_request_cache_counts
    invalidate_todos_cache_counts
    invalidate_personal_projects_count
  end

  def invalidate_issue_cache_counts
    Rails.cache.delete(['users', id, 'assigned_open_issues_count'])
    Rails.cache.delete(['users', id, 'max_assigned_open_issues_count'])
  end

  def invalidate_merge_request_cache_counts
    Rails.cache.delete(['users', id, 'assigned_open_merge_requests_count', merge_request_dashboard_enabled?])
    Rails.cache.delete(['users', id, 'review_requested_open_merge_requests_count', merge_request_dashboard_enabled?])
  end

  def invalidate_todos_cache_counts
    Rails.cache.delete(['users', id, 'todos_pending_count'])
  end

  def invalidate_personal_projects_count
    Rails.cache.delete(['users', id, 'personal_projects_count'])
  end

  def invalidate_authored_todo_user_pending_todo_cache_counts
    # Invalidate the todo cache counts for other users with pending todos authored by the user
    cache_keys = authored_todos.pending.distinct.pluck(:user_id).map { |id| ['users', id, 'todos_pending_count'] }
    Gitlab::Instrumentation::RedisClusterValidator.allow_cross_slot_commands do
      Rails.cache.delete_multi(cache_keys)
    end
  end

  # This is copied from Devise::Models::Lockable#valid_for_authentication?, as our auth
  # flow means we don't call that automatically (and can't conveniently do so).
  #
  # See:
  #   <https://github.com/plataformatec/devise/blob/v4.7.1/lib/devise/models/lockable.rb#L104>
  #
  # rubocop: disable CodeReuse/ServiceClass
  def increment_failed_attempts!
    return if ::Gitlab::Database.read_only?

    increment_failed_attempts

    if attempts_exceeded?
      lock_access! unless access_locked?
    else
      Users::UpdateService.new(self, user: self).execute(validate: false)
    end
  end
  # rubocop: enable CodeReuse/ServiceClass

  def access_level
    if admin?
      :admin
    else
      :regular
    end
  end

  def access_level=(new_level)
    new_level = new_level.to_s
    return unless %w[admin regular].include?(new_level)

    self.admin = (new_level == 'admin')
  end

  def can_read_all_resources?
    can?(:read_all_resources)
  end

  def can_admin_all_resources?
    can?(:admin_all_resources)
  end

  def owns_organization?(organization)
    strong_memoize_with(:owns_organization, organization) do
      break false unless organization

      organization_id = organization.is_a?(Integer) ? organization : organization.id

      organization_users.where(organization_id: organization_id).owner.exists?
    end
  end

  def can_admin_organization?(organization)
    can?(:admin_organization, organization)
  end

  def update_two_factor_requirement
    periods = expanded_groups_requiring_two_factor_authentication.pluck(:two_factor_grace_period)

    self.require_two_factor_authentication_from_group = periods.any?
    self.two_factor_grace_period = periods.min || User.column_defaults['two_factor_grace_period']

    save
  end

  # each existing user needs to have a `feed_token`.
  # we do this on read since migrating all existing users is not a feasible
  # solution.
  def feed_token
    ensure_feed_token! unless Gitlab::CurrentSettings.disable_feed_token
  end

  # Each existing user needs to have a `static_object_token`.
  # We do this on read since migrating all existing users is not a feasible
  # solution.
  def static_object_token
    ensure_static_object_token!
  end

  def enabled_static_object_token
    static_object_token if Gitlab::CurrentSettings.static_objects_external_storage_enabled?
  end

  def enabled_incoming_email_token
    incoming_email_token if Gitlab::Email::IncomingEmail.supports_issue_creation?
  end

  def sync_attribute?(attribute)
    return true if ldap_user? && attribute == :email

    attributes = Gitlab.config.omniauth.sync_profile_attributes

    if attributes.is_a?(Array)
      attributes.include?(attribute.to_s)
    else
      attributes
    end
  end

  def read_only_attribute?(attribute)
    user_synced_attributes_metadata&.read_only?(attribute)
  end

  # override, from Devise
  def lock_access!(opts = {})
    Gitlab::AppLogger.info("Account Locked: username=#{username}")
    audit_lock_access(reason: opts.delete(:reason))
    super
  end

  # override, from Devise
  def unlock_access!(unlocked_by: self)
    audit_unlock_access(author: unlocked_by)

    super()
  end

  # Determine the maximum access level for a group of projects in bulk.
  #
  # Returns a Hash mapping project ID -> maximum access level.
  def max_member_access_for_project_ids(project_ids)
    Gitlab::SafeRequestLoader.execute(
      resource_key: max_member_access_for_resource_key(Project),
      resource_ids: project_ids,
      default_value: Gitlab::Access::NO_ACCESS
    ) do |project_ids|
      project_authorizations.where(project: project_ids)
                            .group(:project_id)
                            .maximum(:access_level)
    end
  end

  def max_member_access_for_project(project_id)
    max_member_access_for_project_ids([project_id])[project_id]
  end

  # Determine the maximum access level for a group of groups in bulk.
  #
  # Returns a Hash mapping project ID -> maximum access level.
  def max_member_access_for_group_ids(group_ids)
    Gitlab::SafeRequestLoader.execute(
      resource_key: max_member_access_for_resource_key(Group),
      resource_ids: group_ids,
      default_value: Gitlab::Access::NO_ACCESS
    ) do |group_ids|
      group_members.where(source: group_ids).group(:source_id).maximum(:access_level)
    end
  end

  def max_member_access_for_group(group_id)
    max_member_access_for_group_ids([group_id])[group_id]
  end

  def terms_accepted?
    return true if project_bot? || service_account? || security_policy_bot? || import_user?

    if Feature.enabled?(:enforce_acceptance_of_changed_terms)
      !!ApplicationSetting::Term.latest&.accepted_by_user?(self)
    else
      accepted_term_id.present?
    end
  end

  def required_terms_not_accepted?
    Gitlab::CurrentSettings.current_application_settings.enforce_terms? &&
      !terms_accepted?
  end

  def requires_usage_stats_consent?
    self.admin? && 7.days.ago > self.created_at && !has_current_license? && User.single_user? && !consented_usage_stats?
  end

  # Avoid migrations only building user preference object when needed.
  def user_preference
    super.presence || build_user_preference
  end

  def pending_todo_for(target)
    todos.find_by(target: target, state: :pending)
  end

  def password_expired?
    !!(password_expires_at && password_expires_at.past?)
  end

  def password_expired_if_applicable?
    return false if bot?
    return false unless password_expired?
    return false if password_automatically_set?
    return false unless allow_password_authentication?

    true
  end

  def can_log_in_with_non_expired_password?
    can?(:log_in) && !password_expired_if_applicable?
  end

  def can_be_deactivated?
    active? && no_recent_activity? && !internal?
  end

  def last_active_at
    last_activity = last_activity_on&.to_time&.in_time_zone
    last_sign_in = current_sign_in_at

    [last_activity, last_sign_in].compact.max
  end

  def dismissed_callout?(feature_name:, ignore_dismissal_earlier_than: nil)
    callout = callouts_by_feature_name[feature_name]

    callout_dismissed?(callout, ignore_dismissal_earlier_than)
  end

  def dismissed_callout_for_group?(feature_name:, group:, ignore_dismissal_earlier_than: nil)
    source_feature_name = "#{feature_name}_#{group.id}"
    callout = group_callouts_by_feature_name[source_feature_name]

    callout_dismissed?(callout, ignore_dismissal_earlier_than)
  end

  def dismissed_callout_for_project?(feature_name:, project:, ignore_dismissal_earlier_than: nil)
    callout = project_callouts.find_by(feature_name: feature_name, project: project)

    callout_dismissed?(callout, ignore_dismissal_earlier_than)
  end

  # Load the current highest access by looking directly at the user's memberships
  def current_highest_access_level
    members.non_request.maximum(:access_level)
  end

  def confirmation_required_on_sign_in?
    return false if confirmed?

    if ::Gitlab::CurrentSettings.email_confirmation_setting_off?
      false
    elsif ::Gitlab::CurrentSettings.email_confirmation_setting_soft?
      !in_confirmation_period?
    elsif ::Gitlab::CurrentSettings.email_confirmation_setting_hard?
      true
    end
  end

  def impersonated?
    impersonator.present?
  end

  def created_recently?
    created_at > Devise.confirm_within.ago
  end

  def find_or_initialize_callout(feature_name)
    callouts.find_or_initialize_by(feature_name: ::Users::Callout.feature_names[feature_name])
  end

  def find_or_initialize_group_callout(feature_name, group_id)
    group_callouts
      .find_or_initialize_by(feature_name: ::Users::GroupCallout.feature_names[feature_name], group_id: group_id)
  end

  def find_or_initialize_project_callout(feature_name, project_id)
    project_callouts
      .find_or_initialize_by(feature_name: ::Users::ProjectCallout.feature_names[feature_name], project_id: project_id)
  end

  def can_trigger_notifications?
    confirmed? && !blocked? && !ghost?
  end

  # This attribute hosts a Ci::JobToken::Scope object which is set when
  # the user is authenticated successfully via CI_JOB_TOKEN.
  def ci_job_token_scope
    Gitlab::SafeRequestStore[ci_job_token_scope_cache_key]
  end

  def set_ci_job_token_scope!(job)
    Gitlab::SafeRequestStore[ci_job_token_scope_cache_key] = Ci::JobToken::Scope.new(job.project)
  end

  def from_ci_job_token?
    ci_job_token_scope.present?
  end

  def user_project
    strong_memoize(:user_project) do
      personal_projects.find_by(path: username, visibility_level: Gitlab::VisibilityLevel::PUBLIC)
    end
  end

  def user_readme
    strong_memoize(:user_readme) do
      user_project&.repository&.readme
    end
  end

  def account_age_in_days
    (Date.current - created_at.to_date).to_i
  end

  def webhook_email
    public_email.presence || _('[REDACTED]')
  end

  def namespace_commit_email_for_project(project)
    return if project.nil?

    namespace_commit_emails.find_by(namespace: project.project_namespace) ||
      namespace_commit_emails.find_by(namespace: project.root_namespace)
  end

  def abuse_metadata
    {
      account_age: account_age_in_days,
      two_factor_enabled: two_factor_enabled? ? 1 : 0
    }
  end

  def trusted?
    trusted_with_spam_attribute.present?
  end

  def namespace_commit_email_for_namespace(namespace)
    return if namespace.nil?

    namespace_commit_emails.find_by(namespace: namespace)
  end

  def deleted_own_account?
    custom_attributes.by_key(UserCustomAttribute::DELETED_OWN_ACCOUNT_AT).exists?
  end

  def supports_saved_replies?
    true
  end

  def uploads_sharding_key
    {}
  end

  def add_admin_note(new_note)
    self.note = "#{new_note}\n#{self.note}"
  end

  # rubocop: disable CodeReuse/ServiceClass
  def support_pin_data
    strong_memoize(:support_pin_data) do
      Users::SupportPin::RetrieveService.new(self).execute
    end
  end
  # rubocop: enable CodeReuse/ServiceClass

  def support_pin
    support_pin_data&.fetch(:pin, nil)
  end

  def support_pin_expires_at
    support_pin_data&.fetch(:expires_at, nil)
  end

  def can_access_admin_area?
    admin?
  end

  protected

  # override, from Devise::Validatable
  def password_required?
    return false if internal? || project_bot? || security_policy_bot? || placeholder?

    super
  end

  # override from Devise::Confirmable
  def confirmation_period_valid?
    return super if ::Gitlab::CurrentSettings.email_confirmation_setting_soft?

    # Following devise logic for method, we want to return `true`
    # See: https://github.com/heartcombo/devise/blob/ec0674523e7909579a5a008f16fb9fe0c3a71712/lib/devise/models/confirmable.rb#L191-L218
    true
  end
  alias_method :in_confirmation_period?, :confirmation_period_valid?

  # This is copied from Devise::Models::TwoFactorAuthenticatable#consume_otp!
  #
  # An OTP cannot be used more than once in a given timestep
  # Storing timestep of last valid OTP is sufficient to satisfy this requirement
  #
  # See:
  #   <https://github.com/tinfoil/devise-two-factor/blob/master/lib/devise_two_factor/models/two_factor_authenticatable.rb#L66>
  #
  def consume_otp!
    if self.consumed_timestep != current_otp_timestep
      self.consumed_timestep = current_otp_timestep
      return Gitlab::Database.read_only? ? true : save(validate: false)
    end

    false
  end

  private

  def notification_setting_find_by_source(source)
    notification_settings.find do |notification|
      notification.source_type == source.class.base_class.name && notification.source_id == source.id
    end
  end

  def closest_notification_email_in_group_hierarchy(source_group)
    return unless source_group

    source_group.self_and_ancestors_asc.find do |group|
      notification_setting = notification_setting_find_by_source(group)

      next unless notification_setting
      break notification_setting.notification_email if notification_setting.notification_email.present?
    end
  end

  def notification_setting_find_or_initialize_by_source(source, inherit)
    notification_settings.find_or_initialize_by(source: source) do |ns|
      next unless source.is_a?(Group) && inherit

      # If we're here it means we're trying to create a NotificationSetting for a group that doesn't have one.
      # Find the closest parent with a notification_setting that's not Global level, or that has an email set.
      ancestor_ns = source.notification_settings(hierarchy_order: :asc).where(user: self)
                      .find_by('level != ? OR notification_email IS NOT NULL', NotificationSetting.levels[:global])
      # Use it to seed the settings
      ns.assign_attributes(ancestor_ns&.slice(*NotificationSetting.allowed_fields))
      ns.source = source
      ns.user = self
    end
  end

  def disable_password_authentication_for_sso_users?
    ::Gitlab::CurrentSettings.disable_password_authentication_for_users_with_sso_identities? && omniauth_user?
  end

  def omniauth_user?
    identities.any?
  end

  def optional_namespace?
    Feature.enabled?(:optional_personal_namespace, self)
  end

  def block_or_ban
    user_scores = AntiAbuse::UserTrustScore.new(self)
    if user_scores.spammer? && account_age_in_days < 7
      ban_and_report
    else
      block
    end
  end

  def ban_and_report
    msg = 'Potential spammer account deletion'
    attrs = { user_id: id, reporter: Users::Internal.security_bot, category: 'spam' }
    abuse_report = AbuseReport.find_by(attrs)

    if abuse_report.nil?
      abuse_report = AbuseReport.create!(attrs.merge(message: msg))
    else
      abuse_report.update(message: "#{abuse_report.message}\n\n#{msg}")
    end

    UserCustomAttribute.set_banned_by_abuse_report(abuse_report)

    ban
  end

  def has_possible_spam_contributions?
    events
      .for_action('commented')
      .or(events.for_action('created').where(target_type: %w[Issue MergeRequest]))
      .any?
  end

  def should_delay_delete?(deleted_by)
    return false if placeholder?

    is_deleting_own_record = deleted_by.id == id

    is_deleting_own_record &&
      ::Gitlab::CurrentSettings.delay_user_account_self_deletion &&
      has_possible_spam_contributions?
  end

  def pbkdf2?
    return false unless otp_backup_codes&.any?

    otp_backup_codes.first.start_with?("$pbkdf2-sha512$")
  end

  # rubocop: disable CodeReuse/ServiceClass
  def add_primary_email_to_emails!
    Emails::CreateService.new(self, user: self, email: self.email).execute(confirmed_at: self.confirmed_at)
  end
  # rubocop: enable CodeReuse/ServiceClass

  def ci_project_ids_for_project_members(level)
    project_members.where('access_level >= ?', level).pluck(:source_id)
  end

  def notification_email_verified
    return if notification_email.blank? || temp_oauth_email?

    errors.add(:notification_email, _("must be an email you have verified")) unless verified_emails.include?(notification_email_or_default)
  end

  def update_default_organization_user
    Organizations::OrganizationUser.update_default_organization_record_for(id, user_is_admin: admin?)
  end

  def public_email_verified
    return if public_email.blank?

    errors.add(:public_email, _("must be an email you have verified")) unless verified_emails.include?(public_email)
  end

  def commit_email_verified
    return if commit_email.blank?

    errors.add(:commit_email, _("must be an email you have verified")) unless verified_emails.include?(commit_email_or_default)
  end

  def callout_dismissed?(callout, ignore_dismissal_earlier_than)
    return false unless callout
    return callout.dismissed_after?(ignore_dismissal_earlier_than) if ignore_dismissal_earlier_than

    true
  end

  def callouts_by_feature_name
    @callouts_by_feature_name ||= callouts.index_by(&:feature_name)
  end

  def group_callouts_by_feature_name
    @group_callouts_by_feature_name ||= group_callouts.index_by(&:source_feature_name)
  end

  def has_current_license?
    false
  end

  def consented_usage_stats?
    # Bypass the cache here because it's possible the admin enabled the
    # usage ping, and we don't want to annoy the user again if they
    # already set the value. This is a bit of hack, but the alternative
    # would be to put in a more complex cache invalidation step. Since
    # this call only gets called in the uncommon situation where the
    # user is an admin and the only user in the instance, this shouldn't
    # cause too much load on the system.
    ApplicationSetting.current_without_cache&.usage_stats_set_by_user_id == self.id
  end

  def ensure_user_rights_and_limits
    if external?
      self.can_create_group = false
      self.projects_limit   = 0
    else
      # Only revert these back to the default if they weren't specifically changed in this update.
      self.can_create_group = Gitlab::CurrentSettings.can_create_group unless can_create_group_changed?
      self.projects_limit = Gitlab::CurrentSettings.default_projects_limit unless projects_limit_changed?
    end
  end

  def email_allowed_by_restrictions
    return if placeholder? || import_user? || security_policy_bot?

    error = validate_admin_signup_restrictions(email)

    errors.add(:email, error) if error
  end

  def signup_email_invalid_message
    self.new_record? ? _('is not allowed for sign-up. Please use your regular email address.') : _('is not allowed. Please use your regular email address.')
  end

  def check_username_format
    return if username.blank? || !self.class.ends_with_reserved_file_extension?(username)

    errors.add(:username, _('ending with a reserved file extension is not allowed.'))
  end

  def check_password_weakness
    if password.present? && Security::WeakPasswords.weak_for_user?(password, self)
      errors.add(:password, _('must not contain commonly used combinations of words and letters'))
    end
  end

  def groups_with_developer_project_access
    project_creation_levels = [::Gitlab::Access::DEVELOPER_PROJECT_ACCESS]

    if ::Gitlab::CurrentSettings.default_project_creation == ::Gitlab::Access::DEVELOPER_PROJECT_ACCESS
      project_creation_levels << nil
    end

    developer_groups.self_and_descendants.where(project_creation_level: project_creation_levels)
  end

  def no_recent_activity?
    last_active_at.to_i <= Gitlab::CurrentSettings.deactivate_dormant_users_period.days.ago.to_i
  end

  def update_highest_role?
    return false unless persisted?

    (previous_changes.keys & %w[state user_type]).any?
  end

  def update_highest_role_attribute
    id
  end

  def ci_job_token_scope_cache_key
    "users:#{id}:ci:job_token_scope"
  end

  # An `ldap_blocked` user will be unblocked if LDAP indicates they are allowed.
  def check_ldap_if_ldap_blocked!
    return unless ::Gitlab::Auth::Ldap::Config.enabled? && ldap_blocked?

    ::Gitlab::Auth::Ldap::Access.allowed?(self)
  end

  def ci_available_project_runners_from_project_members
    project_ids = ci_project_ids_for_project_members(Gitlab::Access::MAINTAINER)

    Ci::Runner.belonging_to_project(project_ids)
  end

  def ci_available_project_runners_from_group_members
    cte_namespace_ids = Gitlab::SQL::CTE.new(
      :cte_namespace_ids,
      ci_namespace_mirrors_for_group_members(Gitlab::Access::MAINTAINER).select(:namespace_id)
    )

    cte_project_ids = Gitlab::SQL::CTE.new(
      :cte_project_ids,
      Ci::ProjectMirror
        .select(:project_id)
        .where('ci_project_mirrors.namespace_id IN (SELECT namespace_id FROM cte_namespace_ids)')
    )

    Ci::Runner
      .with(cte_namespace_ids.to_arel)
      .with(cte_project_ids.to_arel)
      .joins(:runner_projects)
      .where('ci_runner_projects.project_id IN (SELECT project_id FROM cte_project_ids)')
  end

  def ci_available_project_runners
    project_ids = project_authorizations.where(access_level: Gitlab::Access::MAINTAINER..).pluck(:project_id)

    # track the size of project_ids to optimise this query further in future
    track_ci_available_project_runners_query(project_ids.size)

    return Ci::Runner.belonging_to_project(project_ids) if project_ids.size <= CI_RUNNERS_PROJECT_COUNT_LIMIT

    projects_with_runners = Set.new

    project_ids.each_slice(CI_PROJECT_RUNNERS_BATCH_SIZE) do |ids|
      projects_with_runners.merge(Ci::RunnerProject.existing_project_ids(ids))
    end

    Ci::Runner.belonging_to_project(projects_with_runners)
  end

  def track_ci_available_project_runners_query(size_of_project_ids)
    track_internal_event(
      'query_ci_available_project_runners_with_project_ids',
      user: self,
      additional_properties: {
        value: size_of_project_ids
      }
    )
  end

  def ci_available_group_runners
    # NOTE: `ci_available_group_runners` does not return the group runners that the user has access to in group A, when
    # the user is owner of group B and group B has been invited as owner to group A.
    # Instead it only returns group runners that belong to a group that the user is a direct owner of.
    # Ideally, we'd add a `min_access_level` argument to `User#authorized_groups`, similar to `User#authorized_projects`
    # and that would get used by `ci_available_group_runners`, but that would require deeper changes from the
    # ~"group::authorization" team.
    # NOTE: Issue captured in https://gitlab.com/gitlab-org/gitlab/-/issues/549985

    cte_namespace_ids = Gitlab::SQL::CTE.new(
      :cte_namespace_ids,
      ci_namespace_mirrors_for_group_members(Gitlab::Access::OWNER).select(:namespace_id)
    )

    Ci::Runner
      .with(cte_namespace_ids.to_arel)
      .joins(:runner_namespaces)
      .where('ci_runner_namespaces.namespace_id IN (SELECT namespace_id FROM cte_namespace_ids)')
  end

  def ci_namespace_mirrors_for_group_members(level)
    search_members = group_members.where('access_level >= ?', level)

    traversal_ids = Group.joins(:all_group_members)
      .merge(search_members)
      .shortest_traversal_ids_prefixes

    Ci::NamespaceMirror.contains_traversal_ids(traversal_ids)
  end

  def prefix_for_feed_token
    self.class.prefix_for_feed_token
  end

  def self.prefix_for_feed_token
    return FEED_TOKEN_PREFIX unless Feature.enabled?(:custom_prefix_for_all_token_types, :instance)

    ::Authn::TokenField::PrefixHelper.prepend_instance_prefix(FEED_TOKEN_PREFIX)
  end

  # method overridden in EE
  def audit_lock_access(reason: nil); end

  # method overridden in EE
  def audit_unlock_access(author: self); end

  def username_not_assigned_to_pages_unique_domain
    if ProjectSetting.unique_domain_exists?(username)
      # We cannot disclose the Pages unique domain, hence returning generic error message
      errors.add(:username, _('has already been taken'))
    end
  end

  def groups_allowing_project_creation
    Groups::AcceptingProjectCreationsFinder.new(self).execute
  end
end

User.prepend_mod_with('User')
==== /workspace/gitlab/app/models/users/banned_user.rb ====
# frozen_string_literal: true

module Users
  class BannedUser < ApplicationRecord
    include EachBatch

    self.primary_key = :user_id

    belongs_to :user
    has_one :credit_card_validation, class_name: '::Users::CreditCardValidation', primary_key: 'user_id',
      foreign_key: 'user_id', inverse_of: :banned_user
    has_many :emails, primary_key: 'user_id', foreign_key: 'user_id', inverse_of: :banned_user

    validates :user, presence: true
    validates :user_id, uniqueness: { message: N_("banned user already exists") }

    scope :by_detumbled_email, ->(email) do
      return none if email.blank?

      joins(:emails)
        .where({ emails: { detumbled_email: ::Gitlab::Utils::Email.normalize_email(email) } })
        .where.not({ emails: { confirmed_at: nil } })
    end
  end
end

Users::BannedUser.prepend_mod_with('Users::BannedUser')
==== /workspace/gitlab/app/models/users/ghost_user_migration.rb ====
# frozen_string_literal: true

module Users
  class GhostUserMigration < ApplicationRecord
    self.table_name = 'ghost_user_migrations'

    belongs_to :user
    belongs_to :initiator_user, class_name: 'User'

    validates :user_id, presence: true

    scope :consume_order, -> { order(:consume_after, :id) }
  end
end
==== /workspace/gitlab/app/models/users_star_project.rb ====
# frozen_string_literal: true

class UsersStarProject < ApplicationRecord
  include Sortable

  belongs_to :project
  belongs_to :user

  validates :user, presence: true
  validates :user_id, uniqueness: { scope: [:project_id] }
  validates :project, presence: true

  alias_attribute :starred_since, :created_at

  after_create :increment_project_star_count
  after_destroy :decrement_project_star_count

  scope :with_active_user, -> { joins(:user).merge(User.with_state(:active)) }
  scope :order_user_name_asc, -> { joins(:user).merge(User.order_name_asc) }
  scope :order_user_name_desc, -> { joins(:user).merge(User.order_name_desc) }
  scope :by_project, ->(project) { where(project_id: project.id) }
  scope :with_visible_profile, ->(user) { joins(:user).merge(User.with_visible_profile(user)) }
  scope :with_public_profile, -> { joins(:user).merge(User.with_public_profile) }
  scope :preload_users, -> { preload(:user) }

  class << self
    def sort_by_attribute(method)
      order_method = method || 'id_desc'

      case order_method.to_s
      when 'name_asc' then order_user_name_asc
      when 'name_desc' then order_user_name_desc
      else
        order_by(order_method)
      end
    end

    def search(query)
      joins(:user).merge(User.search(query, use_minimum_char_limit: false))
    end
  end

  private

  def increment_project_star_count
    Project.update_counters(project, star_count: 1) if user.active?
  end

  def decrement_project_star_count
    return unless user.active?
    return unless project.star_count > 0

    Project.update_counters(project, star_count: -1)
  end
end
==== /workspace/gitlab/app/models/users_statistics.rb ====
# frozen_string_literal: true

class UsersStatistics < ApplicationRecord
  scope :order_created_at_desc, -> { order(created_at: :desc) }

  def active
    [
      without_groups_and_projects,
      with_highest_role_guest,
      with_highest_role_planner,
      with_highest_role_reporter,
      with_highest_role_developer,
      with_highest_role_maintainer,
      with_highest_role_owner,
      bots
    ].sum
  end

  def total
    active + blocked
  end

  class << self
    def latest
      order_created_at_desc.first
    end

    def create_current_stats!
      create!(highest_role_stats)
    end

    private

    def highest_role_stats
      {
        without_groups_and_projects: without_groups_and_projects_stats,
        with_highest_role_guest: batch_count_for_access_level(Gitlab::Access::GUEST),
        with_highest_role_planner: batch_count_for_access_level(Gitlab::Access::PLANNER),
        with_highest_role_reporter: batch_count_for_access_level(Gitlab::Access::REPORTER),
        with_highest_role_developer: batch_count_for_access_level(Gitlab::Access::DEVELOPER),
        with_highest_role_maintainer: batch_count_for_access_level(Gitlab::Access::MAINTAINER),
        with_highest_role_owner: batch_count_for_access_level(Gitlab::Access::OWNER),
        bots: bot_stats,
        blocked: blocked_stats
      }
    end

    def without_groups_and_projects_stats
      batch_count_for_access_level(nil)
    end

    def bot_stats
      Gitlab::Database::BatchCount.batch_count(User.bots)
    end

    def blocked_stats
      Gitlab::Database::BatchCount.batch_count(User.blocked)
    end

    def batch_count_for_access_level(access_level)
      Gitlab::Database::BatchCount.batch_count(UserHighestRole.with_highest_access_level(access_level))
    end
  end
end

UsersStatistics.prepend_mod_with('UsersStatistics')
==== /workspace/gitlab/app/models/user_status.rb ====
# frozen_string_literal: true

class UserStatus < ApplicationRecord
  include CacheMarkdownField

  self.primary_key = :user_id

  DEFAULT_EMOJI = 'speech_balloon'

  CLEAR_STATUS_QUICK_OPTIONS = {
    '30_minutes' => 30.minutes,
    '3_hours' => 3.hours,
    '8_hours' => 8.hours,
    '1_day' => 1.day,
    '3_days' => 3.days,
    '7_days' => 7.days,
    '30_days' => 30.days
  }.freeze

  belongs_to :user, inverse_of: :status

  enum :availability, { not_set: 0, busy: 1 }

  validates :user, presence: true
  validates :emoji, 'gitlab/emoji_name': true
  validates :message, length: { maximum: 100 }, allow_blank: true

  scope :scheduled_for_cleanup, -> { where(arel_table[:clear_status_at].lteq(Time.current)) }

  cache_markdown_field :message, pipeline: :emoji

  def clear_status_after
    clear_status_at
  end

  def clear_status_after=(value)
    self.clear_status_at = CLEAR_STATUS_QUICK_OPTIONS[value]&.from_now
  end

  def customized?
    message.present? || emoji != UserStatus::DEFAULT_EMOJI
  end
end

UserStatus.prepend_mod_with('UserStatus')
==== /workspace/gitlab/app/models/users/user_follow_user.rb ====
# frozen_string_literal: true
module Users
  class UserFollowUser < ApplicationRecord
    MAX_FOLLOWEE_LIMIT = 300

    belongs_to :follower, class_name: 'User'
    belongs_to :followee, class_name: 'User'

    validate :max_follow_limit

    private

    def max_follow_limit
      followee_count = self.class.where(follower_id: follower_id).limit(MAX_FOLLOWEE_LIMIT).count
      return if followee_count < MAX_FOLLOWEE_LIMIT

      errors.add(
        :base,
        format(
          _("You can't follow more than %{limit} users. To follow more users, unfollow some others."),
          limit: MAX_FOLLOWEE_LIMIT
        )
      )
    end
  end
end
==== /workspace/gitlab/app/models/user_synced_attributes_metadata.rb ====
# frozen_string_literal: true

class UserSyncedAttributesMetadata < ApplicationRecord
  belongs_to :user

  validates :user, presence: true

  SYNCABLE_ATTRIBUTES = %i[name email location organization job_title].freeze

  def read_only?(attribute)
    sync_profile_from_provider? && synced?(attribute)
  end

  def read_only_attributes
    return [] unless sync_profile_from_provider?

    SYNCABLE_ATTRIBUTES.select { |key| synced?(key) }
  end

  def synced?(attribute)
    read_attribute("#{attribute}_synced")
  end

  def set_attribute_synced(attribute, value)
    write_attribute("#{attribute}_synced", value)
  end

  class << self
    def syncable_attributes(provider = nil)
      return SYNCABLE_ATTRIBUTES unless provider && ldap_provider?(provider)
      return SYNCABLE_ATTRIBUTES if ldap_sync_name?(provider)

      SYNCABLE_ATTRIBUTES - %i[name]
    end
  end

  private

  def sync_profile_from_provider?
    Gitlab::Auth::OAuth::Provider.sync_profile_from_provider?(provider)
  end

  class << self
    def ldap_provider?(provider)
      Gitlab::Auth::OAuth::Provider.ldap_provider?(provider)
    end

    def ldap_sync_name?(provider)
      return false unless provider

      config = Gitlab::Auth::Ldap::Config.new(provider)
      config.enabled? && config.sync_name
    end
  end
end
==== /workspace/gitlab/app/models/webauthn_registration.rb ====
# frozen_string_literal: true

# Registration information for WebAuthn credentials

class WebauthnRegistration < ApplicationRecord
  belongs_to :user

  validates :credential_xid, :public_key, :counter, presence: true
  validates :name, length: { minimum: 0, allow_nil: false }
  validates :counter,
    numericality: { only_integer: true, greater_than_or_equal_to: 0, less_than_or_equal_to: (2**32) - 1 }
end
==== /workspace/gitlab/app/models/wikis/user_mention.rb ====
# frozen_string_literal: true

module Wikis
  class UserMention < UserMention
    self.table_name = 'wiki_page_meta_user_mentions'

    belongs_to :wiki_page_meta, class_name: 'WikiPage::Meta', optional: false
    belongs_to :note, optional: false
  end
end
==== /workspace/gitlab/app/models/work_items/user_preference.rb ====
# frozen_string_literal: true

module WorkItems
  class UserPreference < ApplicationRecord
    self.table_name = 'work_item_type_user_preferences'

    belongs_to :user
    belongs_to :namespace
    belongs_to :work_item_type,
      class_name: 'WorkItems::Type',
      inverse_of: :user_preferences,
      optional: true

    validate :validate_sort_value
    validates :display_settings, json_schema: { filename: 'work_item_user_preference_display_settings' }

    def self.create_or_update(namespace:, work_item_type_id:, user:, **attributes)
      record = find_or_initialize_by(namespace: namespace, work_item_type_id: work_item_type_id, user: user)
      record.assign_attributes(**attributes)
      record.save
      record
    end

    def self.find_by_user_namespace_and_work_item_type_id(user, namespace, work_item_type_id)
      find_by(
        user: user,
        namespace: namespace,
        work_item_type_id: work_item_type_id
      )
    end

    private

    def validate_sort_value
      return if sort.blank?
      return if ::WorkItems::SortingKeys.available?(sort, widget_list: work_item_type&.widget_classes(namespace))

      message =
        if work_item_type.present?
          format(
            _('value "%{sort}" is not available on %{namespace} for work items type %{wit}'),
            sort: sort,
            namespace: namespace.full_path,
            wit: work_item_type.name
          )
        else
          format(
            _('value "%{sort}" is not available on %{namespace}'),
            sort: sort,
            namespace: namespace.full_path
          )
        end

      errors.add(:sort, message)
    end
  end
end
==== /workspace/gitlab/app/models/work_items/widgets/current_user_todos.rb ====
# frozen_string_literal: true

module WorkItems
  module Widgets
    class CurrentUserTodos < Base
      def self.quick_action_commands
        [:todo, :done]
      end

      def self.quick_action_params
        [:todo_event]
      end

      def self.process_quick_action_param(param_name, value)
        return super unless param_name == :todo_event

        { action: value == 'done' ? 'mark_as_done' : 'add' }
      end
    end
  end
end
==== /workspace/gitlab/app/services/users/email_verification/base_service.rb ====
# frozen_string_literal: true

module Users
  module EmailVerification
    class BaseService
      VALID_ATTRS = %i[unlock_token confirmation_token email_otp].freeze

      def initialize(attr:, user:)
        @attr = attr
        @user = user

        validate_attr!
      end

      protected

      attr_reader :attr, :user, :token

      def validate_attr!
        raise ArgumentError, 'Invalid attribute' unless attr.in?(VALID_ATTRS)
      end

      def digest
        Devise.token_generator.digest(User, user.email.downcase.strip, token)
      end

      def attr_value
        # Double check for defense-in-depth
        validate_attr!
        # We use public_send instead of hash access (user[attr]) to
        # support attributes provided via delegation
        user.public_send(attr) # rubocop:disable GitlabSecurity/PublicSend -- argument is checked above
      end
    end
  end
end
==== /workspace/gitlab/app/services/users/email_verification/generate_token_service.rb ====
# frozen_string_literal: true

module Users
  module EmailVerification
    class GenerateTokenService < EmailVerification::BaseService
      TOKEN_LENGTH = 6

      def execute
        @token = generate_token

        [token, digest]
      end

      private

      def generate_token
        SecureRandom.random_number(10**TOKEN_LENGTH).to_s.rjust(TOKEN_LENGTH, '0')
      end
    end
  end
end
==== /workspace/gitlab/app/services/users/email_verification/validate_token_service.rb ====
# frozen_string_literal: true

module Users
  module EmailVerification
    class ValidateTokenService < EmailVerification::BaseService
      include ActionView::Helpers::DateHelper

      TOKEN_VALID_FOR_MINUTES = 60

      def initialize(attr:, user:, token:)
        super(attr: attr, user: user)

        @token = token
      end

      def execute
        return failure(:rate_limited) if verification_rate_limited?
        return failure(:invalid) unless valid?
        return failure(:expired) if expired_token?

        success
      end

      def expired_token?
        generated_at = case attr
                       when :unlock_token then user.locked_at
                       when :confirmation_token then user.confirmation_sent_at
                       when :email_otp then user.email_otp_last_sent_at
                       end

        generated_at.nil? ||
          generated_at < TOKEN_VALID_FOR_MINUTES.minutes.ago
      end

      private

      attr_reader :user

      def verification_rate_limited?
        Gitlab::ApplicationRateLimiter.throttled?(:email_verification, scope: attr_value)
      end

      def valid?
        return false unless token.present?

        Devise.secure_compare(attr_value, digest)
      end

      def success
        { status: :success }
      end

      def failure(reason)
        {
          status: :failure,
          reason: reason,
          message: failure_message(reason)
        }
      end

      def failure_message(reason)
        case reason
        when :rate_limited
          format(s_("IdentityVerification|You've reached the maximum amount of tries. "\
             'Wait %{interval} or send a new code and try again.'), interval: email_verification_interval)
        when :expired
          s_('IdentityVerification|The code has expired. Send a new code and try again.')
        when :invalid
          s_('IdentityVerification|The code is incorrect. Enter it again, or send a new code.')
        end
      end

      def email_verification_interval
        interval_in_seconds = Gitlab::ApplicationRateLimiter.rate_limits[:email_verification][:interval]
        distance_of_time_in_words(interval_in_seconds)
      end
    end
  end
end
==== /workspace/gitlab/ee/app/controllers/admin/application_settings/scim_oauth_controller.rb ====
# frozen_string_literal: true

module Admin
  module ApplicationSettings
    class ScimOauthController < Admin::ApplicationController
      feature_category :system_access
      before_action :check_feature_available

      # rubocop: disable CodeReuse/ActiveRecord
      def create
        scim_token = ScimOauthAccessToken.find_or_initialize_by(group: nil)

        if scim_token.new_record?
          scim_token.save
        else
          scim_token.reset_token!
        end

        respond_to do |format|
          format.json do
            if scim_token.errors.empty?
              render json: scim_token.as_entity_json
            else
              render json: { errors: scim_token.errors.full_messages }, status: :unprocessable_entity
            end
          end
        end
      end

      private

      def check_feature_available
        render_404 unless License.feature_available?(:instance_level_scim)
      end
    end
  end
  # rubocop: enable CodeReuse/ActiveRecord
end
==== /workspace/gitlab/ee/app/controllers/concerns/ee/authenticates_with_two_factor.rb ====
# frozen_string_literal: true

module EE
  module AuthenticatesWithTwoFactor
    extend ::Gitlab::Utils::Override

    override :log_failed_two_factor
    def log_failed_two_factor(user, method)
      ::Authn::UnauthenticatedSecurityEventAuditor.new(user, method).execute
    end
  end
end
==== /workspace/gitlab/ee/app/controllers/concerns/ee/enforces_two_factor_authentication.rb ====
# frozen_string_literal: true

module EE
  module EnforcesTwoFactorAuthentication
    extend ::Gitlab::Utils::Override

    override :current_user_requires_two_factor?
    def current_user_requires_two_factor?
      super && !active_smartcard_session?
    end

    private

    def active_smartcard_session?
      return false unless ::Gitlab::Auth::Smartcard.enabled?

      return false unless current_user.smartcard_identities.any?

      ::Gitlab::Auth::Smartcard::Session.new.active?(current_user)
    end
  end
end
==== /workspace/gitlab/ee/app/controllers/concerns/saml_authorization.rb ====
# frozen_string_literal: true
module SamlAuthorization
  extend ActiveSupport::Concern

  private

  def authorize_manage_saml!
    render_404 unless can?(current_user, :admin_group_saml, group)
  end

  def check_group_saml_configured
    render_404 unless Gitlab::Auth::GroupSaml::Config.enabled?
  end

  def require_top_level_group
    render_404 if group.subgroup?
  end
end
==== /workspace/gitlab/ee/app/controllers/ee/ldap/omniauth_callbacks_controller.rb ====
# frozen_string_literal: true

module EE
  module Ldap
    module OmniauthCallbacksController
      extend ::Gitlab::Utils::Override

      override :sign_in_and_redirect
      def sign_in_and_redirect(user, *args)
        # The counter gets incremented in `sign_in_and_redirect`
        show_ldap_sync_flash if user.sign_in_count == 0

        super
      end

      override :fail_login
      def fail_login(user)
        # This is the same implementation as EE::OmniauthCallbacksController#fail_login but we need to add it here since
        # we're overriding Ldap::OmniauthCallbacksController#fail_login, not EE::OmniauthCallbacksController#fail_login.
        log_failed_login(user.username, oauth['provider'])

        super
      end

      private

      override :enqueue_after_sign_in_workers
      def enqueue_after_sign_in_workers(user, auth_user)
        return if auth_user.ldap_config.duo_add_on_groups.blank?

        ::GitlabSubscriptions::AddOnPurchases::LdapAddOnSeatSyncWorker.perform_async({ 'user_id' => user.id })
      end

      def show_ldap_sync_flash
        flash[:notice] = _('LDAP sync in progress. This could take a few minutes. '\
                         'Refresh the page to see the changes.')
      end
    end
  end
end
==== /workspace/gitlab/ee/app/controllers/ee/omniauth_callbacks_controller.rb ====
# frozen_string_literal: true

module EE
  module OmniauthCallbacksController
    extend ActiveSupport::Concern
    extend ::Gitlab::Utils::Override

    prepended do
      include ::Gitlab::RackLoadBalancingHelpers
      include ::Users::IdentityVerificationHelper
    end

    override :openid_connect
    def openid_connect
      if License.feature_available?(:oidc_client_groups_claim)
        omniauth_flow(::Gitlab::Auth::Oidc)
      else
        super
      end
    end

    private

    override :log_failed_login
    def log_failed_login(author, provider)
      unauth_author = ::Gitlab::Audit::UnauthenticatedAuthor.new(name: author)
      user = ::User.new(id: unauth_author.id, name: author)
      ::Gitlab::Audit::Auditor.audit({
        name: "omniauth_login_failed",
        author: unauth_author,
        scope: user,
        target: user,
        additional_details: {
          failed_login: provider.upcase,
          author_name: user.name,
          target_details: user.name
        },
        message: "#{provider.upcase} login failed"
      })
    end

    override :perform_registration_tasks
    def perform_registration_tasks(user, provider)
      # This also protects the sub classes group saml and ldap from staring onboarding
      # as we don't want those to onboard.
      if provider.to_sym.in?(::AuthHelper.providers_for_base_controller)
        ::Onboarding::StatusCreateService
          .new(
            request.env.fetch('omniauth.params', {}).deep_symbolize_keys,
            session['user_return_to'],
            user,
            onboarding_first_step_path(user)
          ).execute
        clear_memoization(:onboarding_status_presenter) # clear since registration_type is now set

        # We need to do this here since the subscription flow relies on what was set
        # in the stored_location_for(:user) that was set on initial redirect from
        # the GitlabSubscriptions::SubscriptionsController#new and super will wipe that out.
        # Then the RegistrationsIdentityVerificationController#success will get
        # whatever is set in super instead of the subscription path we desire.
        super unless onboarding_status_presenter.preserve_stored_location?
      else
        super
      end
    end

    override :sign_in_and_redirect_or_verify_identity
    def sign_in_and_redirect_or_verify_identity(user, auth_user, new_user)
      return super if user.blocked? # When `block_auto_created_users` is set to true
      return super unless auth_user.signup_identity_verification_enabled?(user)
      return super if !new_user && user.signup_identity_verified?

      service_class = ::Users::EmailVerification::SendCustomConfirmationInstructionsService
      service_class.new(user).execute if new_user
      session[:verification_user_id] = user.id
      load_balancer_stick_request(::User, :user, user.id)

      redirect_to signup_identity_verification_path
    end

    override :build_auth_user_params
    def build_auth_user_params
      omniauth_params = request.env.fetch('omniauth.params', {}).deep_symbolize_keys

      # This protects the sub classes group saml and ldap from adding this param. If the builder class inheritance
      # were a bit more declarative and had a base class, we could probably be a bit more declarative here and skip
      # the provider check.
      # The opt_in check may get removed in https://gitlab.com/gitlab-org/gitlab/-/merge_requests/164411.
      unless ::Onboarding.enabled? && oauth['provider'].to_sym.in?(::AuthHelper.providers_for_base_controller) &&
          omniauth_params.key?(:onboarding_status_email_opt_in)
        return super
      end

      data = super
      # We want to say that if for some reason the param is nil or not present, then we can't
      # be certain the user was ever shown this option so we should default to false to follow opt in guidelines.
      opt_in = request.env.fetch('omniauth.params', {}).deep_symbolize_keys[:onboarding_status_email_opt_in]
      data[:onboarding_status_email_opt_in] = ::Gitlab::Utils.to_boolean(opt_in, default: false)
      data
    end

    override :allowed_new_user?
    def allowed_new_user?(auth_user)
      # We need to stop new sign ups in case of restricted countries based on the user IP address
      # It should only apply for new signups, so we check if the user is new in the database.
      new_user = super

      if new_user && restricted_country?(request.env['HTTP_CF_IPCOUNTRY']) && ::Feature.enabled?(
        :restrict_sso_login_for_pipl_compliance, :instance)

        # This logger statement can be deleted while we are deleting feature flag
        ::Gitlab::AppLogger.info("Gitlab Signup via SSO failed for Region: #{request.env['HTTP_CF_IPCOUNTRY']}")

        raise ::OmniauthCallbacksController::SignUpFromRestrictedCountyError
      end

      new_user
    end

    override :set_session_active_since
    def set_session_active_since(id)
      ::Gitlab::Auth::Saml::SsoState.new(provider_id: id)
        .update_active(session_not_on_or_after: session_not_on_or_after_attribute)
    end

    override :store_redirect_to
    def store_redirect_to
      return unless ::Feature.enabled?(:ff_require_saml_auth_to_approve)

      redirect_to = request.env.dig('omniauth.params', 'redirect_to').presence
      redirect_to = sanitize_redirect redirect_to

      return unless redirect_to
      return unless valid_gitlab_initiated_saml_request?

      store_location_for :redirect, redirect_to
    end

    def saml_response
      oauth.fetch(:extra, {}).fetch(:response_object, {})
    end

    def session_not_on_or_after_attribute
      return unless saml_response.present? # response object can be nil in case authentication fails

      saml_response.session_expires_at
    end

    def valid_gitlab_initiated_saml_request?
      ::Gitlab::Auth::Saml::OriginValidator.new(session).gitlab_initiated?(saml_response)
    end
  end
end
==== /workspace/gitlab/ee/app/controllers/ee/sessions_controller.rb ====
# frozen_string_literal: true

module EE
  module SessionsController
    extend ActiveSupport::Concern
    extend ::Gitlab::Utils::Override
    include ::Gitlab::Utils::StrongMemoize

    prepended do
      include GoogleAnalyticsCSP
      include GoogleSyndicationCSP

      before_action :gitlab_geo_logout, only: [:destroy]
      prepend_before_action :detect_and_notify_for_compromised_password, only: [:create]
      prepend_before_action :complete_identity_verification, only: :create
    end

    override :new
    def new
      return super if signed_in?

      if ::Gitlab::Geo.secondary_with_primary?
        current_node_uri = URI(GeoNode.current_node_url)
        state = geo_login_state.encode
        redirect_to oauth_geo_auth_url(host: current_node_uri.host, port: current_node_uri.port, state: state)
      else
        super
      end
    end

    private

    def gitlab_geo_logout
      return unless ::Gitlab::Geo.secondary?

      # The @geo_logout_state instance variable is used within
      # ApplicationController#after_sign_out_path_for to redirect
      # the user to the logout URL on the primary after sign out
      # on the secondary.
      @geo_logout_state = geo_logout_state.encode # rubocop:disable Gitlab/ModuleWithInstanceVariables
    end

    def geo_login_state
      ::Gitlab::Geo::Oauth::LoginState.new(return_to: sanitize_redirect(geo_return_to_after_login))
    end

    def geo_logout_state
      ::Gitlab::Geo::Oauth::LogoutState.new(token: session[:access_token], return_to: geo_return_to_after_logout)
    end

    def geo_return_to_after_login
      stored_redirect_uri || ::Gitlab::Utils.append_path(root_url, session[:user_return_to].to_s)
    end

    def geo_return_to_after_logout
      safe_redirect_path_for_url(request.referer)
    end

    override :log_failed_login
    def log_failed_login
      login = request.filtered_parameters.dig('user', 'login')
      otp_user_id = session[:otp_user_id]

      user = if otp_user_id
               ::User.find_by_id(otp_user_id)
             elsif login
               ::User.find_by_login(login)
             end

      ::Authn::UnauthenticatedSecurityEventAuditor.new(login.presence || user || 'unknown').execute

      super
    end

    def complete_identity_verification
      user = find_user

      return if !user || !user.valid_password?(user_params[:password]) || user.access_locked?
      return if ::Gitlab::Qa.request?(request.user_agent)
      return if !user.signup_identity_verification_enabled? || user.signup_identity_verified?

      # When identity verification is enabled, store the user id in the session and redirect to the
      # identity verification page instead of displaying a Devise flash alert on the sign in page.
      session[:verification_user_id] = user.id
      redirect_to signup_identity_verification_path
    end

    def detect_and_notify_for_compromised_password
      user = find_user

      ::Gitlab::AppJsonLogger.info(
        message: 'Checking for compromised password',
        exposed_credential_check_header: request.headers['HTTP_EXPOSED_CREDENTIAL_CHECK'],
        user_id: user&.id)

      return unless user.present?

      ::Users::CompromisedPasswords::DetectAndNotifyService.new(user, user_params[:password], request).execute
    end

    override :onboarding_status_tracking_label
    def onboarding_status_tracking_label
      onboarding_status_presenter.preregistration_tracking_label
    end

    def onboarding_status_presenter
      ::Onboarding::StatusPresenter
        .new(params.permit(:invite_email).to_h.deep_symbolize_keys, session['user_return_to'], resource)
    end
    strong_memoize_attr :onboarding_status_presenter
  end
end
==== /workspace/gitlab/ee/app/controllers/ee/user_settings/active_sessions_controller.rb ====
# frozen_string_literal: true

module EE
  module UserSettings
    module ActiveSessionsController
      # dotcom-focused endpoint to return time remaining on existing SAML sessions
      # since we want only session data for current device / browser, this endpoint must be
      # in a regular app controller, not in the Grape API. client-side JS does not have access to
      # _gitlab_session_abc123 cookie
      def saml
        session_info = ::Gitlab::Auth::GroupSaml::SsoEnforcer.sessions_time_remaining_for_expiry

        session_info = session_info.map do |item|
          time_remaining = item[:time_remaining].in_milliseconds.to_i
          time_remaining = 0 if time_remaining <= 0

          {
            provider_id: item[:provider_id],
            time_remaining_ms: time_remaining
          }
        end
        render json: session_info
      end
    end
  end
end
==== /workspace/gitlab/ee/app/controllers/groups/omniauth_callbacks_controller.rb ====
# frozen_string_literal: true

class Groups::OmniauthCallbacksController < OmniauthCallbacksController
  extend ::Gitlab::Utils::Override
  include InternalRedirect

  skip_before_action :verify_authenticity_token, only: [:failure, :group_saml]

  before_action :log_saml_response, only: [:group_saml]

  feature_category :system_access
  urgency :low

  def group_saml
    @unauthenticated_group = Group.find_by_full_path(params[:group_id])
    @saml_provider = @unauthenticated_group.saml_provider

    identity_linker = Gitlab::Auth::GroupSaml::IdentityLinker.new(current_user, oauth, session, @saml_provider)

    store_location_for(:redirect, saml_redirect_path)
    omniauth_flow(Gitlab::Auth::GroupSaml, identity_linker: identity_linker)
  rescue Gitlab::Auth::Saml::IdentityLinker::UnverifiedRequest
    redirect_unverified_saml_initiation
  end

  private

  override :allowed_new_user?
  def allowed_new_user?(auth_user)
    # Group SAML users should always be allowed to sign up regardless of country restrictions,
    # so we only check if they are new users
    auth_user.new?
  end

  override :link_identity
  def link_identity(identity_linker)
    super.tap do
      store_active_saml_session unless identity_linker.failed?
    end
  end

  override :redirect_identity_linked
  def redirect_identity_linked
    flash[:notice] = s_("SAML|Your organization's SSO has been connected to your GitLab account")

    redirect_to after_sign_in_path_for(current_user)
  end

  override :redirect_identity_link_failed
  def redirect_identity_link_failed(error_message)
    flash[:alert] = format(
      s_("GroupSAML|%{group_name} SAML authentication failed: %{message}"),
      group_name: @unauthenticated_group.name,
      message: error_message
    )

    redirect_to root_path
  end

  override :sign_in_and_redirect
  def sign_in_and_redirect(user, *args)
    super.tap { flash[:notice] = "Signed in with SAML for #{@unauthenticated_group.name}" }
  end

  override :sign_in
  def sign_in(resource_or_scope, *args)
    store_active_saml_session

    super
  end

  override :prompt_for_two_factor
  def prompt_for_two_factor(user)
    store_active_saml_session

    super
  end

  override :locked_user_redirect
  def locked_user_redirect(user)
    redirect_to_group_sso(alert: locked_user_redirect_alert(user))
  end

  def redirect_to_group_sso(alert: nil)
    flash[:alert] = alert if alert

    redirect_to sso_group_saml_providers_path(@unauthenticated_group, token: @unauthenticated_group.saml_discovery_token)
  end

  def store_active_saml_session
    Gitlab::Auth::GroupSaml::SsoEnforcer.new(@saml_provider).update_session(
      session_not_on_or_after: session_not_on_or_after_attribute)
  end

  def redirect_unverified_saml_initiation
    flash[:notice] = "Request to link SAML account must be authorized"

    redirect_to sso_group_saml_providers_path(@unauthenticated_group)
  end

  override :after_sign_in_path_for
  def after_sign_in_path_for(resource)
    path = saml_redirect_path

    # Ensure that if redirecting to the SAML group path, check the user has access first.
    if path == group_path(@unauthenticated_group)
      path = safe_group_path(@unauthenticated_group) || dashboard_groups_path
    end

    path || super
  end

  override :build_auth_user
  def build_auth_user(auth_user_class)
    super.tap do |auth_user|
      auth_user.saml_provider = @saml_provider
    end
  end

  override :fail_login
  def fail_login(user)
    return redirect_to_login_or_register if email_already_taken?(user)

    error_message = email_blank?(user) ? email_blank_error_message : user.errors.full_messages.to_sentence
    redirect_to_group_sso(alert: error_message)
  end

  def redirect_to_login_or_register
    notice = s_("SAML|There is already a GitLab account associated with this email address. Sign in with your existing credentials to connect your organization's account")

    after_gitlab_sign_in = sso_group_saml_providers_path(@unauthenticated_group)

    store_location_for(:redirect, after_gitlab_sign_in)

    redirect_to new_user_session_path, notice: notice
  end

  def saml_redirect_path
    safe_relay_state || group_path(@unauthenticated_group)
  end

  def safe_group_path(group)
    return unless can?(current_user, :read_group, group)

    group_path(group)
  end

  def safe_relay_state
    valid_gitlab_initiated_saml_request? && safe_redirect_path(params['RelayState'])
  end

  override :find_message
  def find_message(kind, options = {})
    _('Unable to sign in to group with SAML: "%{reason}"') % options
  end

  override :after_omniauth_failure_path_for
  def after_omniauth_failure_path_for(scope)
    group_saml_failure_path(scope)
  end

  def group_saml_failure_path(scope)
    group = Gitlab::Auth::GroupSaml::GroupLookup.new(request.env).group

    unless can?(current_user, :sign_in_with_saml_provider, group&.saml_provider)
      OmniAuth::Strategies::GroupSaml.invalid_group!(group&.path)
    end

    if can?(current_user, :admin_group_saml, group)
      group_saml_providers_path(group)
    else
      sso_group_saml_providers_path(group)
    end
  end

  def email_already_taken?(user)
    email_error?(user, _('has already been taken'))
  end

  def email_blank?(user)
    email_error?(user, _("can't be blank"))
  end

  def email_error?(user, error_text)
    user && user.errors['email'].any?(error_text)
  end

  def email_blank_error_message
    s_('SAML|The SAML response did not contain an email address. Either the SAML identity provider is not configured to send the attribute, or the identity provider directory does not have an email address value for your user.')
  end

  override :log_audit_event
  def log_audit_event(user, options = {})
    return if options[:with].blank?

    provider = options[:with]
    audit_context = {
      name: 'authenticated_with_group_saml',
      author: user,
      scope: @unauthenticated_group,
      target: user,
      message: "Signed in with #{provider.upcase} authentication",
      authentication_event: true,
      authentication_provider: provider,
      additional_details: {
        with: provider,
        registration_details: user.registration_audit_details
      }
    }

    ::Gitlab::Audit::Auditor.audit(audit_context)
  end

  def log_saml_response
    ParameterFilters::SamlResponse.log(params['SAMLResponse'].dup)
  end
end
==== /workspace/gitlab/ee/app/controllers/groups/scim_oauth_controller.rb ====
# frozen_string_literal: true

class Groups::ScimOauthController < Groups::ApplicationController
  include SamlAuthorization

  before_action :require_top_level_group
  before_action :authorize_manage_saml!
  before_action :check_group_saml_available!
  before_action :check_group_saml_configured

  feature_category :system_access

  # rubocop: disable CodeReuse/ActiveRecord
  def create
    scim_token = GroupScimAuthAccessToken.find_or_initialize_by(group: @group)

    if scim_token.new_record?
      scim_token.save
    else
      scim_token.reset_token!
    end

    respond_to do |format|
      format.json do
        if scim_token.valid?
          render json: scim_token.as_entity_json
        else
          render json: { errors: scim_token.errors.full_messages }, status: :unprocessable_entity
        end
      end
    end
  end
  # rubocop: enable CodeReuse/ActiveRecord
end
==== /workspace/gitlab/ee/app/controllers/groups/two_factor_auths_controller.rb ====
# frozen_string_literal: true
module Groups
  class TwoFactorAuthsController < Groups::ApplicationController
    before_action :authorize_admin_group!
    before_action :set_user
    feature_category :user_management

    def destroy
      result = TwoFactor::DestroyService.new(current_user, user: @user, group: group).execute

      if result[:status] == :success
        redirect_to(
          group_group_members_path(group),
          status: :found,
          notice: format(
            format(
              _("Two-factor authentication has been disabled successfully for %{username}!"),
              username: @user.username
            )
          ))
      else
        redirect_to group_group_members_path(group), status: :found, alert: result[:message]
      end
    end

    private

    def set_user
      @user = User.find(params[:user_id])
    end
  end
end
==== /workspace/gitlab/ee/app/controllers/oauth/geo_auth_controller.rb ====
# frozen_string_literal: true

class Oauth::GeoAuthController < BaseActionController
  rescue_from Gitlab::Geo::OauthApplicationUndefinedError, with: :undefined_oauth_application
  rescue_from OAuth2::Error, with: :auth

  def auth
    unless login_state.valid?
      redirect_to root_url
      return
    end

    redirect_to oauth.authorize_url(redirect_uri: oauth_geo_callback_url, state: params[:state])
  end

  def callback
    unless login_state.valid?
      redirect_to new_user_session_path
      return
    end

    token = oauth.get_token(params[:code], redirect_uri: oauth_geo_callback_url)
    user  = user_from_oauth_token(token)

    if user && bypass_sign_in(user)
      after_sign_in_with_gitlab(token)
    else
      invalid_credentials
    end
  end

  def logout
    token = Gitlab::Geo::Oauth::LogoutToken.new(current_user, params[:state])

    if token.valid?
      sign_out current_user
      after_sign_out_with_gitlab(token)
    else
      invalid_access_token(token)
    end
  end

  private

  def oauth
    @oauth ||= Gitlab::Geo::Oauth::Session.new
  end

  def user_from_oauth_token(token)
    remote_user = oauth.authenticate(token)
    UserFinder.new(remote_user['id']).find_by_id if remote_user
  end

  def login_state
    Gitlab::Geo::Oauth::LoginState.from_state(params[:state])
  end

  def after_sign_in_with_gitlab(token)
    session[:access_token] = token

    # Prevent alert from popping up on the first page shown after authentication.
    flash[:alert] = nil

    redirect_to(login_state.return_to || root_path)
  end

  def after_sign_out_with_gitlab(token)
    session[:user_return_to] = token.return_to
    redirect_to(root_path)
  end

  def invalid_credentials
    @error = 'Cannot find user to login. Your account may have been deleted.'
    render :error, layout: 'errors'
  end

  def undefined_oauth_application
    @error = 'There are no OAuth application defined for this Geo node. Please ask your administrator to visit "Geo Nodes" on admin screen and click on "Repair authentication".'
    render :error, layout: 'errors'
  end

  def invalid_access_token(token)
    message = token.errors.full_messages.join(', ')
    @error = "There is a problem with the OAuth access_token: #{message}"
    render :error, layout: 'errors'
  end
end
==== /workspace/gitlab/ee/app/controllers/omniauth_kerberos_controller.rb ====
# frozen_string_literal: true

class OmniauthKerberosController < ApplicationController
  include KerberosHelper

  skip_before_action :authenticate_user!

  feature_category :system_access

  def negotiate
    if spnego_provided? && (krb_principal = spnego_credentials!(spnego_token))
      session[OmniAuth::Strategies::Kerberos::SESSION_KEY] = krb_principal
      send_final_spnego_response
      redirect_to user_kerberos_omniauth_callback_path
      return
    end

    # When the browser is Kerberos-aware, this response will make it try to
    # get a Kerberos ticket and present it to us via an SPNEGO token.
    #
    # When the browser does not know Kerberos, or if it tried to
    # authenticate with Kerberos but failed, it shows the special 'Kerberos
    # denied' 401 page to the user.
    #
    # We cannot redirect the user to the sign-in page because we do not know
    # when the browser has given up.
    #
    headers['Www-Authenticate'] = spnego_challenge
    render template: 'errors/kerberos_denied',
      formats: :html,
      locals: { layout: 'errors' },
      status: :unauthorized
  end
end
==== /workspace/gitlab/ee/app/models/ai/user_metrics.rb ====
# frozen_string_literal: true

module Ai
  class UserMetrics < ApplicationRecord
    include Analytics::HasWriteBuffer

    self.table_name = 'ai_user_metrics'

    self.write_buffer_options = { class: Analytics::AiUserMetricsDatabaseWriteBuffer }

    belongs_to :user, optional: false

    validates :last_duo_activity_on, presence: true

    scope :for_users, ->(users) { where(user: users) }

    def self.refresh_last_activity_on(user, last_duo_activity_on: Time.current)
      write_buffer.add({ user_id: user.id, last_duo_activity_on: last_duo_activity_on })
    end
  end
end
==== /workspace/gitlab/ee/app/models/approval_merge_request_rules_user.rb ====
# frozen_string_literal: true

# Model for join table between ApprovalMergeRequestRule and User
class ApprovalMergeRequestRulesUser < ApplicationRecord # rubocop:disable Gitlab/NamespacedClass -- Conventional name for a join class
  include ApprovalRuleUserLike

  belongs_to :user
  belongs_to :approval_merge_request_rule, class_name: 'ApprovalMergeRequestRule'

  scope :for_approval_merge_request_rules, ->(approval_merge_request_rules) do
    where(approval_merge_request_rule: approval_merge_request_rules)
  end
end
==== /workspace/gitlab/ee/app/models/approval_project_rules_user.rb ====
# frozen_string_literal: true

# Model for join table between ApprovalProjectRule and User
# create to enable exports ApprovalProjectRule
class ApprovalProjectRulesUser < ApplicationRecord # rubocop:disable Gitlab/NamespacedClass
  include ApprovalRuleUserLike

  belongs_to :user
  belongs_to :approval_project_rule, class_name: 'ApprovalProjectRule'

  scope :for_project, ->(project_id) do
    joins(:approval_project_rule).where(approval_project_rule: { project_id: project_id })
  end
end
==== /workspace/gitlab/ee/app/models/approval_rules/approval_group_rules_user.rb ====
# frozen_string_literal: true

# Model for join table between ApprovalGroupRule and User
# create to enable exports ApprovalGroupRule
module ApprovalRules
  class ApprovalGroupRulesUser < ApplicationRecord
    include ApprovalRuleUserLike

    belongs_to :user
    belongs_to :approval_group_rule, class_name: 'ApprovalRules::ApprovalGroupRule'

    validates :user, :approval_group_rule, presence: true
  end
end
==== /workspace/gitlab/ee/app/models/authz/user_admin_role.rb ====
# frozen_string_literal: true

module Authz
  class UserAdminRole < ApplicationRecord
    include Authz::UserRoleAssignable

    self.primary_key = 'user_id'

    belongs_to :user
    belongs_to :admin_role, class_name: 'Authz::AdminRole'
    belongs_to :member_role, foreign_key: 'admin_role_id', class_name: 'Authz::AdminRole', inverse_of: :user_admin_roles

    validates :admin_role, presence: true
    validates :user, presence: true, uniqueness: true

    def self.klass(user)
      if Feature.enabled?(:extract_admin_roles_from_member_roles, user)
        Authz::UserAdminRole
      else
        Users::UserMemberRole
      end
    end
  end
end
==== /workspace/gitlab/ee/app/models/authz/user_group_member_role.rb ====
# frozen_string_literal: true

# This model records member role assignment to a user in groups through:
# - Group membership
# - Group sharing
#
# shared_with_group_id is nil for assigments through group membership.
#
# For assignments through group sharing group_id points to the shared group
# (group_group_link.shared_group) while shared_with_group_id ==
# group_group_link.shared_with_group_id. The shared_with_group_id column serves
# as a differentiator between different types of member role assignments as well
# as a way to easily delete records when the matching group_group_link record is
# deleted or the user's membership to shared_with_group is removed.
module Authz
  class UserGroupMemberRole < ApplicationRecord
    belongs_to :user
    belongs_to :group, class_name: '::Group'
    belongs_to :shared_with_group, class_name: '::Group'
    belongs_to :member_role

    validates :user, presence: true, uniqueness: { scope: %i[group_id shared_with_group_id] }
    validates :group, presence: true
    validates :member_role, presence: true

    def self.for_user_in_group_and_shared_groups(user, group)
      direct_membership = where(user: user, group: group, shared_with_group: nil)
      shared_group_membership = where(user: user, shared_with_group: group)

      from(
        Arel::Nodes::TableAlias.new(
          Arel::Nodes::UnionAll.new(direct_membership.arel, shared_group_membership.arel),
          table_name
        )
      )
    end

    def self.in_shared_group(shared_group, shared_with_group)
      where(group: shared_group, shared_with_group: shared_with_group)
    end

    def self.delete_all_with_id(ids)
      id_in(ids).delete_all
    end

    def self.for_user_in_group(user, group)
      # Member role assigned to the user in the given group through membership.
      # `shared_with_group: nil` condition is added to exclude member role
      # assigments in the given group through an invited group.
      find_by(user: user, group: group, shared_with_group: nil)
    end

    def self.with_attrs(attrs, attr_values)
      # WHERE (attr1, attr2) IN (VALUES (attr1_value, attr2_value), (attr1_value2, attr2_value2))
      #
      # E.g. to fetch all records created for group_group_link we could do
      # .with_attrs([:group_id, :shared_with_group_id], [[1, 2], [3, 4]])
      attrs = Array(attrs.collect { |a| arel_table[a] })
      values = Arel::Nodes::ValuesList.new(attr_values)

      where(Arel::Nodes::In.new(Arel::Nodes::Grouping.new(attrs), values))
    end
  end
end
==== /workspace/gitlab/ee/app/models/boards/epic_list_user_preference.rb ====
# frozen_string_literal: true

module Boards
  class EpicListUserPreference < ApplicationRecord
    belongs_to :user
    belongs_to :epic_list, foreign_key: :epic_list_id, inverse_of: :epic_list_user_preferences

    validates :user, presence: true
    validates :epic_list, presence: true
    validates :user_id, uniqueness: { scope: :epic_list_id, message: "should have only one epic list preference per user" }
  end
end
==== /workspace/gitlab/ee/app/models/boards/epic_user_preference.rb ====
# frozen_string_literal: true

module Boards
  class EpicUserPreference < ApplicationRecord
    self.table_name = 'boards_epic_user_preferences'

    belongs_to :user, inverse_of: :boards_epic_user_preferences
    belongs_to :board, inverse_of: :boards_epic_user_preferences
    belongs_to :epic, inverse_of: :boards_epic_user_preferences

    validates :user, uniqueness: { scope: [:board_id, :epic_id] }

    scope :for_boards_and_epics, ->(board_ids, epic_ids) do
      where(board_id: board_ids, epic_id: epic_ids)
    end
  end
end
==== /workspace/gitlab/ee/app/models/board_user_preference.rb ====
# frozen_string_literal: true

class BoardUserPreference < ApplicationRecord
  belongs_to :user, inverse_of: :board_preferences
  belongs_to :board, inverse_of: :user_preferences

  validates :user, presence: true
  validates :board, presence: true
  validates :user_id, uniqueness: { scope: :board_id, message: "should have only one board preference per user" }

  before_validation :ensure_group_or_project

  private

  def ensure_group_or_project
    self.group_id = board&.group_id
    self.project_id = board&.project_id
  end
end
==== /workspace/gitlab/ee/app/models/compliance_management/pipl_user.rb ====
# frozen_string_literal: true

module ComplianceManagement
  class PiplUser < ApplicationRecord
    include EachBatch

    LEVEL_1_NOTIFICATION_TIME = 30.days
    LEVEL_2_NOTIFICATION_TIME = 53.days
    LEVEL_3_NOTIFICATION_TIME = 59.days

    NOTICE_PERIOD = 60.days
    DELETION_PERIOD = 120.days

    belongs_to :user, optional: false

    scope :days_from_initial_pipl_email, ->(*days) do
      sent_mail_ranges = days.map do |day_count|
        day_count.ago.beginning_of_day..day_count.ago.end_of_day
      end

      includes(:user).where(initial_email_sent_at: sent_mail_ranges)
    end

    scope :with_due_notifications, -> do
      days_from_initial_pipl_email(*[LEVEL_1_NOTIFICATION_TIME, LEVEL_2_NOTIFICATION_TIME, LEVEL_3_NOTIFICATION_TIME])
    end

    scope :pipl_email_sent_on_or_before, ->(date) do
      where(initial_email_sent_at: ..date)
    end

    scope :pipl_blockable, -> do
      joins(:user)
        .includes(:user)
        .pipl_email_sent_on_or_before(NOTICE_PERIOD.ago.end_of_day)
        .where.not(users: { state: ::User.state_machine.states[:blocked].value })
    end

    scope :pipl_deletable, -> do
      joins(:user)
        .includes(:user)
        .left_outer_joins(user: :ghost_user_migration)
        .where(ghost_user_migrations: { id: nil })
        .pipl_email_sent_on_or_before(DELETION_PERIOD.ago.end_of_day)
        .merge(User.blocked)
    end

    validates :last_access_from_pipl_country_at, presence: true

    enum :state, {
      default: 0
    }

    def self.for_user(user)
      find_by(user: user)
    end

    def self.untrack_access!(user)
      where(user: user).delete_all if user.is_a?(User)
    end

    def self.track_access(user)
      upsert({ user_id: user.id, last_access_from_pipl_country_at: Time.current }, unique_by: :user_id)
    end

    def recently_tracked?
      last_access_from_pipl_country_at.after?(24.hours.ago)
    end

    def pipl_access_end_date
      return if initial_email_sent_at.blank?

      initial_email_sent_at.to_date + NOTICE_PERIOD
    end

    def reset_notification!
      update(initial_email_sent_at: nil)
    end

    def notification_sent!
      update!(initial_email_sent_at: Time.current)
    end

    def remaining_pipl_access_days
      return if initial_email_sent_at.blank?

      (pipl_access_end_date - Date.current).to_i
    end

    def block_threshold_met?
      initial_email_sent_at.present? &&
        initial_email_sent_at.to_date <= (Date.current - NOTICE_PERIOD)
    end

    def deletion_threshold_met?
      initial_email_sent_at.present? &&
        initial_email_sent_at.to_date <= (Date.current - DELETION_PERIOD)
    end
  end
end
==== /workspace/gitlab/ee/app/models/concerns/ai/user_authorizable.rb ====
# frozen_string_literal: true

module Ai
  module UserAuthorizable
    extend ActiveSupport::Concern

    GROUP_WITH_AI_ENABLED_CACHE_PERIOD = 1.hour
    GROUP_WITH_AI_ENABLED_CACHE_KEY = 'group_with_ai_enabled'

    BILLABLE_DUO_PRO_ROOT_GROUP_IDS_CACHE_KEY = 'billable_duo_pro_root_group_ids'
    BILLABLE_DUO_PRO_ROOT_GROUP_IDS_CACHE_PERIOD = 10.minutes

    DUO_PRO_ADD_ON_CACHE_KEY = 'user-%{user_id}-code-suggestions-add-on-cache'
    # refers to add-ons listed in GitlabSubscriptions::AddOn::DUO_ADD_ONS
    DUO_ADD_ONS_CACHE_KEY = 'user-%{user_id}-duo-add-ons-cache'
    AMAZON_Q_FEATURES = [
      :code_suggestions,
      :duo_chat,
      :explain_vulnerability,
      :generate_commit_message,
      :glab_ask_git_command,
      :resolve_vulnerability,
      :review_merge_request,
      :summarize_comments,
      :troubleshoot_job
    ].freeze

    Response = Struct.new(:allowed?, :namespace_ids, :enablement_type, :authorized_by_duo_core, keyword_init: true)

    included do
      def duo_available_namespace_ids
        cache_key = duo_addons_cache_key_formatted

        Rails.cache.fetch(cache_key, expires_in: 1.hour) do
          GitlabSubscriptions::UserAddOnAssignment.by_user(self).for_active_gitlab_duo_purchase
            .pluck('subscription_add_on_purchases.namespace_id') # rubocop: disable Database/AvoidUsingPluckWithoutLimit -- limited to a single user's purchases
            .uniq
        end
      end

      def duo_addons_cache_key_formatted
        format(DUO_ADD_ONS_CACHE_KEY, user_id: id)
      end

      def duo_pro_cache_key_formatted
        self.class.duo_pro_cache_key_formatted(id)
      end

      def eligible_for_self_managed_gitlab_duo_pro?
        return false if gitlab_com_subscription?

        active? && !bot? && !ghost?
      end

      # rubocop: disable Database/AvoidUsingPluckWithoutLimit -- limited to a single user's groups
      def billable_gitlab_duo_pro_root_group_ids
        return unless gitlab_com_subscription?

        Rails.cache.fetch(
          ['users', id, BILLABLE_DUO_PRO_ROOT_GROUP_IDS_CACHE_KEY],
          expires_in: BILLABLE_DUO_PRO_ROOT_GROUP_IDS_CACHE_PERIOD
        ) do
          group_ids_from_project_authorizaton = Project.id_in(project_authorizations.non_guests.select(:project_id))
            .pluck(:namespace_id)
          group_ids_from_memberships = GroupMember.with_user(self).active.non_guests.pluck(:source_id)
          group_ids_from_linked_groups = GroupGroupLink.non_guests
          .where(shared_with_group_id: group_ids_from_memberships)
            .pluck(:shared_group_id)

          root_group_ids = Group.where(
            id: group_ids_from_project_authorizaton | group_ids_from_memberships | group_ids_from_linked_groups
          ).pluck(Arel.sql('traversal_ids[1]')).uniq

          banned_root_group_ids = ::Namespaces::NamespaceBan.where(user_id: id).pluck(:namespace_id)

          root_group_ids - banned_root_group_ids
        end
      end
      # rubocop: enable Database/AvoidUsingPluckWithoutLimit -- limited to a single user's groups

      def any_group_with_ai_available?
        Rails.cache.fetch(
          ['users', id, GROUP_WITH_AI_ENABLED_CACHE_KEY],
          expires_in: GROUP_WITH_AI_ENABLED_CACHE_PERIOD
        ) do
          member_namespaces.namespace_settings_with_ai_features_enabled.with_ai_supported_plan.any?
        end
      end

      def allowed_to_use?(ai_feature, service_name: nil, licensed_feature: :ai_features)
        allowed_to_use(ai_feature, service_name: service_name, licensed_feature: licensed_feature).allowed?
      end

      def allowed_by_namespace_ids(...)
        allowed_to_use(...).namespace_ids
      end

      def allowed_to_use(ai_feature, service_name: nil, licensed_feature: :ai_features)
        amazon_q_response = check_amazon_q_feature(ai_feature)
        return amazon_q_response if amazon_q_response

        # Check if feature and service are valid and available
        feature_data = Gitlab::Llm::Utils::AiFeaturesCatalogue.search_by_name(ai_feature)
        return denied_response unless feature_data

        service = CloudConnector::AvailableServices.find_by_name(service_name || ai_feature)
        return denied_response if service.name == :missing_service

        # Access through Duo Pro and Duo Enterprise
        add_on_response = check_add_on_purchases(service)
        return add_on_response if add_on_response

        # Access through Duo Core
        duo_core_response = check_duo_core_features(service)
        return duo_core_response if duo_core_response

        # If the user doesn't have access through Duo add-ons
        # and the service isn't free, they don't have access
        return denied_response unless service_free_access?(service)

        check_free_access(feature_data, licensed_feature)
      end

      private

      def service_free_access?(service)
        service.cut_off_date.nil? || service.cut_off_date&.future?
      end

      def check_add_on_purchases(service)
        # NOTE: We are passing `nil` as the resource to avoid filtering by namespace.
        # This is _not_ a good use of this API, and we should separate filtering by namespace
        # from filtering by user seat assignments. While this works, it will actually join
        # all add-on purchases in all tenant namespaces, which is not ideal.
        purchases = GitlabSubscriptions::AddOnPurchase.for_active_add_ons(service.add_on_names, nil)
                                                      .assigned_to_user(self)
        return unless purchases.any?

        Response.new(
          allowed?: true,
          namespace_ids: purchases.uniq_namespace_ids,
          enablement_type: purchases.last.normalized_add_on_name,
          authorized_by_duo_core: false
        )
      end

      def check_duo_core_features(service)
        return unless active? && !bot?
        return unless service.add_on_names.include?("duo_core") && duo_core_add_on?

        if saas?
          groups = groups_with_duo_core_enabled
          return unless groups.any?

          Response.new(
            allowed?: true,
            namespace_ids: groups.ids,
            enablement_type: duo_core_add_on_purchase.normalized_add_on_name,
            authorized_by_duo_core: true
          )
        elsif ::Ai::Setting.instance.duo_core_features_enabled?
          Response.new(
            allowed?: true,
            namespace_ids: [],
            enablement_type: duo_core_add_on_purchase.normalized_add_on_name,
            authorized_by_duo_core: true
          )
        end
      end

      def check_free_access(feature_data, licensed_feature)
        if saas?
          check_saas_free_access(feature_data)
        else
          check_sm_free_access(licensed_feature)
        end
      end

      def check_saas_free_access(feature_data)
        seats = namespaces_allowed_in_com(feature_data[:maturity])

        if seats.any?
          Response.new(allowed?: true, namespace_ids: seats, enablement_type: 'tier', authorized_by_duo_core: false)
        else
          denied_response
        end
      end

      def check_sm_free_access(licensed_feature)
        Response.new(allowed?: licensed_to_use_in_sm?(licensed_feature), namespace_ids: [],
          authorized_by_duo_core: false)
      end

      def denied_response
        Response.new(allowed?: false, namespace_ids: [], authorized_by_duo_core: false)
      end

      def groups_with_duo_core_enabled
        Namespace.id_in(billable_gitlab_duo_pro_root_group_ids)
          .namespace_settings_with_duo_core_features_enabled
      end

      def duo_core_add_on?
        duo_core_add_on_purchase.present?
      end

      def duo_core_add_on_purchase
        @duo_core_add_on_purchase ||= GitlabSubscriptions::AddOnPurchase.for_duo_core.for_user(self).active.first
      end

      def check_amazon_q_feature(ai_feature)
        return unless ::Ai::AmazonQ.connected?
        return unless AMAZON_Q_FEATURES.include?(ai_feature)

        Response.new(
          allowed?: true,
          namespace_ids: [],
          enablement_type: 'duo_amazon_q',
          authorized_by_duo_core: false
        )
      end

      def namespaces_allowed_in_com(maturity)
        namespaces = member_namespaces.with_ai_supported_plan
        namespaces = namespaces.namespace_settings_with_ai_features_enabled if maturity != :ga
        namespaces.ids
      end

      def licensed_to_use_in_sm?(licensed_feature)
        License.feature_available?(licensed_feature)
      end

      def saas?
        Gitlab::Saas.feature_available?(:gitlab_com_subscriptions)
      end
    end

    class_methods do
      def clear_group_with_ai_available_cache(ids)
        cache_keys_ai_features = Array.wrap(ids).map { |id| ["users", id, GROUP_WITH_AI_ENABLED_CACHE_KEY] }
        cache_keys_billable_duo_pro_group_ids = Array.wrap(ids).map do |id|
          ["users", id, BILLABLE_DUO_PRO_ROOT_GROUP_IDS_CACHE_KEY]
        end

        cache_keys = cache_keys_ai_features + cache_keys_billable_duo_pro_group_ids
        ::Gitlab::Instrumentation::RedisClusterValidator.allow_cross_slot_commands do
          Rails.cache.delete_multi(cache_keys)
        end
      end

      def duo_pro_cache_key_formatted(user_id)
        format(DUO_PRO_ADD_ON_CACHE_KEY, user_id: user_id)
      end
    end
  end
end
==== /workspace/gitlab/ee/app/models/concerns/approval_rule_user_like.rb ====
# frozen_string_literal: true

module ApprovalRuleUserLike
  extend ActiveSupport::Concern
  include EachBatch

  included do
    scope :for_users, ->(user_ids) { where(user_id: user_ids) }
  end
end
==== /workspace/gitlab/ee/app/models/concerns/authz/user_role_assignable.rb ====
# frozen_string_literal: true

module Authz
  module UserRoleAssignable
    extend ActiveSupport::Concern

    class_methods do
      def create_or_update(user:, member_role:, **args)
        find_or_initialize_by(user: user).tap do |record|
          record.update(member_role: member_role, **args)
        end
      end
    end
  end
end
==== /workspace/gitlab/ee/app/models/concerns/identity_verifiable.rb ====
# frozen_string_literal: true

module IdentityVerifiable
  include Gitlab::Utils::StrongMemoize
  include Gitlab::Experiment::Dsl
  extend ActiveSupport::Concern

  VERIFICATION_METHODS = {
    CREDIT_CARD: 'credit_card',
    PHONE_NUMBER: 'phone',
    EMAIL: 'email'
  }.freeze

  SIGNUP_IDENTITY_VERIFICATION_EXEMPT_METHODS = %w[email].freeze
  PHONE_NUMBER_EXEMPT_METHODS = %w[email credit_card].freeze
  ASSUMED_HIGH_RISK_USER_METHODS = %w[email credit_card phone].freeze
  HIGH_RISK_USER_METHODS = %w[email phone credit_card].freeze
  MEDIUM_RISK_USER_METHODS = %w[email phone].freeze
  LOW_RISK_USER_METHODS = %w[email].freeze
  ACTIVE_USER_METHODS = %w[phone].freeze
  IDENTITY_VERIFICATION_RELEASE_DATE = Date.new(2024, 5, 30)
  IDENTITY_VERIFICATION_FOR_OSS_FROM_DATE = Date.new(2025, 7, 1)

  def signup_identity_verification_enabled?
    return false unless ::Gitlab::Saas.feature_available?(:identity_verification)
    return false unless ::Gitlab::CurrentSettings.email_confirmation_setting_hard?
    return false if ::Gitlab::CurrentSettings.require_admin_approval_after_user_signup

    true
  end

  def active_for_authentication?
    return false unless super

    !signup_identity_verification_enabled? || signup_identity_verified?
  end

  def signup_identity_verified?
    return email_verified? unless signup_identity_verification_enabled?

    # Treat users that have already signed in before as verified if their email
    # is already verified.
    #
    # This prevents the scenario where a user has to verify their identity
    # multiple times. For example:
    #
    # 1. credit_card_verification_enabled application setting is false
    # 2. A user registers, is assigned High risk band, verifies their email as
    # prompted, and starts using GitLab
    # 3. credit_card_verification_enabled application setting is true
    # 4. User signs out and signs in again
    # 5. User is redirected to Identity Verification which requires them to
    # verify their credit card
    return email_verified? if active_user?

    identity_verification_state.values.all?
  end

  def identity_verification_enabled?
    return false unless ::Gitlab::Saas.feature_available?(:identity_verification)

    # When no verification methods are available i.e. both phone number and
    # credit card verifications are disabled
    return false if required_identity_verification_methods.empty?

    true
  end

  def identity_verified?
    return true unless identity_verification_enabled?
    return true unless created_after_require_identity_verification_release_day?
    return bot_identity_verified? unless human?

    # Allow an existing credit card validation to override the identity verification state if
    # credit_card is not a required verification method.
    return true if identity_verification_state.exclude?(VERIFICATION_METHODS[:CREDIT_CARD]) && credit_card_verified?

    identity_verification_state.values.all? || identity_verification_exempt?
  end

  def identity_verification_state
    # Return only the state of required verification methods instead of all
    # methods. This will save us from doing unnecessary queries. E.g. when risk
    # band is 'Low' we only need to call `confirmed?`
    required_identity_verification_methods.index_with do |method|
      verification_state[method].call
    end
  end
  strong_memoize_attr :identity_verification_state

  def required_identity_verification_methods
    methods = determine_required_methods
    methods.select { |method| verification_method_enabled?(method) }
  end

  def credit_card_verified?
    credit_card_validation.present? && !credit_card_validation.used_by_banned_user?
  end

  def add_phone_number_verification_exemption
    return if phone_number_verification_exempt?
    return if phone_verified?

    risk_profile.add_phone_number_verification_exemption
    clear_memoization(:identity_verification_state)
  end

  def toggle_phone_number_verification
    if phone_number_verification_exempt?
      remove_phone_number_verification_exemption
      clear_memoization(:identity_verification_state)
    else
      add_phone_number_verification_exemption
    end
  end

  def identity_verification_exempt?
    return true if risk_profile.identity_verification_exempt?
    return true if enterprise_user?

    # We need identity check for OSS plans to prevent abuse.
    plans = ::Plan::PAID_HOSTED_PLANS
    plans = plans.without(::Plan::OPEN_SOURCE) if id_check_for_oss_enabled?
    return true if belongs_to_paid_namespace?(plans: plans, exclude_trials: true)

    false
  end

  def offer_phone_number_exemption?
    return false unless verification_method_enabled?('credit_card')
    return false unless verification_method_enabled?('phone')

    phone_required = verification_method_required?(method: VERIFICATION_METHODS[:PHONE_NUMBER])
    cc_required = verification_method_required?(method: VERIFICATION_METHODS[:CREDIT_CARD])

    return false if phone_required && cc_required

    # If phone verification is not required but a phone exemption exists it means the user toggled from
    # verifying with a phone to verifying with a credit card. Returning true if a phone exemption exists
    # will allow the user to toggle back to using phone verification from the credit card form.
    phone_required || phone_number_verification_exempt?
  end

  def verification_method_allowed?(method:)
    return false unless verification_method_required?(method: method)

    # Take all methods that precede <method>. E.g. if <method> is cc and
    # required methods is [email phone cc], then prerequisite methods is
    # [email phone]
    prerequisite_methods = required_identity_verification_methods.take_while { |m| m != method }

    # Get the state of prerequisite methods. E.g. if <method> is cc and state is
    # { email: true, phone: false, cc: false }, then prerequisite methods state
    # is { email: true, phone: false }
    prerequisite_methods_state = identity_verification_state.select { |method| method.in? prerequisite_methods }

    # Check if all prerequisite methods are completed?
    prerequisite_methods_state.values.all?
  end

  def requires_identity_verification_to_create_group?(group)
    return false if group.parent

    reached_top_level_group_limit?
  end

  delegate :arkose_verified?, :assume_low_risk!, :assume_high_risk!, :assumed_high_risk?,
    :add_identity_verification_exemption, :remove_identity_verification_exemption, :phone_number_verification_exempt?,
    :assume_high_risk_if_phone_verification_limit_exceeded!,
    to: :risk_profile
  delegate :high_risk?, :medium_risk?, :low_risk?, :remove_phone_number_verification_exemption,
    to: :risk_profile, private: true

  private

  def verification_method_enabled?(method)
    case method
    when 'phone'
      ::Gitlab::CurrentSettings.phone_verification_enabled &&
        !::Gitlab::ApplicationRateLimiter.peek(:hard_phone_verification_transactions_limit, scope: nil)
    when 'credit_card'
      ::Gitlab::CurrentSettings.credit_card_verification_enabled
    when 'email'
      !opt_in_flow?
    end
  end

  def active_user?
    last_sign_in_at.present?
  end

  def opt_in_flow?
    active_user? && email_verified?
  end

  def risk_profile
    @risk_profile ||= IdentityVerification::UserRiskProfile.new(self)
  end

  def affected_by_phone_verifications_limit?
    # All users will be required to verify 1. email 2. credit card
    return true if ::Gitlab::ApplicationRateLimiter.peek(:hard_phone_verification_transactions_limit, scope: nil)

    # Actual high risk users will be subject to the same order of required steps
    # as users assumed high risk when the daily phone verification transaction
    # limit is exceeded until it is reset
    return high_risk? if ::Gitlab::ApplicationRateLimiter.peek(:soft_phone_verification_transactions_limit, scope: nil)

    false
  end

  def determine_required_methods
    if opt_in_flow?
      active_user_required_methods
    else
      new_user_required_methods
    end
  end

  def active_user_required_methods
    return PHONE_NUMBER_EXEMPT_METHODS if phone_number_verification_exempt?
    return ASSUMED_HIGH_RISK_USER_METHODS if assumed_high_risk? || affected_by_phone_verifications_limit?

    ACTIVE_USER_METHODS
  end

  def new_user_required_methods
    return SIGNUP_IDENTITY_VERIFICATION_EXEMPT_METHODS if identity_verification_exempt?
    return PHONE_NUMBER_EXEMPT_METHODS if phone_number_verification_exempt?
    return ASSUMED_HIGH_RISK_USER_METHODS if assumed_high_risk? || affected_by_phone_verifications_limit?
    return HIGH_RISK_USER_METHODS if high_risk?
    return MEDIUM_RISK_USER_METHODS if medium_risk?

    LOW_RISK_USER_METHODS
  end

  def verification_method_required?(method:)
    return unless method.in? required_identity_verification_methods

    !identity_verification_state[method]
  end

  def verification_state
    @verification_state ||= {
      credit_card: -> { credit_card_verified? },
      phone: -> { phone_verified? },
      email: -> { email_verified? }
    }.stringify_keys
  end

  def phone_verified?
    phone_number_validation.present? && phone_number_validation.validated?
  end

  def email_verified?
    confirmed?
  end

  def created_top_level_group_count
    created_namespace_details.joins(:namespace).where(namespaces: { parent: nil, type: 'Group' }).count
  end

  def reached_top_level_group_limit?
    return false if identity_verified?

    created_top_level_group_count >= ::Gitlab::CurrentSettings.unverified_account_group_creation_limit
  end

  def created_after_require_identity_verification_release_day?
    created_at >= IDENTITY_VERIFICATION_RELEASE_DATE
  end

  def id_check_for_oss_enabled?
    Feature.enabled?(:id_check_for_oss, self) && created_after_require_identity_verification_for_oss?
  end

  def created_after_require_identity_verification_for_oss?
    created_at >= IDENTITY_VERIFICATION_FOR_OSS_FROM_DATE
  end

  def bot_identity_verified?
    return true unless project_bot?

    member = members.first
    id_check_for_oss = ::Feature.enabled?(:id_check_for_oss, self)
    if member && member.source.root_ancestor.actual_plan.paid_excluding_trials?(exclude_oss: id_check_for_oss)
      return true
    end

    return false unless created_by.present?
    return false if created_by.banned?

    created_by.identity_verified?
  end
end
==== /workspace/gitlab/ee/app/models/ee/active_session.rb ====
# frozen_string_literal: true

module EE
  module ActiveSession
    module ClassMethods
      def set_marketing_user_cookies(auth, user)
        return unless ::Gitlab::Saas.feature_available?(:gitlab_com_subscriptions)

        expiration_time = 2.weeks.from_now
        domain = ::Gitlab.config.gitlab.host

        auth.cookies[:gitlab_user] =
          {
            value: true,
            domain: domain,
            expires: expiration_time
          }

        tiers = GitlabSubscriptions::CurrentActivePlansForUserFinder.new(user).execute.pluck(:name) # rubocop:disable Database/AvoidUsingPluckWithoutLimit -- False positive as limit is defined in finder

        auth.cookies[:gitlab_tier] = {
          value: tiers.presence || false,
          domain: domain,
          expires: expiration_time
        }
      end

      def unset_marketing_user_cookies(auth)
        return unless ::Gitlab::Saas.feature_available?(:gitlab_com_subscriptions)

        domain = ::Gitlab.config.gitlab.host

        auth.cookies.delete(:gitlab_user, domain: domain)
        auth.cookies.delete(:gitlab_tier, domain: domain)
      end
    end

    def self.prepended(base)
      base.singleton_class.prepend(ClassMethods)
    end
  end
end
==== /workspace/gitlab/ee/app/models/ee/audit_events/user_audit_event.rb ====
# frozen_string_literal: true

module EE
  module AuditEvents
    module UserAuditEvent
      include ::Gitlab::Utils::StrongMemoize
      include ::AuditEvents::CommonAuditEventStreamable

      attr_accessor :root_group_entity_id
      attr_writer :entity, :user

      def user
        lazy_user
      end
      strong_memoize_attr :user

      def entity
        user
      end
      strong_memoize_attr :entity

      def entity_id
        return if entity.is_a?(::Gitlab::Audit::NullEntity)

        entity.id if entity.respond_to?(:id)
      end

      def entity_type
        "User"
      end

      def present
        AuditEventPresenter.new(self)
      end

      def root_group_entity
        nil
      end
      strong_memoize_attr :root_group_entity

      private

      def lazy_user
        BatchLoader.for(user_id).batch(default_value: ::Gitlab::Audit::NullEntity.new) do |ids, loader|
          ::User.id_in(ids).find_each { |record| loader.call(record.id, record) }
        end
      end
    end
  end
end
==== /workspace/gitlab/ee/app/models/ee/identity.rb ====
# frozen_string_literal: true

module EE
  module Identity
    extend ActiveSupport::Concern

    prepended do
      include ScimPaginatable

      belongs_to :saml_provider

      validates :name_id,
        presence: { message: "is missing from your SAML response. Please contact your administrator" },
        if: :saml_provider

      validates :saml_provider_id, presence: true, if: :group_saml?

      validates :secondary_extern_uid,
        allow_blank: true,
        uniqueness: {
          scope: ::Identity::UniquenessScopes.scopes,
          case_sensitive: false
        }

      validate :validate_managing_group

      after_destroy :update_user_admin_roles

      scope :with_secondary_extern_uid, ->(provider, secondary_extern_uid) do
        iwhere(secondary_extern_uid: normalize_uid(provider, secondary_extern_uid)).with_provider(provider)
      end

      def name_id
        extern_uid
      end

      def group_saml?
        provider.to_s == "group_saml"
      end
    end

    class_methods do
      extend ::Gitlab::Utils::Override

      override :human_attribute_name
      def human_attribute_name(name, *args)
        if name.to_sym == :name_id
          "SAML NameID"
        else
          super
        end
      end

      def find_by_extern_uid(provider, extern_uid)
        with_extern_uid(provider, extern_uid).take
      end

      def where_group_saml_uid(saml_provider, extern_uid)
        where(provider: :group_saml, saml_provider: saml_provider, extern_uid: extern_uid)
      end

      def find_by_group_saml_uid(saml_provider, extern_uid)
        where_group_saml_uid(saml_provider, extern_uid).take
      end

      def preload_saml_group
        preload(saml_provider: { group: :route })
      end
    end

    private

    def validate_managing_group
      return unless saml_provider&.enforced_group_managed_accounts?

      errors.add(:base, _('Group requires separate account')) if saml_provider.group != user.managing_group
    end

    def update_user_admin_roles
      user.user_member_role&.update(ldap: false)
    end
  end
end
==== /workspace/gitlab/ee/app/models/ee/import/source_user.rb ====
# frozen_string_literal: true

module EE
  module Import
    module SourceUser
      extend ::Gitlab::Utils::Override

      override :enterprise_bypass_placeholder_confirmation_allowed?
      def enterprise_bypass_placeholder_confirmation_allowed?
        ::Import::UserMapping::EnterpriseBypassAuthorizer.new(namespace, reassign_to_user, reassigned_by_user).allowed?
      end
    end
  end
end
==== /workspace/gitlab/ee/app/models/ee/personal_access_token.rb ====
# frozen_string_literal: true

module EE
  # PersonalAccessToken EE mixin
  #
  # This module is intended to encapsulate EE-specific model logic
  # and be prepended in the `PersonalAccessToken` model
  module PersonalAccessToken
    extend ActiveSupport::Concern
    extend ::Gitlab::Utils::Override
    include ::Gitlab::Utils::StrongMemoize

    prepended do
      include FromUnion

      has_one :workspace,
        class_name: 'RemoteDevelopment::Workspace',
        inverse_of: :personal_access_token,
        foreign_key: :personal_access_token_id

      scope :with_expires_at_after, ->(max_lifetime) { where(revoked: false).where('expires_at > ?', max_lifetime) }
      scope :expires_in, ->(within) { not_revoked.where('expires_at > CURRENT_DATE AND expires_at <= ?', within) }
      scope :created_on_or_after, ->(date) { active.where('created_at >= ?', date) }
      scope :owner_is_service_account, -> { includes(:user).references(:user).merge(::User.service_account) }

      with_options if: :expiration_policy_enabled? do
        validate :expires_at_before_max_expiry_date
      end
    end

    class_methods do
      extend ::Gitlab::Utils::Override

      def pluck_names
        pluck(:name)
      end

      def with_invalid_expires_at(max_lifetime, limit = 1_000)
        from_union(
          [
            with_expires_at_after(max_lifetime).limit(limit)
          ]
        )
      end

      # Disable lookup by token (token auth) when PATs disabled (FIPS)
      override :find_by_token
      def find_by_token(token)
        return if ::Gitlab::CurrentSettings.personal_access_tokens_disabled?

        pat_token = super

        personal_access_tokens_disabled_by_enterprise_group = pat_token&.user&.enterprise_user? &&
          pat_token.user.enterprise_group.disable_personal_access_tokens?
        return if personal_access_tokens_disabled_by_enterprise_group

        pat_token
      end
    end

    private

    def expiration_policy_enabled?
      return group_level_expiration_policy_enabled? if user.group_managed_account?

      instance_level_expiration_policy_enabled?
    end

    def instance_level_expiration_policy_enabled?
      expiration_policy_licensed? &&
        expiry_date_calculator.instance_level_max_expiry_date
    end

    def max_expiry_date
      expiry_date_calculator.max_expiry_date
    end

    def allow_expires_at_to_be_empty?
      !EE::Gitlab::PersonalAccessTokens::ServiceAccountTokenValidator.new(user).expiry_enforced?
    end

    def expires_at_before_max_expiry_date
      return if expires_at.blank?
      return unless expires_at > max_expiry_date

      errors.add(
        :expires_at,
        format(_("must be before %{expiry_date}"), expiry_date: max_expiry_date)
      )
    end

    def expiration_policy_licensed?
      License.feature_available?(:personal_access_token_expiration_policy)
    end

    def group_level_expiration_policy_enabled?
      expiration_policy_licensed? && expiry_date_calculator.group_level_max_expiry_date
    end

    def expiry_date_calculator
      EE::Gitlab::PersonalAccessTokens::ExpiryDateCalculator.new(user)
    end
    strong_memoize_attr :expiry_date_calculator
  end
end
==== /workspace/gitlab/ee/app/models/ee/preloaders/users_max_access_level_by_project_preloader.rb ====
# frozen_string_literal: true

module EE
  module Preloaders
    module UsersMaxAccessLevelByProjectPreloader
      extend ::Gitlab::Utils::Override

      private

      override :preload_users_namespace_bans
      def preload_users_namespace_bans(users)
        ActiveRecord::Associations::Preloader.new(records: users, associations: :namespace_bans).call
      end
    end
  end
end
==== /workspace/gitlab/ee/app/models/ee/user_detail.rb ====
# frozen_string_literal: true

module EE
  module UserDetail
    extend ActiveSupport::Concern

    prepended do
      belongs_to :provisioned_by_group, class_name: 'Group', optional: true, inverse_of: :provisioned_user_details
      belongs_to :enterprise_group, class_name: 'Group', optional: true, inverse_of: :enterprise_user_details

      scope :with_enterprise_group, -> { where.not(enterprise_group_id: nil) }

      attribute :onboarding_status, ::Gitlab::Database::Type::IndifferentJsonb.new
      store_accessor(
        :onboarding_status, :step_url, :email_opt_in, :initial_registration_type,
        :registration_type, :registration_objective, :setup_for_company,
        :glm_content, :glm_source, :joining_project, :role, :version, prefix: true
      )

      def self.onboarding_status_registration_objectives
        {
          'basics' => 0,
          'move_repository' => 1,
          'code_storage' => 2,
          'exploring' => 3,
          'ci' => 4,
          'other' => 5,
          'joining_team' => 6
        }
      end

      # Values here should match the role enums in app/validators/json_schemas/user_detail_onboarding_status.json
      def self.onboarding_status_roles
        {
          'software_developer' => 0,
          'development_team_lead' => 1,
          'devops_engineer' => 2,
          'systems_administrator' => 3,
          'security_analyst' => 4,
          'data_analyst' => 5,
          'product_manager' => 6,
          'product_designer' => 7,
          'other' => 8
        }
      end

      def onboarding_status_role_name
        self.class.onboarding_status_roles.key(onboarding_status_role)
      end

      def onboarding_status_role=(value)
        if value.present?
          int_value = value.is_a?(String) ? value.to_i : value
          super(int_value)
        else
          super(nil)
        end
      end

      def onboarding_status_registration_objective_name
        self.class.onboarding_status_registration_objectives.key(onboarding_status_registration_objective)
      end

      def onboarding_status_registration_objective=(value)
        if value.present?
          int_value = value.is_a?(String) ? value.to_i : value
          super(int_value)
        else
          super(nil)
        end
      end

      def onboarding_status_joining_project=(value)
        super(::Gitlab::Utils.to_boolean(value, default: false))
      end

      def onboarding_status_setup_for_company=(value)
        super(::Gitlab::Utils.to_boolean(value, default: false))
      end
    end
  end
end
==== /workspace/gitlab/ee/app/models/ee/user_highest_role.rb ====
# frozen_string_literal: true

module EE
  module UserHighestRole
    extend ActiveSupport::Concern

    class_methods do
      extend ::Gitlab::Utils::Override

      override :allowed_values
      def allowed_values
        ::Gitlab::Access.values_with_minimal_access
      end
    end
  end
end
==== /workspace/gitlab/ee/app/models/ee/user_preference.rb ====
# frozen_string_literal: true

module EE
  module UserPreference
    extend ActiveSupport::Concern

    prepended do
      belongs_to :default_duo_add_on_assignment, class_name: 'GitlabSubscriptions::UserAddOnAssignment', optional: true

      validates :roadmap_epics_state, allow_nil: true, inclusion: {
        in: ::Epic.available_states.values, message: "%{value} is not a valid epic state id"
      }

      validates :epic_notes_filter, inclusion: { in: ::UserPreference::NOTES_FILTERS.values }, presence: true

      validate :check_seat_for_default_duo_assigment, if: :default_duo_add_on_assignment_id_changed?

      def eligible_duo_add_on_assignments
        assignable_enum_value = ::GitlabSubscriptions::AddOn.names.values_at(
          *::GitlabSubscriptions::AddOn::SEAT_ASSIGNABLE_DUO_ADD_ONS
        )

        GitlabSubscriptions::UserAddOnAssignment
                                    .by_user(user)
                                    .with_namespaces
                                    .joins(add_on_purchase: :add_on)
                                    .where(add_on_purchase: { subscription_add_ons: { name: assignable_enum_value } })
                                    .where.not(add_on_purchase: { namespace_id: nil })
      end

      def distinct_eligible_duo_add_on_assignments
        distinct_query = 'DISTINCT ON (add_on_purchase.namespace_id) subscription_user_add_on_assignments.*'

        eligible_duo_add_on_assignments.select(distinct_query)
      end

      def check_seat_for_default_duo_assigment
        return if default_duo_add_on_assignment_id.nil?

        return if eligible_duo_add_on_assignments.exists?(id: default_duo_add_on_assignment_id)

        errors.add(:default_duo_add_on_assignment_id,
          "No Duo seat assignments with namespace found with ID #{default_duo_add_on_assignment_id}")
      end

      def no_eligible_duo_add_on_assignments?
        eligible_duo_add_on_assignments.none?
      end

      def get_default_duo_namespace
        return default_duo_add_on_assignment.namespace if default_duo_add_on_assignment.present?

        assignments = distinct_eligible_duo_add_on_assignments.limit(2).to_a

        return if assignments.size != 1

        assignments.first.add_on_purchase.namespace
      end
    end
  end
end
==== /workspace/gitlab/ee/app/models/ee/user.rb ====
# frozen_string_literal: true

module EE
  # User EE mixin
  #
  # This module is intended to encapsulate EE-specific model logic
  # and be prepended in the `User` model
  module User
    extend ActiveSupport::Concern
    extend ::Gitlab::Utils::Override
    include ::Gitlab::Utils::StrongMemoize

    include AuditorUserHelper
    include GitlabSubscriptions::SubscriptionHelper

    DEFAULT_ROADMAP_LAYOUT = 'months'
    DEFAULT_GROUP_VIEW = 'details'
    ELASTICSEARCH_TRACKED_FIELDS = %w[id username email public_email name admin state
      user_detail_organization timezone external otp_required_for_login].freeze

    prepended do
      include UsageStatistics
      include PasswordComplexity
      include IdentityVerifiable
      include Elastic::ApplicationVersionedSearch
      include Ai::Model
      include Ai::UserAuthorizable

      EMAIL_OPT_IN_SOURCE_ID_GITLAB_COM = 1

      # We aren't using the `auditor?` method for the `if` condition here
      # because `auditor?` returns `false` when the `auditor` column is `true`
      # and the auditor add-on absent. We want to run this validation
      # regardless of the add-on's presence, so we need to check the `auditor`
      # column directly.
      validate :auditor_requires_license_add_on, if: :auditor
      validate :cannot_be_admin_and_auditor

      validate :enterprise_user_email_change, on: :update, if: ->(user) {
        user.email_changed? && user.enterprise_user? && !user.skip_enterprise_user_email_change_restrictions?
      }

      after_create :perform_user_cap_check
      after_create :associate_with_enterprise_group
      after_update :email_changed_hook, if: :saved_change_to_email?
      after_update :dismiss_compromised_password_detection_alerts, if: :saved_change_to_encrypted_password?

      delegate :shared_runners_minutes_limit, :shared_runners_minutes_limit=,
        :extra_shared_runners_minutes_limit, :extra_shared_runners_minutes_limit=,
        to: :namespace
      delegate :provisioned_by_group, :provisioned_by_group=,
        :provisioned_by_group_id, :provisioned_by_group_id=,
        :onboarding_status_step_url, :onboarding_status_step_url=,
        :onboarding_status_registration_objective, :onboarding_status_registration_objective=,
        :onboarding_status_registration_objective_name,
        :onboarding_status_setup_for_company, :onboarding_status_setup_for_company=,
        :onboarding_status_registration_type, :onboarding_status_registration_type=,
        :onboarding_status_email_opt_in, :onboarding_status_email_opt_in=, :onboarding_status, :onboarding_status=,
        :onboarding_status_initial_registration_type, :onboarding_status_initial_registration_type=,
        :onboarding_status_glm_content, :onboarding_status_glm_content=,
        :onboarding_status_glm_source, :onboarding_status_glm_source=,
        :onboarding_status_version, :onboarding_status_version=,
        :onboarding_status_joining_project, :onboarding_status_joining_project=, :onboarding_status_role, :onboarding_status_role=, :onboarding_status_role_name,
        :enterprise_group, :enterprise_group=,
        :enterprise_group_id, :enterprise_group_id=, :enterprise_group_associated_at, :enterprise_group_associated_at=,
        to: :user_detail, allow_nil: true

      delegate :enabled_zoekt?, :enabled_zoekt, :enabled_zoekt=,
        to: :user_preference

      has_many :epics,                    foreign_key: :author_id
      has_many :test_reports,             foreign_key: :author_id, inverse_of: :author, class_name: 'RequirementsManagement::TestReport'
      has_many :assigned_epics,           foreign_key: :assignee_id, class_name: "Epic"
      has_many :path_locks,               dependent: :destroy # rubocop:disable Cop/ActiveRecordDependent -- legacy usage
      has_many :vulnerability_feedback, foreign_key: :author_id, class_name: 'Vulnerabilities::Feedback'
      has_many :vulnerability_state_transitions, foreign_key: :author_id, class_name: 'Vulnerabilities::StateTransition', inverse_of: :author
      has_many :vulnerability_severity_overrides, foreign_key: :author_id, class_name: 'Vulnerabilities::SeverityOverride', inverse_of: :author
      has_many :commented_vulnerability_feedback, foreign_key: :comment_author_id, class_name: 'Vulnerabilities::Feedback'
      has_many :boards_epic_user_preferences, class_name: 'Boards::EpicUserPreference', inverse_of: :user
      has_many :epic_board_recent_visits, class_name: 'Boards::EpicBoardRecentVisit', inverse_of: :user

      has_many :approvals,                dependent: :destroy # rubocop:disable Cop/ActiveRecordDependent -- legacy usage
      has_many :approvers,                dependent: :destroy # rubocop:disable Cop/ActiveRecordDependent -- legacy usage

      has_many :minimal_access_group_members, -> { where(access_level: [::Gitlab::Access::MINIMAL_ACCESS]) }, class_name: 'GroupMember'
      has_many :minimal_access_groups, through: :minimal_access_group_members, source: :group
      has_many :elevated_members, -> { elevated_guests }, class_name: 'Member'

      has_many :requested_member_approvals, class_name: '::GitlabSubscriptions::MemberManagement::MemberApproval', foreign_key: 'requested_by_id'
      has_many :reviewed_member_approvals, class_name: '::GitlabSubscriptions::MemberManagement::MemberApproval', foreign_key: 'reviewed_by_id'

      has_many :users_ops_dashboard_projects
      has_many :ops_dashboard_projects, through: :users_ops_dashboard_projects, source: :project
      has_many :users_security_dashboard_projects
      has_many :security_dashboard_projects, through: :users_security_dashboard_projects, source: :project

      has_many :group_saml_identities, -> { where.not(saml_provider_id: nil) }, class_name: "::Identity"
      has_many :group_saml_providers, through: :group_saml_identities, source: :saml_provider

      # Protected Branch Access
      # rubocop:disable Cop/ActiveRecordDependent -- legacy usage
      has_many :protected_branch_merge_access_levels, dependent: :destroy, class_name: "::ProtectedBranch::MergeAccessLevel"
      # rubocop:enable Cop/ActiveRecordDependent -- legacy usage
      # rubocop:disable Cop/ActiveRecordDependent -- legacy usage
      has_many :protected_branch_push_access_levels, dependent: :destroy, class_name: "::ProtectedBranch::PushAccessLevel"
      # rubocop:enable Cop/ActiveRecordDependent -- legacy usage
      # rubocop:disable Cop/ActiveRecordDependent -- legacy usage
      has_many :protected_branch_unprotect_access_levels, dependent: :destroy, class_name: "::ProtectedBranch::UnprotectAccessLevel"
      # rubocop:enable Cop/ActiveRecordDependent -- legacy usage

      has_many :deployment_approvals, class_name: 'Deployments::Approval'

      has_many :smartcard_identities

      has_many :group_scim_identities, class_name: 'GroupScimIdentity'
      has_many :instance_scim_identities, -> { where(group_id: nil) }, class_name: 'ScimIdentity'
      has_many :scim_group_memberships, -> { where(group_id: nil) }, class_name: 'Authn::ScimGroupMembership'

      has_many :board_preferences, class_name: 'BoardUserPreference', inverse_of: :user

      belongs_to :managing_group, class_name: 'Group', optional: true, inverse_of: :managed_users

      has_many :user_permission_export_uploads

      has_many :oncall_participants, -> { not_removed }, class_name: 'IncidentManagement::OncallParticipant', inverse_of: :user
      has_many :oncall_rotations, class_name: 'IncidentManagement::OncallRotation', through: :oncall_participants, source: :rotation
      has_many :oncall_schedules, -> { distinct }, class_name: 'IncidentManagement::OncallSchedule', through: :oncall_rotations, source: :schedule
      has_many :escalation_rules, -> { not_removed }, class_name: 'IncidentManagement::EscalationRule', inverse_of: :user
      has_many :escalation_policies, -> { distinct }, class_name: 'IncidentManagement::EscalationPolicy', through: :escalation_rules, source: :policy

      has_many :namespace_bans, class_name: 'Namespaces::NamespaceBan'

      has_many :workspaces, class_name: 'RemoteDevelopment::Workspace', inverse_of: :user

      has_many :dependency_list_exports, class_name: 'Dependencies::DependencyListExport', inverse_of: :author

      # rubocop:disable Cop/ActiveRecordDependent -- legacy usage
      has_many :assigned_add_ons, class_name: 'GitlabSubscriptions::UserAddOnAssignment', inverse_of: :user, dependent: :destroy
      # rubocop:enable Cop/ActiveRecordDependent -- legacy usage

      has_many :created_namespace_cluster_agent_mappings,
        class_name: 'RemoteDevelopment::NamespaceClusterAgentMapping',
        inverse_of: :user

      has_many :created_organization_cluster_agent_mappings,
        class_name: 'RemoteDevelopment::OrganizationClusterAgentMapping',
        foreign_key: 'creator_id',
        inverse_of: :user

      has_many :country_access_logs, class_name: 'Users::CountryAccessLog', inverse_of: :user

      has_one :pipl_user, class_name: 'ComplianceManagement::PiplUser'

      has_one :user_admin_role, class_name: 'Authz::UserAdminRole'
      has_one :admin_role, through: :user_admin_role

      # TODO: remove as part of https://gitlab.com/groups/gitlab-org/-/epics/17390
      has_one :user_member_role, class_name: 'Users::UserMemberRole'
      has_one :member_role, class_name: 'MemberRole', through: :user_member_role

      has_many :user_group_member_roles, inverse_of: :user, class_name: 'Authz::UserGroupMemberRole'

      has_many :ai_conversation_threads, class_name: 'Ai::Conversation::Thread', foreign_key: :user_id
      has_many :ai_conversation_messages, class_name: 'Ai::Conversation::Message', through: :ai_conversation_threads, source: :messages

      has_many :subscription_seat_assignments, class_name: 'GitlabSubscriptions::SeatAssignment'

      has_many :compromised_password_detections, class_name: 'Users::CompromisedPasswordDetection', inverse_of: :user

      has_many :arkose_sessions, class_name: 'Users::ArkoseSession', inverse_of: :user

      scope :auditors, -> { where('auditor IS true') }
      scope :managed_by, ->(group) { where(managing_group: group) }

      scope :excluding_guests_and_requests, -> do
        subquery = ::Member
          .select(1)
          .where(::Member.arel_table[:user_id].eq(::User.arel_table[:id]))
          .with_elevated_guests

        subquery = subquery.non_request

        where('EXISTS (?)', subquery)
          .allow_cross_joins_across_databases(url: 'https://gitlab.com/gitlab-org/gitlab/-/issues/422405')
      end

      scope :guests_with_elevating_role, -> do
        joins(:user_highest_role).joins(:elevated_members)
          .where(user_highest_role: { highest_access_level: ::Gitlab::Access::GUEST })
          .allow_cross_joins_across_databases(url: 'https://gitlab.com/gitlab-org/gitlab/-/issues/422405')
      end

      scope :with_admin_role, ->(admin_role_id) do
        joins(:user_member_role)
          .where(user_member_role: { member_role_id: admin_role_id })
      end

      scope :subscribed_for_admin_email, -> { where(admin_email_unsubscribed_at: nil) }

      scope :with_provider, ->(provider) do
        joins(:identities).where(identities: { provider: provider })
      end
      scope :with_saml_provider, ->(saml_provider) do
        joins(:identities).where(identities: { saml_provider: saml_provider })
      end
      scope :with_provisioning_group, ->(group) do
        joins(:user_detail).where(user_detail: { provisioned_by_group: group })
      end

      scope :with_invalid_expires_at_tokens, ->(expiration_date) do
        where(id: ::PersonalAccessToken.with_invalid_expires_at(expiration_date).select(:user_id))
      end

      scope :with_group_scim_identities_by_extern_uid, ->(extern_uid) { joins(:group_scim_identities).merge(GroupScimIdentity.with_extern_uid(extern_uid)) }

      scope :with_instance_scim_identities_by_extern_uid, ->(extern_uid) { joins(:instance_scim_identities).merge(ScimIdentity.with_extern_uid(extern_uid)) }

      scope :with_email_domain, ->(domain) { where("lower(split_part(email, '@', 2)) = ?", domain.downcase) }

      scope :excluding_enterprise_users_of_group, ->(group) { left_join_user_detail.where('user_details.enterprise_group_id != ? OR user_details.enterprise_group_id IS NULL', group.id) }

      scope :security_policy_bots_for_projects, ->(projects) do
        security_policy_bot
          .joins(:members)
          .where(members: { source: projects })
          .allow_cross_joins_across_databases(url: "https://gitlab.com/gitlab-org/gitlab/-/issues/422405")
      end

      scope :orphaned_security_policy_bots, -> do
        security_policy_bot
        .joins("LEFT OUTER JOIN members ON members.user_id = users.id AND members.type = 'ProjectMember'")
        .left_outer_joins(:ghost_user_migration)
        .where(members: { id: nil }, ghost_user_migrations: { id: nil })
      end

      accepts_nested_attributes_for :namespace
      accepts_nested_attributes_for :custom_attributes

      enum :roadmap_layout, { weeks: 1, months: 4, quarters: 12 }

      # User's Group preference
      # Note: When adding an option, it's value MUST equal to the last value + 1.
      enum :group_view, { details: 1, security_dashboard: 2 }, prefix: true
      scope :group_view_details, -> { where('group_view = ? OR group_view IS NULL', group_view[:details]) }
      scope :unconfirmed_and_created_before, ->(created_cut_off) { human.with_state(:active).where(confirmed_at: nil).where('created_at < ?', created_cut_off).where(sign_in_count: 0) }

      # If user cap is reached any user that is getting marked :active from :deactivated
      # should get blocked pending approval
      state_machine :state do
        after_transition deactivated: :active do |user|
          user.block_pending_approval if ::User.user_cap_reached?
        end
      end
    end

    class_methods do
      extend ::Gitlab::Utils::Override

      def non_ldap
        joins('LEFT JOIN identities ON identities.user_id = users.id')
          .where('identities.provider IS NULL OR identities.provider NOT LIKE ?', 'ldap%')
      end

      def find_by_smartcard_identity(certificate_subject, certificate_issuer)
        joins(:smartcard_identities)
          .find_by(smartcard_identities: { subject: certificate_subject, issuer: certificate_issuer })
      end

      def billable
        scope = active.without_bots

        if License.current&.exclude_guests_from_active_count?
          scope = scope.excluding_guests_and_requests
        end

        scope
      end

      def non_billable_users_for_billable_management(user_ids)
        # Billable management is done for Ultimate Licenses, so returning None for other Licenses
        return ::User.none unless License.current&.exclude_guests_from_active_count?

        scope = active.without_bots
        billable_user_ids_excluding_lte_guests_and_requests = ::User.select(:id).where(id: user_ids)
                                                       .excluding_guests_and_requests
        scope.where(id: user_ids).where.not(id: billable_user_ids_excluding_lte_guests_and_requests)
      end

      def user_cap_reached?
        return false unless ::Gitlab::CurrentSettings.seat_control_user_cap?

        billable.limit(user_cap_max + 1).count >= user_cap_max
      end

      def user_cap_max
        ::Gitlab::CurrentSettings.new_user_signups_cap
      end

      override :random_password
      def random_password
        1000.times do
          password = super
          next unless complexity_matched? password

          return password
        end
      end

      # override
      def use_separate_indices?
        true
      end

      def filter_items(filter_name)
        case filter_name
        when 'auditors'
          auditors
        else
          super
        end
      end
    end

    def should_use_security_policy_bot_avatar?
      security_policy_bot?
    end

    def security_policy_bot_static_avatar_path(size = nil)
      if Avatarable::USER_AVATAR_SIZES.include?(size)
        avatar_image = ActionController::Base.helpers.image_path("bot_avatars/security-bot_#{size}.png")
        return ::Gitlab::Utils.append_path(Settings.gitlab.base_url, avatar_image)
      end

      ::Gitlab::Utils.append_path(Settings.gitlab.base_url, ActionController::Base.helpers.image_path('bot_avatars/security-bot.png'))
    end

    override :toggle_star
    def toggle_star(project)
      super
      project.maintain_elasticsearch_update if self.active? && project.maintaining_elasticsearch?
    end

    def expired_sso_session_saml_providers_with_access_restricted
      expired_sso_session_saml_providers.select do |saml_provider|
        ::Gitlab::Auth::GroupSaml::SsoEnforcer.new(saml_provider, user: self).access_restricted?
      end
    end

    def expired_sso_session_saml_providers
      group_saml_providers.id_not_in(active_sso_sessions_saml_provider_ids)
    end

    def active_sso_sessions_saml_provider_ids
      ::Gitlab::Auth::GroupSaml::SsoEnforcer.sessions_time_remaining_for_expiry.each_with_object([]) do |session, result|
        result << session[:provider_id] if session[:time_remaining] > 0
      end
    end

    def pending_billable_invitations
      if ::License.current.exclude_guests_from_active_count?
        pending_invitations.where('access_level > ?', ::Gitlab::Access::GUEST)
      else
        pending_invitations
      end
    end

    def external?
      return true if security_policy_bot?

      read_attribute(:external)
    end

    def cannot_be_admin_and_auditor
      if admin? && auditor?
        errors.add(:admin, 'user cannot also be an Auditor.')
      end
    end

    def auditor_requires_license_add_on
      unless license_allows_auditor_user?
        errors.add(:auditor, 'user cannot be created without the "GitLab_Auditor_User" addon')
      end
    end

    def auditor?
      self.auditor && license_allows_auditor_user?
    end

    def access_level
      if auditor?
        :auditor
      else
        super
      end
    end

    def access_level=(new_level)
      new_level = new_level.to_s
      return unless %w[admin auditor regular].include?(new_level)

      self.admin = (new_level == 'admin')
      self.auditor = (new_level == 'auditor')
    end

    def email_domain
      Mail::Address.new(email).domain
    end

    def available_custom_project_templates(search: nil, subgroup_id: nil, project_id: nil)
      CustomProjectTemplatesFinder
        .new(current_user: self, search: search, subgroup_id: subgroup_id, project_id: project_id)
        .execute
    end

    def use_elasticsearch?
      ::Gitlab::CurrentSettings.elasticsearch_search?
    end

    override :maintaining_elasticsearch?
    def maintaining_elasticsearch?
      ::Gitlab::CurrentSettings.elasticsearch_indexing?
    end

    # override
    def maintain_elasticsearch_update
      super if update_elasticsearch?
    end

    def update_elasticsearch?
      changed_fields = previous_changes.keys
      changed_fields && (changed_fields & ELASTICSEARCH_TRACKED_FIELDS).any?
    end

    def search_membership_ancestry
      members.flat_map do |member|
        member.source&.elastic_namespace_ancestry
      end
    end

    def available_subgroups_with_custom_project_templates(group_id = nil)
      found_groups = GroupsWithTemplatesFinder.new(self, group_id).execute

      if ::Feature.enabled?(:project_templates_without_min_access, self)
        params = {
          filter_group_ids: found_groups.select(:custom_project_templates_group_id)
        }

        ::GroupsFinder.new(self, params)
          .execute
          .preload(:projects)
          .joins(:projects)
          .without_order
          .distinct
      else
        params = {
          min_access_level: ::Gitlab::Access::REPORTER
        }

        ::GroupsFinder.new(self, params)
          .execute
          .where(id: found_groups.select(:custom_project_templates_group_id))
          .preload(:projects)
          .joins(:projects)
          .without_order
          .distinct
      end
    end

    def roadmap_layout
      super || DEFAULT_ROADMAP_LAYOUT
    end

    def group_view
      super || DEFAULT_GROUP_VIEW
    end

    # Returns true if the user owns a group
    # that has never had a trial (now or in the past)
    def owns_group_without_trial?
      owned_groups
        .include_gitlab_subscription
        .top_level
        .where(gitlab_subscriptions: { trial_ends_on: nil })
        .any?
    end

    def has_exact_code_search?
      ::Gitlab::CurrentSettings.zoekt_search_enabled?
    end

    def zoekt_indexed_namespaces
      ::Search::Zoekt::EnabledNamespace.where(
        namespace: ::Namespace
          .from("(#{namespace_union_for_reporter_developer_maintainer_owned}) #{::Namespace.table_name}")
      )
    end

    # Returns true if the user is a Reporter or higher on any namespace
    # currently on a paid plan
    def belongs_to_paid_namespace?(plans: ::Plan::PAID_HOSTED_PLANS, exclude_trials: false)
      paid_namespaces(plans: plans, exclude_trials: exclude_trials).any?
    end

    # Returns true if the user is an Owner on any namespace currently on
    # a paid plan
    def owns_paid_namespace?(plans: ::Plan::PAID_HOSTED_PLANS)
      ::Namespace
        .from("(#{namespace_union_for_owned}) #{::Namespace.table_name}")
        .include_gitlab_subscription
        .where(gitlab_subscriptions: { hosted_plan: ::Plan.where(name: plans) })
        .allow_cross_joins_across_databases(url: "https://gitlab.com/gitlab-org/gitlab/-/issues/419988")
        .any?
    end

    override :has_current_license?
    def has_current_license?
      License.current.present?
    end

    def using_license_seat?
      active? &&
        !internal? &&
        !project_bot? &&
        !service_account? &&
        has_current_license? &&
        paid_in_current_license?
    end

    def using_gitlab_com_seat?(namespace)
      ::Gitlab.com? &&
        namespace.present? &&
        active? &&
        !namespace.root_ancestor.free_plan? &&
        namespace.root_ancestor.billed_user_ids[:user_ids].include?(self.id)
    end

    def assigned_to_duo_enterprise?(container)
      namespace = ::Gitlab::Saas.feature_available?(:gitlab_duo_saas_only) ? container.root_ancestor : nil

      GitlabSubscriptions::AddOnPurchase
        .for_duo_enterprise
        .active
        .by_namespace(namespace)
        .assigned_to_user(self).exists?
    end

    def assigned_to_duo_pro?(container)
      namespace = ::Gitlab::Saas.feature_available?(:gitlab_duo_saas_only) ? container.root_ancestor : nil

      GitlabSubscriptions::AddOnPurchase
        .for_duo_pro_or_duo_enterprise
        .active
        .by_namespace(namespace)
        .assigned_to_user(self).exists?
    end

    def assigned_to_duo_add_ons?(container)
      namespace = ::Gitlab::Saas.feature_available?(:gitlab_duo_saas_only) ? container.root_ancestor : nil

      GitlabSubscriptions::AddOnPurchase
        .for_duo_add_ons
        .active
        .by_namespace(namespace)
        .assigned_to_user(self)
        .exists?
    end

    def group_sso?(group)
      return false unless group

      if group_saml_identities.loaded?
        group_saml_identities.any? { |identity| identity.saml_provider.group_id == group.id }
      else
        group_saml_identities.where(saml_provider: group.saml_provider).any?
      end
    end

    def group_managed_account?
      managing_group.present?
    end

    def managed_by_group?(group)
      return false unless group

      group.domain_verification_available? && enterprise_user_of_group?(group)
    end

    def managed_by_user?(user, group: user_detail.enterprise_group)
      return false unless user && group

      managed_by_group?(group) && Ability.allowed?(user, :owner_access, group)
    end

    override :ldap_sync_time
    def ldap_sync_time
      ::Gitlab.config.ldap['sync_time']
    end

    override :allow_password_authentication_for_web?
    def allow_password_authentication_for_web?(*)
      return false if group_managed_account?
      return false if password_authentication_disabled_by_enterprise_group?

      super
    end

    override :allow_password_authentication_for_git?
    def allow_password_authentication_for_git?(*)
      return false if group_managed_account?
      return false if password_authentication_disabled_by_enterprise_group?

      super
    end

    def password_authentication_disabled_by_enterprise_group?
      return false unless enterprise_user?
      return false unless enterprise_group.saml_provider

      enterprise_group.saml_provider.enabled? && enterprise_group.saml_provider.disable_password_authentication_for_enterprise_users?
    end

    def enterprise_user_of_group?(group)
      enterprise_group_id == group.id
    end

    def enterprise_user?
      # NOTE: Double check is added since enterprise_group_id is a lose foreign key and this is a high traffic method
      # This would make sure that we don't fire a query in most cases on gitlab.com, as we have more normal users than enterprise users.
      enterprise_group_id.present? && enterprise_group.present?
    end

    def gitlab_employee?
      gitlab_team_member?
    end

    def gitlab_team_member?
      human? && gitlab_com_member?
    end

    def gitlab_service_user?
      service_user? && gitlab_com_member?
    end

    def gitlab_bot?
      bot? && gitlab_com_member?
    end

    override :can_access_admin_area?
    def can_access_admin_area?
      return true if super

      has_admin_custom_permissions?
    end
    strong_memoize_attr :can_access_admin_area?

    def security_dashboard
      InstanceSecurityDashboard.new(self)
    end

    # Returns the groups a user has access to, either through a membership or a project authorization
    override :authorized_groups
    def authorized_groups(with_minimal_access: true)
      return super() unless with_minimal_access

      ::Group.unscoped do
        ::Group.from_union([super(), available_minimal_access_groups])
      end
    end

    def find_or_init_board_epic_preference(board_id:, epic_id:)
      boards_epic_user_preferences.find_or_initialize_by(
        board_id: board_id, epic_id: epic_id)
    end

    # GitLab.com users should not be able to remove themselves
    # when they cannot verify their local password, because it
    # isn't set (using third party authentication).
    override :can_remove_self?
    def can_remove_self?
      return true unless ::Gitlab.com?

      !password_automatically_set?
    end

    def activate_based_on_user_cap?
      !blocked_auto_created_oauth_ldap_user? &&
        blocked_pending_approval? &&
        self.class.user_cap_max.present?
    end

    def blocked_auto_created_oauth_ldap_user?
      identities.any? && block_auto_created_users?
    end

    def privatized_by_abuse_automation?
      # Prevent abuse automation names are expected to be in the format: ghost-:id-:id. Ex: ghost-123-4567
      # More context: https://gitlab.com/gitlab-org/customers-gitlab-com/-/issues/3871 for more context on the
      private_profile? && name.match?(/\Aghost-\d+-\d+\z/)
    end

    def banned_from_namespace?(namespace)
      # Always load the entire collection to allow preloading and avoiding N+1 queries.
      namespace_bans.any? { |namespace_ban| namespace_ban.namespace == namespace }
    end

    def namespace_ban_for(namespace)
      namespace_bans.find_by!(namespace: namespace)
    end

    def registration_audit_details
      {
        id: id,
        username: username,
        name: name,
        email: email,
        access_level: access_level
      }
    end

    def skip_enterprise_user_email_change_restrictions!
      @skip_enterprise_user_email_change_restrictions = true # rubocop:disable Gitlab/ModuleWithInstanceVariables
    end

    def skip_enterprise_user_email_change_restrictions?
      @skip_enterprise_user_email_change_restrictions
    end

    def contributed_epic_groups
      contributed_group_ids = ::Event.select(:group_id)
        .epic_contributions
        .where(author_id: self)
        .created_after(Time.current - 1.year)
        .distinct
        .without_order

      ::Group.where(id: contributed_group_ids).not_aimed_for_deletion
    end

    def contributed_note_groups
      contributed_group_ids = ::Event.select(:group_id)
        .group_note_contributions
        .where(author_id: self)
        .created_after(Time.current - 1.year)
        .distinct
        .without_order

      ::Group.where(id: contributed_group_ids).not_aimed_for_deletion
    end

    protected

    override :password_required?
    def password_required?(*)
      return false if service_account? || group_managed_account?

      super
    end

    # override, from Devise::Confirmable
    def send_confirmation_instructions
      super

      ::Gitlab::Audit::Auditor.audit({
        name: 'email_confirmation_sent',
        author: self,
        scope: self,
        message: "Confirmation instructions sent to: #{unconfirmed_email}",
        target: self,
        additional_details: {
          target_type: "Email",
          current_email: email,
          unconfirmed_email: unconfirmed_email
        }
      })
    end

    private

    def ci_namespace_mirrors_permitted_to(permission)
      ::Ci::NamespaceMirror.by_group_and_descendants(
        group_members
          .joins(:member_role)
          .merge(::MemberRole.permissions_where(permission => true))
          .pluck('members.source_id') # rubocop: disable Database/AvoidUsingPluckWithoutLimit -- limited to a single user's groups
      )
    end

    def enterprise_user_email_change
      return if user_detail.enterprise_group.owner_of_email?(email)

      errors.add(:email, _("must be owned by the user's enterprise group"))
    end

    def gitlab_com_member?
      ::Gitlab::Com.gitlab_com_group_member?(self)
    end
    strong_memoize_attr :gitlab_com_member?

    def block_auto_created_users?
      if ldap_user?
        provider = ldap_identity.provider

        return false unless provider
        return false unless ::Gitlab::Auth::Ldap::Config.enabled?

        ::Gitlab::Auth::Ldap::Config.new(provider).block_auto_created_users
      else
        ::Gitlab.config.omniauth.block_auto_created_users
      end
    end

    def paid_namespaces(plans: ::Plan::PAID_HOSTED_PLANS, exclude_trials: false)
      paid_hosted_plans = ::Plan::PAID_HOSTED_PLANS & plans

      namespaces_with_plans = ::Namespace
        .from("(#{namespace_union_for_reporter_developer_maintainer_owned}) #{::Namespace.table_name}")
        .include_gitlab_subscription
        .where(gitlab_subscriptions: { hosted_plan: ::Plan.where(name: paid_hosted_plans) })
        .allow_cross_joins_across_databases(url: "https://gitlab.com/gitlab-org/gitlab/-/issues/419988")

      if exclude_trials
        return namespaces_with_plans
          .where(gitlab_subscriptions: { trial: [nil, false] })
          .or(namespaces_with_plans.where(gitlab_subscriptions: { trial_ends_on: ..Date.yesterday }))
          .select(:id)
      end

      namespaces_with_plans.select(:id)
    end

    def namespace_union_for_owned(select = :id)
      ::Gitlab::SQL::Union.new(
        [
          ::Namespace.select(select).where(type: ::Namespaces::UserNamespace.sti_name, owner: self),
          owned_groups.select(select).top_level
        ]).to_sql
    end

    def namespace_union_for_reporter_developer_maintainer_owned(select = :id)
      ::Gitlab::SQL::Union.new(
        [
          ::Namespace.select(select).where(type: ::Namespaces::UserNamespace.sti_name, owner: self),
          reporter_developer_maintainer_owned_groups.select(select).top_level
        ]).to_sql
    end

    def paid_in_current_license?
      return true unless License.current.exclude_guests_from_active_count?

      highest_role > ::Gitlab::Access::GUEST || elevated_members.any?
    end

    def available_minimal_access_groups
      return ::Group.none unless License.feature_available?(:minimal_access_role)
      return minimal_access_groups unless ::Gitlab::CurrentSettings.should_check_namespace_plan?

      minimal_access_groups.with_feature_available_in_plan(:minimal_access_role)
    end

    def perform_user_cap_check
      return unless self.class.user_cap_reached?
      return if active?

      run_after_commit do
        SetUserStatusBasedOnUserCapSettingWorker.perform_async(id)
      end
    end

    def associate_with_enterprise_group
      # see callback reasoning: https://gitlab.com/gitlab-org/gitlab/-/merge_requests/130735#note_1556734817
      run_after_commit do
        ::Groups::EnterpriseUsers::AssociateWorker.perform_async(id)
      end
    end

    def email_changed_hook
      run_after_commit do
        if enterprise_user?
          ::Groups::EnterpriseUsers::DisassociateWorker.perform_async(id)
        end
      end
    end

    def dismiss_compromised_password_detection_alerts
      run_after_commit do
        ::Users::CompromisedPasswords::ResolveDetectionForUserService.new(self).execute
      end
    end

    override :should_delay_delete?
    def should_delay_delete?(*args)
      super && !belongs_to_paid_namespace?(exclude_trials: true)
    end

    override :audit_lock_access
    def audit_lock_access(reason: nil)
      return if access_locked?

      if !reason && attempts_exceeded?
        reason = 'excessive failed login attempts'
      end

      ::Gitlab::Audit::Auditor.audit(
        name: 'user_access_locked',
        author: ::Users::Internal.admin_bot,
        scope: self,
        target: self,
        message: ['User access locked', reason].compact.join(' - ')
      )
    end

    override :audit_unlock_access
    def audit_unlock_access(author: self)
      # We can't use access_locked? because it checks if locked_at <
      # User.unlock_in.ago. If we use access_locked? and the lock is already
      # expired the call to unlock_access! when a user tries to login will not
      # log an audit event as expected
      return unless locked_at.present?

      ::Gitlab::Audit::Auditor.audit(
        name: 'user_access_unlocked',
        author: author,
        scope: self,
        target: self,
        message: 'User access unlocked'
      )
    end

    def has_admin_custom_permissions?
      Authz::Admin.new(self).available_permissions_for_user.present?
    end
  end
end
==== /workspace/gitlab/ee/app/models/ee/users/banned_user.rb ====
# frozen_string_literal: true

module EE
  module Users
    module BannedUser
      extend ActiveSupport::Concern

      prepended do
        after_commit :reindex_issues_and_merge_requests, on: [:create, :destroy]
      end

      private

      def reindex_issues_and_merge_requests
        ElasticAssociationIndexerWorker.perform_async(user.class.name, user.id, %i[issues merge_requests])
      end
    end
  end
end
==== /workspace/gitlab/ee/app/models/ee/users_statistics.rb ====
# frozen_string_literal: true

module EE
  module UsersStatistics
    extend ActiveSupport::Concern
    extend ::Gitlab::Utils::Override

    def billable
      (base_billable_users + guest_billable_users).sum
    end

    def non_billable
      return base_non_billable + without_groups_and_projects if exclude_guests_from_active_count?

      base_non_billable
    end

    def non_billable_guests
      with_highest_role_guest - with_highest_role_guest_with_custom_role
    end

    override :active
    def active
      super + with_highest_role_minimal_access
    end

    private

    def base_non_billable
      return bots + non_billable_guests if exclude_guests_from_active_count?

      bots
    end

    def base_billable_users
      [
        with_highest_role_planner,
        with_highest_role_reporter,
        with_highest_role_developer,
        with_highest_role_maintainer,
        with_highest_role_owner
      ]
    end

    def guest_billable_users
      if exclude_guests_from_active_count?
        [with_highest_role_guest_with_custom_role]
      else
        [without_groups_and_projects, with_highest_role_guest, with_highest_role_minimal_access]
      end
    end

    def exclude_guests_from_active_count?
      License.current&.exclude_guests_from_active_count?
    end

    class_methods do
      extend ::Gitlab::Utils::Override

      private

      override :highest_role_stats
      def highest_role_stats
        super.merge(
          with_highest_role_minimal_access: batch_count_for_access_level(::Gitlab::Access::MINIMAL_ACCESS),
          with_highest_role_guest_with_custom_role: count_guests_with_elevating_custom_role)
      end

      def count_guests_with_elevating_custom_role
        ::Gitlab::Database::BatchCount.batch_count(::User.guests_with_elevating_role)
      end
    end
  end
end
==== /workspace/gitlab/ee/app/models/epic_user_mention.rb ====
# frozen_string_literal: true

class EpicUserMention < UserMention
  belongs_to :epic
  belongs_to :note
end
==== /workspace/gitlab/ee/app/models/geo/push_user.rb ====
# frozen_string_literal: true

class Geo::PushUser
  include ::Gitlab::Identifier

  def initialize(gl_id)
    @gl_id = gl_id
  end

  def user
    @user ||= identify_using_ssh_key(gl_id)
  end

  def deploy_key
    @deploy_key ||= identify_using_deploy_key(gl_id)
  end

  private

  attr_reader :gl_id
end
==== /workspace/gitlab/ee/app/models/gitlab_subscriptions/user_add_on_assignment.rb ====
# frozen_string_literal: true

module GitlabSubscriptions
  class UserAddOnAssignment < ApplicationRecord
    include EachBatch

    has_paper_trail(
      versions: {
        class_name: 'GitlabSubscriptions::UserAddOnAssignmentVersion'
      },
      meta: {
        organization_id: :add_on_purchase_organization_id,
        namespace_path: :namespace_traversal_path,
        user_id: :user_id,
        add_on_name: :add_on_name,
        purchase_id: :add_on_purchase_id
      }
    )

    belongs_to :user, inverse_of: :assigned_add_ons
    belongs_to :add_on_purchase, class_name: 'GitlabSubscriptions::AddOnPurchase', inverse_of: :assigned_users

    validates :user, :add_on_purchase, presence: true
    validates :add_on_purchase_id, uniqueness: { scope: :user_id }

    scope :by_user, ->(user) { where(user: user) }
    scope :for_user_ids, ->(user_ids) { where(user_id: user_ids) }
    scope :with_namespaces, -> { includes(add_on_purchase: :namespace) }
    scope :for_add_on_purchases, ->(add_on_purchases) { where(add_on_purchase: add_on_purchases) }
    scope :for_active_add_on_purchases, ->(add_on_purchases) do
      joins(:add_on_purchase).merge(add_on_purchases.active)
    end

    scope :for_active_gitlab_duo_purchase, -> do
      for_active_add_on_purchases(::GitlabSubscriptions::AddOnPurchase.for_duo_add_ons)
    end

    scope :for_active_add_on_purchase_ids, ->(add_on_purchase_ids) do
      for_active_add_on_purchases(::GitlabSubscriptions::AddOnPurchase.where(id: add_on_purchase_ids))
    end

    scope :order_by_id_desc, -> { order(id: :desc) }

    delegate :namespace, :namespace_id, to: :add_on_purchase

    def self.pluck_user_ids
      pluck(:user_id)
    end

    def namespace_traversal_path
      add_on_purchase.namespace&.traversal_path
    end

    # Get organization_id from add_on_purchase association for paper trail versioning record.
    #
    # We cannot rely on this model because its organization_id
    # is set using a database before INSERT trigger, at the
    # time paper trail version record is created this model is dirty with
    # organization_id as nil.
    def add_on_purchase_organization_id
      add_on_purchase.organization_id
    end

    def add_on_name
      add_on_purchase.add_on.name
    end
  end
end
==== /workspace/gitlab/ee/app/models/gitlab_subscriptions/user_add_on_assignment_version.rb ====
# frozen_string_literal: true

module GitlabSubscriptions
  class UserAddOnAssignmentVersion < ApplicationRecord
    include PaperTrail::VersionConcern
    include EachBatch
  end
end
==== /workspace/gitlab/ee/app/models/group_scim_identity.rb ====
# frozen_string_literal: true

class GroupScimIdentity < ApplicationRecord # rubocop:disable Gitlab/NamespacedClass,Gitlab/BoundedContexts -- Split from existing file
  include Sortable
  include CaseSensitivity
  include ScimPaginatable

  belongs_to :group
  belongs_to :user

  validates :user, presence: true, uniqueness: { scope: [:group_id] }
  validates :extern_uid, presence: true,
    uniqueness: { case_sensitive: false, scope: [:group_id] }

  scope :for_user, ->(user) { where(user: user) }
  scope :with_extern_uid, ->(extern_uid) { iwhere(extern_uid: extern_uid) }

  after_commit :sync_records, on: %i[create update]

  def sync_records
    Authn::SyncGroupScimIdentityRecordWorker.perform_async({ 'group_scim_identity_id' => id })
  end
end
==== /workspace/gitlab/ee/app/models/integrations/google_cloud_platform/workload_identity_federation.rb ====
# frozen_string_literal: true

module Integrations
  module GoogleCloudPlatform
    class WorkloadIdentityFederation < Integration
      include HasAvatar

      SECTION_TYPE_GOOGLE_CLOUD_IAM = 'google_cloud_iam'

      attribute :alert_events, default: false
      attribute :commit_events, default: false
      attribute :confidential_issues_events, default: false
      attribute :confidential_note_events, default: false
      attribute :issues_events, default: false
      attribute :job_events, default: false
      attribute :merge_requests_events, default: false
      attribute :note_events, default: false
      attribute :pipeline_events, default: false
      attribute :push_events, default: false
      attribute :tag_push_events, default: false
      attribute :wiki_page_events, default: false
      attribute :comment_on_event_enabled, default: false

      validates :workload_identity_federation_project_id, format: /\A[a-z0-9-]{6,30}\z/, allow_blank: true
      validates :workload_identity_pool_id, format: /\A[a-z0-9-]{4,32}\z/, allow_blank: true
      validates :workload_identity_pool_provider_id, format: /\A[a-z0-9-]{4,32}\z/, allow_blank: true

      with_options if: :activated? do
        validates :workload_identity_federation_project_id, presence: true
        validates :workload_identity_federation_project_number, presence: true, numericality: { only_integer: true }
        validates :workload_identity_pool_id, presence: true
        validates :workload_identity_pool_provider_id, presence: true
      end

      field :workload_identity_federation_project_id,
        required: true,
        section: SECTION_TYPE_CONFIGURATION,
        title: -> { s_('GoogleCloud|Project ID') },
        description: -> {
          s_('GoogleCloud|Google Cloud project ID for the Workload Identity Federation.')
        },
        help: -> {
          format(
            s_('GoogleCloud|Can be 6 to 30 lowercase letters, numbers, or hyphens. ' \
              'Must start with a letter and end with a letter or number. ' \
              'Example: %{code_open}my-sample-project-191923%{code_close}'),
            {
              code_open: '<code>',
              code_close: '</code>'
            }
          )
        }

      field :workload_identity_federation_project_number,
        required: true,
        section: SECTION_TYPE_CONFIGURATION,
        title: -> { s_('GoogleCloud|Project number') },
        description: -> {
          s_('GoogleCloud|Google Cloud project number for the Workload Identity Federation.')
        },
        help: -> {
          format(
            s_('GoogleCloud|Example: %{code_open}314053285323%{code_close}'),
            {
              code_open: '<code>',
              code_close: '</code>'
            }
          )
        }

      field :workload_identity_pool_id,
        required: true,
        section: SECTION_TYPE_CONFIGURATION,
        title: -> { s_('GoogleCloud|Pool ID') },
        description: -> {
          s_('GoogleCloud|ID of the Workload Identity Pool.')
        },
        help: -> {
          format(
            s_('GoogleCloud|Can be 4 to 32 lowercase letters, numbers, or hyphens.')
          )
        }

      field :workload_identity_pool_provider_id,
        required: true,
        section: SECTION_TYPE_CONFIGURATION,
        title: -> { s_('GoogleCloud|Provider ID') },
        description: -> {
          s_('GoogleCloud|ID of the Workload Identity Pool provider.')
        },
        help: -> {
          format(
            s_('GoogleCloud|Can be 4 to 32 lowercase letters, numbers, or hyphens.')
          )
        }

      def self.title
        s_('GoogleCloud|Google Cloud IAM')
      end

      def self.description
        s_('GoogleCloud|Manage permissions for Google Cloud resources with Identity and Access Management (IAM).')
      end

      def self.to_param
        'google_cloud_platform_workload_identity_federation'
      end

      def sections
        [
          {
            type: SECTION_TYPE_GOOGLE_CLOUD_IAM
          }
        ]
      end

      def self.supported_events
        []
      end

      def self.wlif_issuer_url(group_or_project)
        "#{::GoogleCloud.glgo_base_url}/oidc/#{group_or_project.root_ancestor.path}"
      end

      # used when setting up WLIF pools
      # google cloud supports a max of 50 attributes
      # https://cloud.google.com/iam/docs/workload-identity-federation#mapping
      #
      # list of all possible attributes at
      # https://docs.gitlab.com/ee/ci/secrets/id_token_authentication.html#token-payload
      def self.jwt_claim_mapping
        access_attributes = Gitlab::Access.sym_options_with_owner.keys
        attribute_mapping = access_attributes.to_h do |k, _v|
          ["attribute.#{k}_access", "assertion.#{k}_access"]
        end

        additional_attributes = %w[
          namespace_id
          namespace_path
          project_id
          project_path
          user_id
          user_login
          user_email
          user_access_level
        ]
        additional_attributes.each { |a| attribute_mapping["attribute.#{a}"] = "assertion.#{a}" }

        attribute_mapping['google.subject'] = 'assertion.sub'
        attribute_mapping
      end

      def self.jwt_claim_mapping_script_value
        jwt_claim_mapping.map { |k, v| "#{k}=#{v}" }.join(',')
      end

      # We will make the integration testable in https://gitlab.com/gitlab-org/gitlab/-/issues/439885
      def testable?
        false
      end

      def identity_provider_resource_name
        return unless ::Gitlab::Saas.feature_available?(:google_cloud_support) && activated?

        "//#{identity_pool_resource_name}/providers/#{workload_identity_pool_provider_id}"
      end

      def identity_pool_resource_name
        return unless ::Gitlab::Saas.feature_available?(:google_cloud_support) && activated?

        "iam.googleapis.com/projects/#{workload_identity_federation_project_number}/" \
          "locations/global/workloadIdentityPools/#{workload_identity_pool_id}"
      end
    end
  end
end
==== /workspace/gitlab/ee/app/models/merge_requests/approval_rules_approver_user.rb ====
# frozen_string_literal: true

module MergeRequests
  class ApprovalRulesApproverUser < ApplicationRecord
    self.table_name = 'merge_requests_approval_rules_approver_users'

    belongs_to :approval_rule, class_name: 'MergeRequests::ApprovalRule'
    belongs_to :user

    before_validation :set_sharding_key

    private

    def set_sharding_key
      return self.group_id = approval_rule.group_id if approval_rule.originates_from_group?

      self.project_id = approval_rule.project_id
    end
  end
end
==== /workspace/gitlab/ee/app/models/namespaces/free_user_cap.rb ====
# frozen_string_literal: true

module Namespaces
  module FreeUserCap
    REACHED_LIMIT_VARIANT = 'reached'
    CLOSE_TO_LIMIT_VARIANT = 'close'

    def self.dashboard_limit
      ::Gitlab::CurrentSettings.dashboard_limit
    end

    def self.dashboard_limit_enabled?
      ::Gitlab::CurrentSettings.dashboard_limit_enabled?
    end

    def self.owner_access?(user:, namespace:)
      return false unless user

      Ability.allowed?(user, :owner_access, namespace)
    end

    def self.non_owner_access?(user:, namespace:)
      return false unless user
      return false if owner_access?(user: user, namespace: namespace)

      Ability.allowed?(user, :read_group, namespace)
    end
  end
end

Namespaces::FreeUserCap.prepend_mod
==== /workspace/gitlab/ee/app/models/onboarding/user_status.rb ====
# frozen_string_literal: true

module Onboarding
  class UserStatus
    REGISTRATION_KLASSES = {
      ::Onboarding::REGISTRATION_TYPE[:free] => ::Onboarding::FreeRegistration,
      ::Onboarding::REGISTRATION_TYPE[:trial] => ::Onboarding::TrialRegistration,
      ::Onboarding::REGISTRATION_TYPE[:invite] => ::Onboarding::InviteRegistration,
      ::Onboarding::REGISTRATION_TYPE[:subscription] => ::Onboarding::SubscriptionRegistration
    }.freeze
    private_constant :REGISTRATION_KLASSES

    attr_reader :registration_type

    # string delegations
    delegate :product_interaction, to: :registration_type
    # predicate delegations
    delegate :apply_trial?, :eligible_for_iterable_trigger?, to: :registration_type

    def initialize(user)
      @user = user

      @registration_type = calculate_registration_type_klass
    end

    def existing_plan
      (registration_type.include_existing_plan_for_iterable? &&
        plan_name_from_invited_source&.then { |plan| { existing_plan: plan } }) || {}
    end

    private

    attr_reader :user

    def plan_name_from_invited_source
      user.members.last&.source&.root_ancestor&.actual_plan_name
    end

    def calculate_registration_type_klass
      return ::Onboarding::AutomaticTrialRegistration if automatic_trial?

      REGISTRATION_KLASSES.fetch(user&.onboarding_status_registration_type, ::Onboarding::FreeRegistration)
    end

    def automatic_trial?
      trial_registration? && !initial_trial?
    end

    def trial_registration?
      user&.onboarding_status_registration_type == registration_type_trial
    end

    def initial_trial?
      user.onboarding_status_initial_registration_type == registration_type_trial
    end

    def registration_type_trial
      REGISTRATION_TYPE[:trial]
    end
  end
end
==== /workspace/gitlab/ee/app/models/preloaders/user_member_roles_for_admin_preloader.rb ====
# frozen_string_literal: true

module Preloaders
  class UserMemberRolesForAdminPreloader
    include Gitlab::Utils::StrongMemoize

    attr_reader :user

    def initialize(user:)
      @user = user
    end

    def execute
      ::Gitlab::SafeRequestLoader.execute(
        resource_key: resource_key,
        resource_ids: [:admin]
      ) do
        admin_abilities_for_user
      end
    end

    private

    def admin_abilities_for_user
      return { admin: [] } unless custom_roles_enabled?

      user_member_roles = Authz::UserAdminRole.klass(user).where(user_id: user.id).includes(:member_role)

      user_abilities = user_member_roles.flat_map do |user_role|
        user_role.member_role.enabled_admin_permissions.keys
      end

      { admin: user_abilities }
    end

    def custom_roles_enabled?
      ::Feature.enabled?(:custom_admin_roles, :instance) && ::License.feature_available?(:custom_roles)
    end

    def resource_key
      "member_roles_for_admin:user:#{user.id}"
    end
  end
end
==== /workspace/gitlab/ee/app/models/preloaders/user_member_roles_in_groups_preloader.rb ====
# frozen_string_literal: true

module Preloaders
  class UserMemberRolesInGroupsPreloader
    include Gitlab::Utils::StrongMemoize

    attr_reader :groups, :group_relation, :user

    def initialize(groups:, user:)
      @groups = groups
      @user = user
    end

    def execute
      return {} if groups.blank? || user.blank?

      group_ids = groups.map { |group| group.respond_to?(:id) ? group.id : group }

      ::Gitlab::SafeRequestLoader.execute(
        resource_key: resource_key,
        resource_ids: group_ids,
        default_value: []
      ) do |group_ids|
        abilities_for_user_grouped_by_group(group_ids)
      end
    end

    private

    def abilities_for_user_grouped_by_group(group_ids)
      @group_relation = Group.id_in(group_ids)

      ::Namespaces::Preloaders::GroupRootAncestorPreloader.new(group_relation).execute

      groups_with_traversal_ids = group_relation.filter_map do |group|
        next unless group.root_ancestor.should_process_custom_roles?

        [group.id, Arel.sql("ARRAY[#{group.traversal_ids_as_sql}]")]
      end

      return {} if groups_with_traversal_ids.empty?

      value_list = Arel::Nodes::ValuesList.new(groups_with_traversal_ids)

      sql = <<~SQL
      SELECT namespace_ids.namespace_id, custom_permissions.permissions
        FROM (#{value_list.to_sql}) AS namespace_ids (namespace_id, namespace_ids),
        LATERAL (
          #{union_query}
        ) AS custom_permissions
      SQL

      grouped_by_group = ApplicationRecord.connection.select_all(sql).to_a.group_by do |h|
        h['namespace_id']
      end

      log_statistics(group_ids)

      grouped_by_group.transform_values do |values|
        group_permissions = values.map do |value|
          Gitlab::Json.parse(value['permissions']).select { |_, v| v }
        end

        group_permissions.inject(&:merge).keys.map(&:to_sym) & enabled_group_permissions
      end
    end

    def union_query
      union_queries = []

      member = Member.select('member_roles.permissions').with_user(user)

      group_member = member
        .joins(:member_role)
        .where(source_type: 'Namespace')
        .where('members.source_id IN (SELECT UNNEST(namespace_ids) as ids)')
        .to_sql

      if custom_role_for_group_link_enabled?
        group_link_join = member
          .joins('JOIN group_group_links ON members.source_id = group_group_links.shared_with_group_id')
          .where('group_group_links.shared_group_id IN (SELECT UNNEST(namespace_ids) as ids)')

        invited_member_role = group_link_join
          .joins('JOIN member_roles ON member_roles.id = group_group_links.member_role_id')
          .where('access_level > group_access')
          .to_sql

        # when both roles are custom roles with the same base access level,
        # choose the source role as the max role
        source_member_role = group_link_join
          .joins('JOIN member_roles ON member_roles.id = members.member_role_id')
          .where('(access_level < group_access) OR ' \
            '(access_level = group_access AND group_group_links.member_role_id IS NOT NULL)')
          .to_sql

        union_queries.push(invited_member_role, source_member_role)
      end

      union_queries.push(group_member)

      union_queries.join(" UNION ALL ")
    end

    def resource_key
      "member_roles_in_groups:user:#{user.id}"
    end

    def enabled_group_permissions
      MemberRole.all_customizable_group_permissions
        .filter { |permission| ::MemberRole.permission_enabled?(permission, user) }
    end
    strong_memoize_attr :enabled_group_permissions

    def custom_role_for_group_link_enabled?
      if ::Gitlab::Saas.feature_available?(:gitlab_com_subscriptions)
        group_relation.any? do |group|
          ::Feature.enabled?(:assign_custom_roles_to_group_links_saas, group.root_ancestor)
        end
      else
        ::Feature.enabled?(:assign_custom_roles_to_group_links_sm, :instance)
      end
    end

    def log_statistics(group_ids)
      ::Gitlab::AppLogger.info(
        class: self.class.name,
        user_id: user.id,
        groups_count: group_ids.length,
        group_ids: group_ids.first(10)
      )
    end
  end
end
==== /workspace/gitlab/ee/app/models/preloaders/user_member_roles_in_projects_preloader.rb ====
# frozen_string_literal: true

module Preloaders
  class UserMemberRolesInProjectsPreloader
    include Gitlab::Utils::StrongMemoize

    attr_reader :projects, :projects_relation, :user

    def initialize(projects:, user:)
      @projects = projects
      @user = user
    end

    def execute
      return {} if projects.blank? || user.blank?

      project_ids = projects.map { |project| project.respond_to?(:id) ? project.id : project }

      ::Gitlab::SafeRequestLoader.execute(
        resource_key: resource_key,
        resource_ids: project_ids,
        default_value: []
      ) do |project_ids|
        abilities_for_user_grouped_by_project(project_ids)
      end
    end

    private

    def abilities_for_user_grouped_by_project(project_ids)
      @projects_relation = Project.select(:id, :namespace_id).id_in(project_ids)

      ::Namespaces::Preloaders::ProjectRootAncestorPreloader.new(projects_relation, :namespace).execute

      projects_with_traversal_ids = projects_relation.filter_map do |project|
        next unless custom_roles_enabled_on?(project)

        [project.id, Arel.sql("ARRAY[#{project.namespace.traversal_ids_as_sql}]")]
      end

      return {} if projects_with_traversal_ids.empty?

      value_list = Arel::Nodes::ValuesList.new(projects_with_traversal_ids)

      sql = <<~SQL
      SELECT project_ids.project_id, custom_permissions.permissions
        FROM (#{value_list.to_sql}) AS project_ids (project_id, namespace_ids),
        LATERAL (
          #{union_query}
        ) AS custom_permissions
      SQL

      grouped_by_project = ApplicationRecord.connection.select_all(sql).to_a.group_by do |h|
        h['project_id']
      end

      log_statistics(project_ids)

      grouped_by_project.transform_values do |values|
        project_permissions = values.map do |value|
          Gitlab::Json.parse(value['permissions']).select { |_, v| v }
        end

        project_permissions.inject(:merge).keys.map(&:to_sym) & enabled_project_permissions
      end
    end

    def union_query
      union_queries = []

      member = Member.select('member_roles.permissions')
        .with_user(user)

      project_member = member
        .joins(:member_role)
        .where(source_type: 'Project')
        .where('members.source_id = project_ids.project_id')
        .to_sql

      namespace_member = member
        .joins(:member_role)
        .where(source_type: 'Namespace')
        .where('members.source_id IN (SELECT UNNEST(project_ids.namespace_ids) as ids)')
        .to_sql

      if custom_role_for_group_link_enabled?
        group_link_join = member
          .joins('JOIN group_group_links ON members.source_id = group_group_links.shared_with_group_id')
          .where('group_group_links.shared_group_id IN (SELECT UNNEST(project_ids.namespace_ids) as ids)')

        invited_member_role = group_link_join
          .joins('JOIN member_roles ON member_roles.id = group_group_links.member_role_id')
          .where('access_level > group_access')
          .to_sql

        # when both roles are custom roles with the same base access level,
        # choose the source role as the max role
        source_member_role = group_link_join
          .joins('JOIN member_roles ON member_roles.id = members.member_role_id')
          .where('(access_level < group_access) OR ' \
            '(access_level = group_access AND group_group_links.member_role_id IS NOT NULL)')
          .to_sql

        union_queries.push(invited_member_role, source_member_role)
      end

      union_queries.push(project_member, namespace_member)

      union_queries.join(" UNION ALL ")
    end

    def custom_roles_enabled_on
      Hash.new do |hash, namespace|
        hash[namespace] = namespace&.should_process_custom_roles?
      end
    end
    strong_memoize_attr :custom_roles_enabled_on

    def custom_roles_enabled_on?(project)
      custom_roles_enabled_on[project&.root_ancestor]
    end

    def resource_key
      "member_roles_in_projects:user:#{user.id}"
    end

    def enabled_project_permissions
      MemberRole
        .all_customizable_project_permissions
        .filter { |permission| ::MemberRole.permission_enabled?(permission, user) }
    end
    strong_memoize_attr :enabled_project_permissions

    def custom_role_for_group_link_enabled?
      if ::Gitlab::Saas.feature_available?(:gitlab_com_subscriptions)
        projects_relation.any? do |project|
          ::Feature.enabled?(:assign_custom_roles_to_group_links_saas, project.root_ancestor)
        end
      else
        ::Feature.enabled?(:assign_custom_roles_to_group_links_sm, :instance)
      end
    end

    def log_statistics(project_ids)
      ::Gitlab::AppLogger.info(
        class: self.class.name,
        user_id: user.id,
        projects_count: project_ids.length
      )
    end
  end
end
==== /workspace/gitlab/ee/app/models/scim_identity.rb ====
# frozen_string_literal: true

class ScimIdentity < ApplicationRecord
  include Sortable
  include CaseSensitivity
  include ScimPaginatable

  belongs_to :group, optional: true
  belongs_to :user

  validates :user, presence: true, uniqueness: { scope: [:group_id] }
  validates :extern_uid, presence: true,
    uniqueness: { case_sensitive: false, scope: [:group_id] }

  scope :for_instance, -> { where(group: nil) }
  scope :for_user, ->(user) { where(user: user) }
  scope :with_extern_uid, ->(extern_uid) { iwhere(extern_uid: extern_uid) }
  scope :with_user_ids, ->(user_ids) { where(user_id: user_ids) }

  after_commit :sync_records, on: %i[create update]

  def sync_records
    Authn::SyncScimIdentityRecordWorker.perform_async({ 'scim_identity_id' => id })
  end
end
==== /workspace/gitlab/ee/app/models/secrets_management/project_secrets_managers/user_helper.rb ====
# frozen_string_literal: true

module SecretsManagement
  module ProjectSecretsManagers
    module UserHelper
      extend ActiveSupport::Concern

      # currently we are gonna set the max_group as 25, but will increase if nescessary
      MAX_GROUPS = 25

      def user_auth_mount
        [
          namespace_path,
          'user_jwt'
        ].compact.join('/')
      end

      def user_auth_role
        "project_#{project.id}"
      end

      def user_auth_type
        'jwt'
      end

      def user_auth_policies
        [
          # User policy
          user_policy_template,
          # MemberRole policy
          member_role_policy_template,
          # Group policy
          *group_policy_template,
          # Role policy
          role_policy_template
        ]
      end

      def user_policy_template
        "{{ if ne \"\" .user_id }}project_{{ .project_id }}/users/direct/user_{{ .user_id }}{{ end }}"
      end

      def member_role_policy_template
        "{{ if ne \"\" .member_role_id }}project_{{ .project_id }}/users/direct/member_role_{{ .member_role_id }}" \
          "{{ end }}"
      end

      def group_policy_template
        (0...MAX_GROUPS).map do |i|
          "{{ if gt (len .groups) #{i} }}project_{{ .project_id }}/users/direct/group_{{ index .groups #{i} }}{{ end }}"
        end
      end

      def role_policy_template
        "{{ if ne \"\" .role_id }}project_{{ .project_id }}/users/roles/{{ .role_id }}{{ end }}"
      end
    end
  end
end
==== /workspace/gitlab/ee/app/models/smartcard_identity.rb ====
# frozen_string_literal: true

class SmartcardIdentity < ApplicationRecord
  belongs_to :user

  validates :user, presence: true
  validates :subject, presence: true, uniqueness: { scope: :issuer }
  validates :issuer, presence: true
end
==== /workspace/gitlab/ee/app/models/user_permission_export_upload.rb ====
# frozen_string_literal: true

class UserPermissionExportUpload < ApplicationRecord
  include WithUploads

  belongs_to :user, -> { where(admin: true) }

  mount_uploader :file, AttachmentUploader

  validates :status, presence: true
  validates :file, length: { maximum: 255 }
  validate :file_presence, if: :finished?

  state_machine :status, initial: :created do
    event :start do
      transition created: :running
    end

    event :finish do
      transition running: :finished
    end

    event :failed do
      transition [:created, :running] => :failed
    end

    state :created, value: 0
    state :running, value: 1
    state :finished, value: 2
    state :failed, value: 3
  end

  def uploads_sharding_key
    {}
  end

  private

  def file_presence
    errors.add(:file, "can't be blank") unless file.present?
  end
end
==== /workspace/gitlab/ee/app/models/users_ops_dashboard_project.rb ====
# frozen_string_literal: true

class UsersOpsDashboardProject < ApplicationRecord
  include UsageStatistics

  belongs_to :project
  belongs_to :user

  validates :user, presence: true
  validates :user_id, uniqueness: { scope: [:project_id] }
  validates :project, presence: true
end
==== /workspace/gitlab/ee/app/models/users_security_dashboard_project.rb ====
# frozen_string_literal: true

class UsersSecurityDashboardProject < ApplicationRecord
  extend SuppressCompositePrimaryKeyWarning

  SECURITY_DASHBOARD_PROJECTS_LIMIT = 1000

  belongs_to :project
  belongs_to :user

  validates :user, presence: true
  validates :project, presence: true
  validates :project_id, uniqueness: { scope: [:user_id] }
  validate :per_user_projects_limit

  def self.delete_by_project_id(project_id)
    where(project_id: project_id).delete_all
  end

  private

  def per_user_projects_limit
    if self.class.where(user: user).count >= SECURITY_DASHBOARD_PROJECTS_LIMIT
      errors.add(:project, _('limit of %{project_limit} reached') % { project_limit: SECURITY_DASHBOARD_PROJECTS_LIMIT })
    end
  end
end
==== /workspace/gitlab/ee/app/models/users/user_member_role.rb ====
# frozen_string_literal: true

module Users
  class UserMemberRole < ApplicationRecord
    include Authz::UserRoleAssignable

    self.table_name = 'user_member_roles'

    belongs_to :member_role
    belongs_to :user

    validates :member_role, presence: true
    validates :user, presence: true, uniqueness: true

    scope :ldap_synced, -> { where(ldap: true) }

    scope :with_identity_provider, ->(provider) do
      joins(user: :identities).where(identities: { provider: provider })
    end

    scope :preload_user, -> { preload(:user) }
  end
end
==== /workspace/gitlab/ee/app/models/vulnerability_user_mention.rb ====
# frozen_string_literal: true

class VulnerabilityUserMention < ::SecApplicationRecord
  include EachBatch
  include UserMentionBehaviour

  belongs_to :vulnerability
  belongs_to :note

  scope :by_vulnerability, ->(values) { where(vulnerability_id: values) }
end
==== /workspace/gitlab/lib/gitlab/auth/activity.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    ##
    # Metrics and logging for user authentication activity.
    #
    class Activity
      extend Gitlab::Utils::StrongMemoize

      COUNTERS = {
        user_authenticated: 'Counter of successful authentication events',
        user_unauthenticated: 'Counter of authentication failures',
        user_not_found: 'Counter of failed log-ins when user is unknown',
        user_password_invalid: 'Counter of failed log-ins with invalid password',
        user_session_override: 'Counter of manual log-ins and sessions overrides',
        user_session_destroyed: 'Counter of user sessions being destroyed',
        user_two_factor_authenticated: 'Counter of two factor authentications',
        user_sessionless_authentication: 'Counter of sessionless authentications',
        user_blocked: 'Counter of sign in attempts when user is blocked',
        user_csrf_token_invalid: 'Counter of CSRF token validation failures'
      }.freeze

      def initialize(opts)
        @opts = opts
      end

      def user_authentication_failed!
        self.class.user_unauthenticated_counter_increment!

        case @opts[:message]
        when :not_found_in_database
          self.class.user_not_found_counter_increment!
        when :invalid
          self.class.user_password_invalid_counter_increment!
        end
      end

      def user_authenticated!
        self.class.user_authenticated_counter_increment!

        case @opts[:message]
        when :two_factor_authenticated
          self.class.user_two_factor_authenticated_counter_increment!
        end
      end

      def user_session_override!
        self.class.user_session_override_counter_increment!

        case @opts[:message]
        when :sessionless_sign_in
          self.class.user_sessionless_authentication_counter_increment!
        end
      end

      def user_blocked!
        self.class.user_blocked_counter_increment!
      end

      def user_session_destroyed!
        self.class.user_session_destroyed_counter_increment!
      end

      def user_csrf_token_mismatch!
        controller = @opts[:controller]
        controller_label = controller.class.name
        controller_label = 'other' unless controller_label == 'GraphqlController'

        session = controller.try(:request).try(:session)
        user_auth_type_label = session.try(:loaded?) ? 'session' : 'other'

        self.class.user_csrf_token_invalid_counter
          .increment(controller: controller_label, auth: user_auth_type_label)
      end

      def self.each_counter
        COUNTERS.each_pair do |metric, description|
          yield "#{metric}_counter", metric, description
        end
      end

      each_counter do |counter, metric, description|
        define_singleton_method(counter) do
          strong_memoize(counter) do
            Gitlab::Metrics.counter("gitlab_auth_#{metric}_total".to_sym, description)
          end
        end

        define_singleton_method("#{counter}_increment!") do
          public_send(counter).increment # rubocop:disable GitlabSecurity/PublicSend
        end
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/atlassian/auth_hash.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    module Atlassian
      class AuthHash < Gitlab::Auth::OAuth::AuthHash
        def token
          credentials[:token]
        end

        def refresh_token
          credentials[:refresh_token]
        end

        def expires?
          credentials[:expires]
        end

        def expires_at
          credentials[:expires_at]
        end

        private

        def credentials
          auth_hash[:credentials]
        end
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/atlassian/identity_linker.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    module Atlassian
      class IdentityLinker < OmniauthIdentityLinkerBase
        extend ::Gitlab::Utils::Override
        include ::Gitlab::Utils::StrongMemoize

        private

        override :identity
        def identity
          strong_memoize(:identity) do
            current_user.atlassian_identity || build_atlassian_identity
          end
        end

        def build_atlassian_identity
          identity = current_user.build_atlassian_identity
          ::Gitlab::Auth::Atlassian::User.assign_identity_from_auth_hash!(identity, auth_hash)
        end

        def auth_hash
          ::Gitlab::Auth::Atlassian::AuthHash.new(oauth)
        end
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/atlassian/token_refresher.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    module Atlassian
      class TokenRefresher
        attr_reader :identity

        REFRESH_TOKEN_URL = 'https://auth.atlassian.com/oauth/token'
        MIN_TIME_ALLOWED_TILL_EXPIRE = 5.minutes
        AtlassianTokenRefreshError = Class.new(StandardError)

        def initialize(identity)
          @identity = identity
        end

        def needs_refresh?
          identity.expires_at < MIN_TIME_ALLOWED_TILL_EXPIRE.from_now
        end

        def refresh!
          response = Gitlab::HTTP.post(REFRESH_TOKEN_URL, body: payload.to_json, headers: headers)
          raise AtlassianTokenRefreshError, response["error"] unless response.success?

          identity.update!(
            expires_at: Time.zone.now + response["expires_in"].seconds,
            refresh_token: response["refresh_token"],
            token: response["access_token"]
          )
        end

        def refresh_if_needed!
          refresh! if needs_refresh?
        end

        private

        def headers
          { 'Content-Type' => 'application/json' }
        end

        def payload
          {
            grant_type: 'refresh_token',
            client_id: config.app_id,
            client_secret: config.app_secret,
            refresh_token: identity.refresh_token
          }
        end

        def config
          @config ||= Gitlab::Auth::OAuth::Provider.config_for('atlassian_oauth2')
        end
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/atlassian/user.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    module Atlassian
      class User < Gitlab::Auth::OAuth::User
        def self.assign_identity_from_auth_hash!(identity, auth_hash)
          identity.extern_uid = auth_hash.uid
          identity.token = auth_hash.token
          identity.refresh_token = auth_hash.refresh_token
          identity.expires_at = Time.at(auth_hash.expires_at).utc.to_datetime if auth_hash.expires?

          identity
        end

        protected

        def find_by_uid_and_provider
          ::Atlassian::Identity.find_by_extern_uid(auth_hash.uid)&.user
        end

        def add_or_update_user_identities
          return unless gl_user

          identity = gl_user.atlassian_identity || gl_user.build_atlassian_identity
          self.class.assign_identity_from_auth_hash!(identity, auth_hash)
        end

        def auth_hash=(auth_hash)
          @auth_hash = ::Gitlab::Auth::Atlassian::AuthHash.new(auth_hash)
        end
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/auth_finders.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    AuthenticationError = Class.new(StandardError)
    MissingTokenError = Class.new(AuthenticationError)
    TokenNotFoundError = Class.new(AuthenticationError)
    ExpiredError = Class.new(AuthenticationError)
    RevokedError = Class.new(AuthenticationError)
    ImpersonationDisabled = Class.new(AuthenticationError)
    UnauthorizedError = Class.new(AuthenticationError)

    class DpopValidationError < AuthenticationError
      def initialize(msg)
        super("DPoP validation error: #{msg}")
      end
    end

    class RestrictedLanguageServerClientError < AuthenticationError
      def initialize(msg)
        super("Language server client error: #{msg}")
      end
    end

    class InsufficientScopeError < AuthenticationError
      attr_reader :scopes

      def initialize(scopes)
        @scopes = scopes.map { |s| s.try(:name) || s }
      end
    end

    module AuthFinders
      include Gitlab::Utils::StrongMemoize
      include ActionController::HttpAuthentication::Basic
      include ActionController::HttpAuthentication::Token

      PRIVATE_TOKEN_HEADER = 'HTTP_PRIVATE_TOKEN'
      PRIVATE_TOKEN_PARAM = :private_token
      JOB_TOKEN_HEADER = 'HTTP_JOB_TOKEN'
      JOB_TOKEN_PARAM = :job_token
      DEPLOY_TOKEN_HEADER = 'HTTP_DEPLOY_TOKEN'
      RUNNER_TOKEN_PARAM = :token
      RUNNER_JOB_TOKEN_PARAM = :token
      PATH_DEPENDENT_FEED_TOKEN_REGEX = /\A#{User::FEED_TOKEN_PREFIX}(\h{64})-(\d+)\z/

      PARAM_TOKEN_KEYS = [
        PRIVATE_TOKEN_PARAM,
        JOB_TOKEN_PARAM,
        RUNNER_JOB_TOKEN_PARAM
      ].map(&:to_s).freeze
      HEADER_TOKEN_KEYS = [
        PRIVATE_TOKEN_HEADER,
        JOB_TOKEN_HEADER,
        DEPLOY_TOKEN_HEADER
      ].freeze

      attr_accessor :current_token

      # Check the Rails session for valid authentication details
      def find_user_from_warden
        current_request.env['warden']&.authenticate if verified_request?
      end

      def find_user_from_static_object_token(request_format)
        return unless valid_static_objects_format?(request_format)

        token = current_request.params[:token].presence || current_request.headers['X-Gitlab-Static-Object-Token'].presence
        return unless token

        User.find_by_static_object_token(token.to_s) || raise(UnauthorizedError)
      end

      def find_user_from_feed_token(request_format)
        return unless valid_rss_format?(request_format)
        return if Gitlab::CurrentSettings.disable_feed_token

        # NOTE: feed_token was renamed from rss_token but both needs to be supported because
        #       users might have already added the feed to their RSS reader before the rename
        token = current_request.params[:feed_token].presence || current_request.params[:rss_token].presence
        return unless token

        find_feed_token_user(token) || raise(UnauthorizedError)
      end

      def find_user_from_bearer_token
        find_user_from_job_bearer_token || find_user_from_access_token
      end

      def find_user_from_job_token
        return unless route_authentication_setting[:job_token_allowed]

        user = find_user_from_job_token_basic_auth if can_authenticate_job_token_basic_auth?
        return user if user

        find_user_from_job_token_query_params_or_header if can_authenticate_job_token_request?
      end

      def find_user_from_basic_auth_password
        return unless has_basic_credentials?(current_request)

        login, password = user_name_and_password(current_request)
        return if ::Gitlab::Auth::CI_JOB_USER == login

        Gitlab::Auth.find_with_user_password(login.to_s, password.to_s)
      end

      def find_user_from_lfs_token
        return unless has_basic_credentials?(current_request)

        login, token = user_name_and_password(current_request)
        user = User.find_by_login(login.to_s)

        user if user && Gitlab::LfsToken.new(user, nil).token_valid?(token.to_s)
      end

      def find_user_from_personal_access_token
        return unless access_token

        validate_and_save_access_token!

        access_token&.user || raise(UnauthorizedError)
      end

      # We allow private access tokens with `api` scope to be used by web
      # requests on RSS feeds or ICS files for backwards compatibility.
      # It is also used by GraphQL/API requests.
      # And to allow accessing /archive programatically as it was a big pain point
      # for users https://gitlab.com/gitlab-org/gitlab/-/issues/28978.
      # Used for release downloading as well
      def find_user_from_web_access_token(request_format, scopes: [:api])
        return unless access_token && valid_web_access_format?(request_format)

        validate_and_save_access_token!(scopes: scopes)

        ::PersonalAccessTokens::LastUsedService.new(access_token).execute

        access_token.user || raise(UnauthorizedError)
      end

      def find_user_from_access_token
        return unless access_token

        validate_and_save_access_token!

        ::PersonalAccessTokens::LastUsedService.new(access_token).execute

        access_token.user || raise(UnauthorizedError)
      end

      # This returns a deploy token, not a user since a deploy token does not
      # belong to a user.
      #
      # deploy tokens are accepted with deploy token headers and basic auth headers
      def deploy_token_from_request
        return unless route_authentication_setting[:deploy_token_allowed]
        return unless Gitlab::ExternalAuthorization.allow_deploy_tokens_and_deploy_keys?

        self.current_token = current_request.env[DEPLOY_TOKEN_HEADER].presence || parsed_oauth_token

        if has_basic_credentials?(current_request)
          _, self.current_token = user_name_and_password(current_request)
        end

        deploy_token = DeployToken.active.find_by_token(current_token.to_s)
        @current_authenticated_deploy_token = deploy_token # rubocop:disable Gitlab/ModuleWithInstanceVariables

        deploy_token
      end

      def cluster_agent_token_from_authorization_token
        return unless route_authentication_setting[:cluster_agent_token_allowed]

        self.current_token = current_request.headers[Gitlab::Kas::INTERNAL_API_AGENT_REQUEST_HEADER]

        return unless current_token.present?

        ::Clusters::AgentToken.active.find_by_token(current_token.to_s)
      end

      def find_runner_from_token
        return unless api_request?

        token = current_request.params[RUNNER_TOKEN_PARAM].presence
        return unless token

        ::Ci::Runner.find_by_token(token.to_s) || raise(UnauthorizedError)
      end

      def validate_and_save_access_token!(scopes: [], save_auth_context: true, reset_token: false)
        # return early if we've already authenticated via a job token
        return if @current_authenticated_job.present? # rubocop:disable Gitlab/ModuleWithInstanceVariables

        # return early if we've already authenticated via a deploy token
        return if @current_authenticated_deploy_token.present? # rubocop:disable Gitlab/ModuleWithInstanceVariables

        return unless access_token

        # Originally, we tried to use `reset` here to follow the rubocop rule introduced by
        # gitlab-org/gitlab-foss#60218, but this caused a NoMethodError for OAuth tokens,
        # leading to incident 18980 (see gitlab-com/gl-infra/production#18988).
        # We're using reload instead and disabling the rubocop rule to prevent similar incidents.
        access_token.reload if reset_token # rubocop:disable Cop/ActiveRecordAssociationReload

        case AccessTokenValidationService.new(access_token, request: request).validate(scopes: scopes)
        when AccessTokenValidationService::INSUFFICIENT_SCOPE
          save_auth_failure_in_application_context(access_token, :insufficient_scope, scopes) if save_auth_context
          raise InsufficientScopeError, scopes
        when AccessTokenValidationService::EXPIRED
          save_auth_failure_in_application_context(access_token, :token_expired, scopes) if save_auth_context
          raise ExpiredError
        when AccessTokenValidationService::REVOKED
          save_auth_failure_in_application_context(access_token, :token_revoked, scopes) if save_auth_context
          revoke_token_family(access_token)

          raise RevokedError
        when AccessTokenValidationService::IMPERSONATION_DISABLED
          save_auth_failure_in_application_context(access_token, :impersonation_disabled, scopes) if save_auth_context
          raise ImpersonationDisabled
        end

        save_current_token_in_env
      end

      def authentication_token_present?
        PARAM_TOKEN_KEYS.intersection(current_request.params.keys).any? ||
          HEADER_TOKEN_KEYS.intersection(current_request.env.keys).any? ||
          parsed_oauth_token.present?
      end

      private

      def extract_personal_access_token
        current_request.params[PRIVATE_TOKEN_PARAM].presence ||
          current_request.env[PRIVATE_TOKEN_HEADER].presence ||
          parsed_oauth_token
      end

      def save_current_token_in_env
        token_info = {
          token_id: access_token.id,
          token_type: access_token.class.to_s,
          token_scopes: access_token.scopes.map(&:to_sym)
        }

        token_info[:token_application_id] = access_token.application_id if access_token.respond_to?(:application_id)

        ::Current.token_info = token_info
      end

      def save_auth_failure_in_application_context(access_token, cause, requested_scopes)
        Gitlab::ApplicationContext.push(
          auth_fail_reason: cause.to_s,
          auth_fail_token_id: "#{access_token.class}/#{access_token.id}",
          auth_fail_requested_scopes: requested_scopes.join(' ')
        )
      end

      def find_user_from_job_bearer_token
        return unless route_authentication_setting[:job_token_allowed]

        self.current_token = parsed_oauth_token
        return unless current_token

        job = ::Ci::AuthJobFinder.new(token: current_token).execute
        return unless job

        @current_authenticated_job = job # rubocop:disable Gitlab/ModuleWithInstanceVariables

        job.user
      end

      def route_authentication_setting
        return {} unless respond_to?(:route_setting)

        route_setting(:authentication) || {}
      end

      def access_token
        strong_memoize(:access_token) do
          # Kubernetes API OAuth header is not OauthAccessToken or PersonalAccessToken
          # and should be ignored by this method. When the kubernetes API uses a different
          # header, we can remove this guard
          # https://gitlab.com/gitlab-org/gitlab/-/issues/406582
          next if current_request.path.starts_with? "/api/v4/internal/kubernetes/"

          if try(:namespace_inheritable, :authentication)
            access_token_from_namespace_inheritable
          else
            # The token can be a PAT or an OAuth (doorkeeper) token
            begin
              find_oauth_access_token
            rescue UnauthorizedError
              # It is also possible that a PAT is encapsulated in a `Bearer` OAuth token
              # (e.g. NPM client registry auth). In that case, we rescue UnauthorizedError
              # and try to find a personal access token.
            end || find_personal_access_token
          end
        end
      end

      def find_personal_access_token
        self.current_token = extract_personal_access_token
        return unless current_token

        # The runner sends the job token for PUT /api/jobs/:id in the PRIVATE-TOKEN header
        # and the token JSON parameter. Ignore this personal access token so
        # that the job token can be authenticated.
        return if api_request? && current_token.start_with?(::Ci::Build::TOKEN_PREFIX)

        # Expiration, revocation and scopes are verified in `validate_access_token!`
        PersonalAccessToken.find_by_token(current_token.to_s) || raise(UnauthorizedError)
      end

      def find_oauth_access_token
        self.current_token = parsed_oauth_token
        return unless current_token

        # Expiration, revocation and scopes are verified in `validate_access_token!`
        oauth_token = OauthAccessToken.by_token(current_token)
        raise UnauthorizedError unless oauth_token

        oauth_token.revoke_previous_refresh_token!

        ::Gitlab::Auth::Identity.link_from_oauth_token(oauth_token).tap do |identity|
          raise UnauthorizedError if identity && !identity.valid?
        end

        oauth_token
      end

      def find_personal_access_token_from_http_basic_auth
        return unless route_authentication_setting[:basic_auth_personal_access_token]
        return unless has_basic_credentials?(current_request)

        _username, self.current_token = user_name_and_password(current_request)
        PersonalAccessToken.find_by_token(current_token.to_s)
      end

      def find_feed_token_user(token)
        token = token.to_s
        find_user_from_path_feed_token(token) || User.find_by_feed_token(token)
      end

      def find_user_from_path_feed_token(token)
        glft = token.match(PATH_DEPENDENT_FEED_TOKEN_REGEX)

        return unless glft

        # make sure that user id uses decimal notation
        user_id = glft[2].to_i(10)
        digest = glft[1]

        user = User.find_by_id(user_id)
        return unless user

        feed_token = user.feed_token
        our_digest = OpenSSL::HMAC.hexdigest("SHA256", feed_token, current_request.path)

        return unless ActiveSupport::SecurityUtils.secure_compare(digest, our_digest)

        user
      end

      def can_authenticate_job_token_basic_auth?
        setting = route_authentication_setting[:job_token_allowed]
        Array.wrap(setting).include?(:basic_auth)
      end

      def can_authenticate_job_token_request?
        setting = route_authentication_setting[:job_token_allowed]
        setting == true || Array.wrap(setting).include?(:request)
      end

      def find_user_from_job_token_query_params_or_header
        self.current_token = current_request.params[JOB_TOKEN_PARAM].presence ||
          current_request.params[RUNNER_JOB_TOKEN_PARAM].presence ||
          current_request.env[JOB_TOKEN_HEADER].presence
        return unless current_token

        job = find_valid_running_job_by_token!(current_token.to_s)
        @current_authenticated_job = job # rubocop:disable Gitlab/ModuleWithInstanceVariables

        job.user
      end

      def find_user_from_job_token_basic_auth
        return unless has_basic_credentials?(current_request)

        login, self.current_token = user_name_and_password(current_request)
        return unless login.present? && current_token.present?
        return unless ::Gitlab::Auth::CI_JOB_USER == login

        job = find_valid_running_job_by_token!(current_token.to_s)
        @current_authenticated_job = job # rubocop:disable Gitlab/ModuleWithInstanceVariables

        job.user
      end

      def parsed_oauth_token
        Doorkeeper::OAuth::Token.from_request(current_request, *Doorkeeper.configuration.access_token_methods)
      end

      # Check if the request is GET/HEAD, or if CSRF token is valid.
      def verified_request?
        Gitlab::RequestForgeryProtection.verified?(current_request.env)
      end

      def ensure_action_dispatch_request(request)
        ActionDispatch::Request.new(request.env.dup)
      end

      def current_request
        @current_request ||= ensure_action_dispatch_request(request)
      end

      def valid_web_access_format?(request_format)
        case request_format
        when :rss
          rss_request?
        when :ics
          ics_request?
        when :api
          api_request?
        when :archive
          archive_request?
        when :download
          download_request?
        end
      end

      def valid_rss_format?(request_format)
        case request_format
        when :rss
          rss_request?
        when :ics
          ics_request?
        end
      end

      def valid_static_objects_format?(request_format)
        case request_format
        when :archive
          archive_request?
        when :blob
          blob_request?
        else
          false
        end
      end

      def rss_request?
        current_request.path.ends_with?('.atom') || current_request.format.atom?
      end

      def ics_request?
        current_request.path.ends_with?('.ics') || current_request.format.ics?
      end

      def api_request?
        current_request.path.starts_with?(Gitlab::Utils.append_path(Gitlab.config.gitlab.relative_url_root, '/api/'))
      end

      def git_request?
        Gitlab::PathRegex.repository_git_route_regex.match?(current_request.path)
      end

      def git_lfs_request?
        Gitlab::PathRegex.repository_git_lfs_route_regex.match?(current_request.path)
      end

      def git_or_lfs_request?
        git_request? || git_lfs_request?
      end

      def archive_request?
        current_request.path.include?('/-/archive/')
      end

      def download_request?
        current_request.path.include?('/downloads/')
      end

      def blob_request?
        current_request.path.include?('/raw/')
      end

      def find_valid_running_job_by_token!(token)
        ::Ci::AuthJobFinder.new(token: token).execute.tap do |job|
          raise UnauthorizedError unless job
        end
      end

      def revoke_token_family(token)
        return unless access_token_rotation_request?

        PersonalAccessTokens::RevokeTokenFamilyService.new(token).execute
      end

      def access_token_rotation_request?
        current_request.path.match(%r{access_tokens/(\d+|self)/rotate$})
      end

      # To prevent Rack Attack from incorrectly rate limiting
      # authenticated Git activity, we need to authenticate the user
      # from other means (e.g. HTTP Basic Authentication) only if the
      # request originated from a Git or Git LFS
      # request. Repositories::GitHttpClientController or
      # Repositories::LfsApiController normally does the authentication,
      # but Rack Attack runs before those controllers.
      def find_user_for_git_or_lfs_request
        return unless git_or_lfs_request?

        find_user_from_lfs_token || find_user_from_basic_auth_password
      end

      def find_user_from_personal_access_token_for_api_or_git
        return unless api_request? || git_or_lfs_request?

        find_user_from_personal_access_token
      end

      def find_user_from_dependency_proxy_token
        return unless dependency_proxy_request?

        token, _ = ActionController::HttpAuthentication::Token.token_and_options(current_request)

        return unless token

        user_or_deploy_token = ::DependencyProxy::AuthTokenService.user_or_deploy_token_from_jwt(token)

        # Do not return deploy tokens
        # See https://gitlab.com/gitlab-org/gitlab/-/issues/342481
        return unless user_or_deploy_token.is_a?(::User)

        user_or_deploy_token
      rescue ActiveRecord::RecordNotFound
        nil # invalid id used return no user
      end

      def dependency_proxy_request?
        Gitlab::PathRegex.dependency_proxy_route_regex.match?(current_request.path)
      end
    end
  end
end

Gitlab::Auth::AuthFinders.prepend_mod_with('Gitlab::Auth::AuthFinders')
==== /workspace/gitlab/lib/gitlab/auth/blocked_user_tracker.rb ====
# frozen_string_literal: true
module Gitlab
  module Auth
    class BlockedUserTracker
      def initialize(user, auth)
        @user = user
        @auth = auth
      end

      def log_activity!
        return unless @user.blocked?

        Gitlab::AppLogger.info <<~INFO
          "Failed login for blocked user: user=#{@user.username} ip=#{@auth.request.ip}")
        INFO

        SystemHooksService.new.execute_hooks_for(@user, :failed_login)
      rescue TypeError
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/crowd/authentication.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    module Crowd
      class Authentication < Gitlab::Auth::OAuth::Authentication
        def login(login, password)
          return unless Gitlab::Auth::OAuth::Provider.enabled?(@provider)
          return unless login.present? && password.present?

          user_info = user_info_from_authentication(login, password)
          return unless user_info&.key?(:user)

          Gitlab::Auth::OAuth::User.find_by_uid_and_provider(user_info[:user], provider)
        end

        private

        def config
          gitlab_crowd_config = Gitlab::Auth::OAuth::Provider.config_for(@provider)
          raise "OmniAuth Crowd is not configured." unless gitlab_crowd_config && gitlab_crowd_config[:args]

          OmniAuth::Strategies::Crowd::Configuration.new(
            gitlab_crowd_config[:args].symbolize_keys)
        end

        def user_info_from_authentication(login, password)
          validator = OmniAuth::Strategies::Crowd::CrowdValidator.new(
            config, login, password, RequestContext.instance.client_ip, nil)
          validator&.user_info&.symbolize_keys
        end
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/current_user_mode.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    # Keeps track of the current session user mode
    #
    # In order to perform administrative tasks over some interfaces,
    # an administrator must have explicitly enabled admin-mode
    # e.g. on web access require re-authentication
    class CurrentUserMode
      include Gitlab::Utils::StrongMemoize

      NotRequestedError = Class.new(StandardError)
      NonSidekiqEnvironmentError = Class.new(StandardError)

      # RequestStore entries
      CURRENT_REQUEST_BYPASS_SESSION_ADMIN_ID_RS_KEY = { res: :current_user_mode, data: :bypass_session_admin_id }.freeze
      CURRENT_REQUEST_ADMIN_MODE_USER_RS_KEY =         { res: :current_user_mode, data: :current_admin }.freeze

      # SessionStore entries
      SESSION_STORE_KEY = :current_user_mode
      ADMIN_MODE_START_TIME_KEY = :admin_mode
      ADMIN_MODE_REQUESTED_TIME_KEY = :admin_mode_requested
      MAX_ADMIN_MODE_TIME = 6.hours
      ADMIN_MODE_REQUESTED_GRACE_PERIOD = 5.minutes

      class << self
        # Admin mode activation requires storing a flag in the user session. Using this
        # method when scheduling jobs in sessionless environments (e.g. Sidekiq, API)
        # will bypass the session check for a user that was already in admin mode
        #
        # If passed a block, it will surround the block execution and reset the session
        # bypass at the end; otherwise you must remember to call '.reset_bypass_session!'
        def bypass_session!(admin_id)
          Gitlab::SafeRequestStore[CURRENT_REQUEST_BYPASS_SESSION_ADMIN_ID_RS_KEY] = admin_id
          # Bypassing the session invalidates the cached value of admin_mode?
          # Any new calls need to be re-computed.
          uncache_admin_mode_state(admin_id)

          Gitlab::AppLogger.debug("Bypassing session in admin mode for: #{admin_id}")

          return unless block_given?

          begin
            yield
          ensure
            reset_bypass_session!(admin_id)
          end
        end

        def reset_bypass_session!(admin_id = nil)
          # Restoring the session bypass invalidates the cached value of admin_mode?
          uncache_admin_mode_state(admin_id)
          Gitlab::SafeRequestStore.delete(CURRENT_REQUEST_BYPASS_SESSION_ADMIN_ID_RS_KEY)
        end

        def bypass_session_admin_id
          Gitlab::SafeRequestStore[CURRENT_REQUEST_BYPASS_SESSION_ADMIN_ID_RS_KEY]
        end

        def uncache_admin_mode_state(admin_id = nil)
          if admin_id
            key = { res: :current_user_mode, user: admin_id, method: :admin_mode? }
            Gitlab::SafeRequestStore.delete(key)
          else
            Gitlab::SafeRequestStore.delete_if do |key|
              key.is_a?(Hash) && key[:res] == :current_user_mode && key[:method] == :admin_mode?
            end
          end
        end

        # Store in the current request the provided user model (only if in admin mode)
        # and yield
        def with_current_admin(admin)
          return yield unless new(admin).admin_mode?

          Gitlab::SafeRequestStore[CURRENT_REQUEST_ADMIN_MODE_USER_RS_KEY] = admin

          Gitlab::AppLogger.debug("Admin mode active for: #{admin.username}")

          yield
        ensure
          Gitlab::SafeRequestStore.delete(CURRENT_REQUEST_ADMIN_MODE_USER_RS_KEY)
        end

        def current_admin
          Gitlab::SafeRequestStore[CURRENT_REQUEST_ADMIN_MODE_USER_RS_KEY]
        end

        # Execute the given block with admin privileges if the user is an admin and admin mode is enabled.
        # Otherwise, execute the block with regular user permissions.
        def optionally_run_in_admin_mode(user)
          raise NonSidekiqEnvironmentError unless Gitlab::Runtime.sidekiq?

          return yield unless Gitlab::CurrentSettings.admin_mode && user.can_access_admin_area?

          bypass_session!(user.id) do
            with_current_admin(user) do
              yield
            end
          end
        end
      end

      def initialize(user, session = Gitlab::Session.current)
        @user = user
        @session = session
      end

      def admin_mode?
        return false unless user

        Gitlab::SafeRequestStore.fetch(admin_mode_rs_key) do
          user.can_access_admin_area? && (privileged_runtime? || session_with_admin_mode?)
        end
      end

      def admin_mode_requested?
        return false unless user

        Gitlab::SafeRequestStore.fetch(admin_mode_requested_rs_key) do
          user.can_access_admin_area? && admin_mode_requested_in_grace_period?
        end
      end

      def enable_admin_mode!(password: nil, skip_password_validation: false)
        return false unless user&.can_access_admin_area?
        return false unless skip_password_validation || user&.valid_password?(password)

        raise NotRequestedError unless admin_mode_requested?

        reset_request_store_cache_entries

        current_session_data[ADMIN_MODE_REQUESTED_TIME_KEY] = nil
        current_session_data[ADMIN_MODE_START_TIME_KEY] = Time.now

        audit_user_enable_admin_mode

        true
      end

      def disable_admin_mode!
        return unless user&.can_access_admin_area?

        reset_request_store_cache_entries

        current_session_data[ADMIN_MODE_REQUESTED_TIME_KEY] = nil
        current_session_data[ADMIN_MODE_START_TIME_KEY] = nil
      end

      def request_admin_mode!
        return unless user&.can_access_admin_area?

        reset_request_store_cache_entries

        current_session_data[ADMIN_MODE_REQUESTED_TIME_KEY] = Time.now
      end

      def current_session_data
        Gitlab::NamespacedSessionStore.new(SESSION_STORE_KEY, @session)
      end
      strong_memoize_attr :current_session_data

      private

      attr_reader :user

      # RequestStore entry to cache #admin_mode? result
      def admin_mode_rs_key
        @admin_mode_rs_key ||= { res: :current_user_mode, user: user.id, method: :admin_mode? }
      end

      # RequestStore entry to cache #admin_mode_requested? result
      def admin_mode_requested_rs_key
        @admin_mode_requested_rs_key ||= { res: :current_user_mode, user: user.id, method: :admin_mode_requested? }
      end

      def session_with_admin_mode?
        return true if bypass_session?

        current_session_data.initiated? && current_session_data[ADMIN_MODE_START_TIME_KEY].to_i > MAX_ADMIN_MODE_TIME.ago.to_i
      end

      def admin_mode_requested_in_grace_period?
        current_session_data[ADMIN_MODE_REQUESTED_TIME_KEY].to_i > ADMIN_MODE_REQUESTED_GRACE_PERIOD.ago.to_i
      end

      def bypass_session?
        user&.id && user.id == self.class.bypass_session_admin_id
      end

      def reset_request_store_cache_entries
        Gitlab::SafeRequestStore.delete(admin_mode_rs_key)
        Gitlab::SafeRequestStore.delete(admin_mode_requested_rs_key)
      end

      # Runtimes which imply shell access get admin mode automatically, see Gitlab::Runtime
      def privileged_runtime?
        Gitlab::Runtime.rake? || Gitlab::Runtime.rails_runner? || Gitlab::Runtime.console?
      end

      def audit_user_enable_admin_mode; end
    end
  end
end

Gitlab::Auth::CurrentUserMode.prepend_mod_with('Gitlab::Auth::CurrentUserMode')
==== /workspace/gitlab/lib/gitlab/auth/database/authentication.rb ====
# frozen_string_literal: true

# These calls help to authenticate to OAuth provider by providing username and password
#

module Gitlab
  module Auth
    module Database
      class Authentication < Gitlab::Auth::OAuth::Authentication
        def login(login, password)
          return false unless Gitlab::CurrentSettings.password_authentication_enabled_for_git?

          return user if user&.valid_password?(password)
        end
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/devise/strategies/combined_two_factor_authenticatable.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    module Devise
      module Strategies
        # This strategy combines the following strategies from
        # devise_two_factor gem:
        # - TwoFactorAuthenticatable: https://github.com/devise-two-factor/devise-two-factor/blob/v4.0.2/lib/devise_two_factor/strategies/two_factor_authenticatable.rb
        # - TwoFactorBackupable: https://github.com/devise-two-factor/devise-two-factor/blob/v4.0.2/lib/devise_two_factor/strategies/two_factor_backupable.rb
        # to avoid double incrementing failed login attempts counter by each
        # strategy in case an incorrect password is provided.
        class CombinedTwoFactorAuthenticatable < ::Devise::Strategies::DatabaseAuthenticatable
          def authenticate!
            resource = mapping.to.find_for_database_authentication(authentication_hash)

            # We check the OTP / backup code, then defer to DatabaseAuthenticatable
            is_valid = validate(resource) do
              validate_otp(resource) || resource.invalidate_otp_backup_code!(params[scope]['otp_attempt'])
            end

            if is_valid
              # Devise fails to authenticate invalidated resources, but if we've
              # gotten here, the object changed (Since we deleted a recovery code)
              resource.save!

              super
            end

            fail(::Devise.paranoid ? :invalid : :not_found_in_database) unless resource # rubocop: disable Style/SignalException

            # We want to cascade to the next strategy if this one fails,
            # but database authenticatable automatically halts on a bad password
            @halted = false if @result == :failure
          end

          def validate_otp(resource)
            return true unless resource.otp_required_for_login

            return if params[scope]['otp_attempt'].nil?

            resource.validate_and_consume_otp!(params[scope]['otp_attempt'])
          end
        end
      end
    end
  end
end

Warden::Strategies.add(
  :combined_two_factor_authenticatable,
  Gitlab::Auth::Devise::Strategies::CombinedTwoFactorAuthenticatable)
==== /workspace/gitlab/lib/gitlab/auth/dpop_token.rb ====
# frozen_string_literal: true

# Demonstrated Proof of Possession (DPoP) is a mechanism to tie a user's
# Personal Access Token (PAT) to one of their signing keys.
#
# A DPoP Token is a signed JSON Web Token. This class implements
# the logic to ensure a provided DPoP Token is well-formed and
# cryptographically signed.
#
module Gitlab
  module Auth
    class DpopToken
      MAX_EXPIRY_TIME_IN_SECS = 300
      KID_DELIMITER = ':'

      attr_reader :data, :payload, :header

      def initialize(data:)
        @data = data
      end

      def validate!
        begin
          @payload, @header = JWT.decode(
            data,
            nil, # we do not pass a key here as we are not checking the signature
            false # we are not verifying the signature or claims
          )
        rescue StandardError => e
          raise Gitlab::Auth::DpopValidationError, "Malformed JWT, unable to decode. #{e.message}"
        end

        # All comparisons should be case-sensitive, using secure comparison
        # See https://www.rfc-editor.org/rfc/rfc7515#section-4.1.1
        raise Gitlab::Auth::DpopValidationError, 'Missing required claim, typ' unless header['typ'].present?
        raise Gitlab::Auth::DpopValidationError, 'Invalid typ value in JWT' unless header['typ'].casecmp?('dpop+jwt')

        raise Gitlab::Auth::DpopValidationError, 'No kid in JWT, unable to fetch key' unless header['kid'].present?
        raise Gitlab::Auth::DpopValidationError, 'Missing required claim, jwk' unless header['jwk'].present?

        # Check header[alg] is one of SUPPORTED_JWS_ALGORITHMS.
        # Remove when support for ED25519 is added
        # This checks for 'alg' in the header and exits early
        unless header['alg'].casecmp?('RS512')
          raise Gitlab::Auth::DpopValidationError,
            'Currently only RS512 algorithm is supported'
        end

        # Check the format of header[kid] (ALGORITHM DELIMITER b64(HASH))
        kid_parts = header['kid'].split(KID_DELIMITER)
        raise Gitlab::Auth::DpopValidationError, 'Malformed fingerprint value in kid' unless kid_parts.size == 2

        # Check kid_algorithm is supported
        kid_algorithm = kid_parts[0]
        unless kid_algorithm.casecmp?('SHA256')
          raise Gitlab::Auth::DpopValidationError, 'Unsupported fingerprint algorithm in kid'
        end

        # Check exp is not set to more than
        # iat + 5.minutes. We do not want users to
        # make JWTs with long expiration times. The
        # spec currently states 5 minutes (300 seconds)
        raise Gitlab::Auth::DpopValidationError, 'exp is missing' unless payload['exp'].present?
        raise Gitlab::Auth::DpopValidationError, 'iat is missing' unless payload['iat'].present?

        if payload['exp'] - payload['iat'] > MAX_EXPIRY_TIME_IN_SECS
          raise Gitlab::Auth::DpopValidationError, 'exp must not exceed iat by more than 5 minutes'
        end

        return if header.dig('jwk', 'kty').eql?('RSA')

        raise Gitlab::Auth::DpopValidationError, 'JWK algorithm must be RSA'
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/dpop_token_user.rb ====
# frozen_string_literal: true

# Demonstrated Proof of Possession (DPoP) is a mechanism to tie a user's
# Personal Access Token (PAT) to one of their signing keys.
#
# A DPoP Token is a signed JSON Web Token. This class implements
# the logic to ensure a provided DPoP Token is well-formed, cryptographically
# signed and belongs to the provided user.
#
module Gitlab
  module Auth
    class DpopTokenUser
      SUPPORTED_JWS_ALGORITHMS = { 'ssh-rsa' => 'RS512' }.freeze
      SUPPORTED_TYPES = ['dpop+jwt'].freeze
      SUPPORTED_KEY_TYPES = ['RSA'].freeze
      SUPPORTED_PROOF_KEY_ID_HASHING_ALGORITHMS = ['SHA256'].freeze

      def initialize(token:, user:, personal_access_token_plaintext:)
        @token = token
        @user = user
        @personal_access_token_plaintext = personal_access_token_plaintext
      end

      def validate!
        token.validate!
        pat_belongs_to_user!
        valid_token_for_user!
        valid_access_token_hash!
      end

      private

      attr_reader :token, :user, :personal_access_token_plaintext

      def pat_belongs_to_user!
        return if user.personal_access_tokens.active.find_by_token(personal_access_token_plaintext).present?

        raise Gitlab::Auth::DpopValidationError, 'Personal access token does not belong to the requesting user'
      end

      # Check that the DPoP is signed with a SSH key belonging to the user
      def valid_token_for_user!
        user_public_key = signing_key_for_user!
        openssh_public_key = convert_public_key_to_openssh_key!(user_public_key)

        payload, header = decode_json_token!(user_public_key, openssh_public_key)
        raise Gitlab::Auth::DpopValidationError, 'Unable to decode JWT' if payload.nil? || header.nil?

        jwk = header['jwk']

        begin
          raise Gitlab::Auth::DpopValidationError, 'JWK contains private key' if JWT::JWK::RSA.import(jwk).private?

          unless openssh_public_key.to_s == OpenSSL::PKey.read(JWT::JWK::RSA.import(jwk).public_key.to_pem).to_s
            raise 'Failed to parse JWK: invalid JWK'
          end
        rescue StandardError => e
          raise Gitlab::Auth::DpopValidationError, e
        end
      end

      def decode_json_token!(user_public_key, openssh_public_key)
        # Decode the JSON token again, this time with the key,
        # the expected algorithm, verifying all the timestamps, etc
        # Overwrites the attrs, in case .decode returns a different result
        # when verify is true.
        algorithm = algorithm_for_dpop_validation(user_public_key)

        JWT.decode(
          token.data,
          openssh_public_key,
          true,
          {
            required_claims: %w[exp ath iat jti],
            algorithm: algorithm,
            verify_iat: true
          }
        )
      rescue JWT::ExpiredSignature
        raise Gitlab::Auth::DpopValidationError, "Signature expired"
      rescue JWT::MissingRequiredClaim => e
        raise Gitlab::Auth::DpopValidationError, e.message
      rescue JWT::InvalidIatError
        raise Gitlab::Auth::DpopValidationError, "Invalid IAT value"
      end

      def signing_key_for_user!
        # Gets a signing key from the user based on the fingerprint.
        fingerprint = token.header['kid']&.delete_prefix('SHA256:')

        key = user.keys.signing.find_by_fingerprint_sha256(fingerprint)&.key
        raise Gitlab::Auth::DpopValidationError, "No matching key found" unless key

        # Validate the signing key uses a supported algorithm.
        algorithm = key.split(' ').first

        return key if algorithm.casecmp?('ssh-rsa')

        raise Gitlab::Auth::DpopValidationError, 'Currently only RSA keys are supported'
      end

      # Finds the algorithm from the public key to decode the JWT in
      # valid_for_user!
      def algorithm_for_dpop_validation(key)
        SUPPORTED_JWS_ALGORITHMS.each do |key_algorithm, jwt_algorithm|
          return jwt_algorithm if key.start_with?(key_algorithm)
        end
        nil
      end

      def convert_public_key_to_openssh_key!(key)
        SSHData::PublicKey.parse_openssh(key).openssl
      rescue SSHData::DecodeError => e
        raise Gitlab::Auth::DpopValidationError, "Unable to parse public key. #{e.message}"
      end

      # Check that the DPoP contains a hash of the PAT being used.
      # Users can have multiple PATs, so we still need to check that
      # they created this DPoP for this particular PAT.
      def valid_access_token_hash!
        expected_hash = Base64.urlsafe_encode64(
          Digest::SHA256.digest(personal_access_token_plaintext),
          padding: false
        )

        return if ActiveSupport::SecurityUtils.secure_compare(token.payload['ath'], expected_hash)

        raise Gitlab::Auth::DpopValidationError, 'Incorrect access token hash in JWT'
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/editor_extensions/language_server_client.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    module EditorExtensions
      class LanguageServerClient
        USER_AGENT_PATTERN = /gitlab-language-server|code-completions-language-server-experiment/
        VERSION_PATTERN = ::Gitlab::Regex.semver_regex

        def initialize(client_version:, user_agent:)
          @client_version = client_version
          @user_agent = user_agent
        end

        def lsp_client?
          # Either condition is sufficient to identify an LSP client:
          # - client_version matching semantic versioning pattern, or
          # - user_agent containing known LSP client identifiers
          client_version&.match(VERSION_PATTERN) || user_agent&.match(USER_AGENT_PATTERN)
        end

        def version
          return Gem::Version.new(client_version) if client_version&.match(VERSION_PATTERN)

          # For older clients it is likely LSP version information is absent.
          Gem::Version.new('0.1.0')
        end

        private

        attr_reader :client_version, :user_agent
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/editor_extensions/language_server_client_verifier.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    module EditorExtensions
      class LanguageServerClientVerifier
        def initialize(current_user:, request:)
          @current_user = current_user
          @request = request
        end

        def execute
          return ServiceResponse.success unless client.lsp_client? && enforce_language_server_version?

          return ServiceResponse.success if client.version >= minimum_version

          ServiceResponse.error(
            message: 'Requests from Editor Extension clients are restricted',
            payload: { client_version: client.version },
            reason: :instance_requires_newer_client
          )
        end

        private

        attr_reader :current_user, :request

        def client
          Gitlab::Auth::EditorExtensions::LanguageServerClient.new(
            client_version: request.headers['HTTP_X_GITLAB_LANGUAGE_SERVER_VERSION'],
            user_agent: request.headers['HTTP_USER_AGENT']
          )
        end

        def enforce_language_server_version?
          return false unless Gitlab::CurrentSettings.gitlab_dedicated_instance? ||
            Feature.enabled?(:enforce_language_server_version, current_user)

          Gitlab::CurrentSettings.enable_language_server_restrictions
        end

        def minimum_version
          Gem::Version.new(Gitlab::CurrentSettings.minimum_language_server_version)
        end
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/external_username_sanitizer.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    class ExternalUsernameSanitizer
      attr_reader :external_username

      def initialize(external_username)
        @external_username = external_username
      end

      def sanitize
        # remove most characters illegal in usernames / slugs
        slug = Gitlab::Slug::Path.new(external_username).generate

        # remove leading - , _ , or . characters not removed by Namespace.clean_path
        slug = slug.sub(/\A[_.-]+/, '')

        # remove trailing - , _ or . characters not removed by Namespace.clean_path
        # hard to write a regex to match end-of-string without ReDoS, so just use plain Ruby
        slug = slug[0...-1] while slug.end_with?('.', '-', '_')

        # remove consecutive - , _ , or . characters
        slug = slug.gsub(/([_.-])[_.-]+/, '\1')

        slug = unique_by_namespace(slug)

        validated_path(slug)
      end

      # decomposed from Namespace.clean_path
      def unique_by_namespace(slug)
        path = Namespaces::RandomizedSuffixPath.new(slug).to_s
        Gitlab::Utils::Uniquify.new.string(path) do |s|
          Namespace.all.find_by_path_or_name(s)
        end
      end

      def validated_path(path)
        Gitlab::Utils::Uniquify.new.string(path) do |s|
          !NamespacePathValidator.valid_path?(s)
        end
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/identity.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    ##
    # Identity class represents identity which we want to use in authorization policies.
    #
    # It decides if an identity is a single or composite identity and finds identity scope.
    #
    class Identity
      COMPOSITE_IDENTITY_USERS_KEY = 'composite_identities'
      COMPOSITE_IDENTITY_KEY_FORMAT = 'user:%s:composite_identity'
      COMPOSITE_IDENTITY_SIDEKIQ_ARG = 'sqci' # Sidekiq Composite Identity

      IdentityError = Class.new(StandardError)
      IdentityLinkMismatchError = Class.new(IdentityError)
      UnexpectedIdentityError = Class.new(IdentityError)
      TooManyIdentitiesLinkedError = Class.new(IdentityError)
      MissingCompositeIdentityError = Class.new(::Gitlab::Access::AccessDeniedError)
      MissingServiceAccountError = Class.new(::Gitlab::Access::AccessDeniedError)

      # TODO: why is this called 3 times in doorkeeper_access_spec.rb specs?
      def self.link_from_oauth_token(oauth_token)
        fabricate(oauth_token.user).tap do |identity|
          identity.link!(oauth_token.scope_user) if identity&.composite?
        end
      end

      def self.link_from_job(job)
        fabricate(job.user).tap do |identity|
          identity.link!(job.scoped_user) if identity&.composite?
        end
      end

      def self.link_from_scoped_user_id(user, scoped_user_id)
        scoped_user = ::User.find_by_id(scoped_user_id)

        return unless scoped_user

        ::Gitlab::Auth::Identity.fabricate(user).tap do |identity|
          identity.link!(scoped_user) if identity&.composite?
        end
      end

      def self.link_from_web_request(service_account:, scoped_user:)
        raise MissingServiceAccountError, 'service account is required' unless service_account

        fabricate(service_account).tap do |identity|
          identity.link!(scoped_user) if identity&.composite?
        end
      end

      def self.sidekiq_restore!(job)
        ids = Array(job[COMPOSITE_IDENTITY_SIDEKIQ_ARG])

        return if ids.empty?
        raise IdentityError, 'unexpected number of identities in Sidekiq job' unless ids.size == 2

        ::Gitlab::Auth::Identity
          .new(::User.find(ids.first))
          .link!(::User.find(ids.second))
      end

      def self.currently_linked
        user = ::Gitlab::SafeRequestStore
          .store[COMPOSITE_IDENTITY_USERS_KEY]
          .to_a.first

        return unless user.present?

        identity = new(user)

        block_given? ? yield(identity) : identity
      end

      def self.fabricate(user)
        new(user) if user.is_a?(::User)
      end

      def initialize(user, store: ::Gitlab::SafeRequestStore)
        raise UnexpectedIdentityError unless user.is_a?(::User)

        @user = user
        @request_store = store
      end

      def composite?
        @user.composite_identity_enforced?
      end

      def sidekiq_link!(job)
        job[COMPOSITE_IDENTITY_SIDEKIQ_ARG] = [primary_user_id, scoped_user_id]
      end

      def link!(scope_user)
        return self unless scope_user

        ##
        # TODO: consider extracting linking to ::Gitlab::Auth::Identities::Link#create!
        #
        validate_link!(scope_user)
        store_identity_link!(scope_user)
        append_log!(scope_user)

        self
      end

      def linked?
        @request_store.exist?(store_key)
      end

      def valid?
        return true unless composite?
        return false unless linked?

        !scoped_user.composite_identity_enforced?
      end

      def scoped_user
        @request_store.fetch(store_key) do
          raise MissingCompositeIdentityError, 'composite identity missing'
        end
      end

      def primary_user
        @user
      end

      private

      def scoped_user_id
        scoped_user.id
      end

      def primary_user_id
        @user.id
      end

      def validate_link!(scope_user)
        return unless linked? && saved_scoped_user_different_from_new_scope_user?(scope_user)

        raise IdentityLinkMismatchError, 'identity link change detected'
      end

      def saved_scoped_user_different_from_new_scope_user?(scope_user)
        scoped_user_id != scope_user.id
      end

      def store_identity_link!(scope_user)
        @request_store.store[store_key] = scope_user

        composite_identities.add(@user)

        raise TooManyIdentitiesLinkedError if composite_identities.size > 1
      end

      def append_log!(scope_user)
        ::Gitlab::ApplicationContext.push(scoped_user: scope_user)
      end

      def composite_identities
        @request_store.store[COMPOSITE_IDENTITY_USERS_KEY] ||= Set.new
      end

      def store_key
        @store_key ||= format(COMPOSITE_IDENTITY_KEY_FORMAT, @user.id)
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/ip_blocked.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    class IpBlocked < StandardError
      def message
        _('Too many failed authentication attempts from this IP')
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/ip_rate_limiter.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    class IpRateLimiter
      include ::Gitlab::Utils::StrongMemoize

      attr_reader :ip

      def initialize(ip)
        @ip = ip
      end

      def reset!
        return if skip_rate_limit?

        Rack::Attack::Allow2Ban.reset(ip, config)
      end

      def register_fail!
        return false if skip_rate_limit?

        # Allow2Ban.filter will return false if this IP has not failed too often yet
        Rack::Attack::Allow2Ban.filter(ip, config) do
          # We return true to increment the count for this IP
          true
        end
      end

      def banned?
        return false if skip_rate_limit?

        Rack::Attack::Allow2Ban.banned?(ip)
      end

      def trusted_ip?
        trusted_ips.any? { |netmask| netmask.include?(ip) }
      end

      private

      def skip_rate_limit?
        !enabled? || trusted_ip?
      end

      def enabled?
        config.enabled
      end

      def config
        Gitlab.config.rack_attack.git_basic_auth
      end

      def trusted_ips
        strong_memoize(:trusted_ips) do
          trusted = config.ip_whitelist.map do |proxy|
            IPAddr.new(proxy)
          rescue IPAddr::InvalidAddressError
          end

          trusted += trusted.compact.select(&:ipv4?).map(&:ipv4_mapped)

          trusted.uniq
        end
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/jwt/identity_linker.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    module Jwt
      class IdentityLinker < ::Gitlab::Auth::OAuth::IdentityLinker
        extend ::Gitlab::Utils::Override

        # For security purposes, all requests to link a JWT identity with an existing
        # user that is currently authenticated require user authorization.
        override :authorization_required?
        def authorization_required?
          true if unlinked?
        end
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/key_status_checker.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    class KeyStatusChecker
      include Gitlab::Utils::StrongMemoize

      attr_reader :key

      def initialize(key)
        @key = key
      end

      def show_console_message?
        console_message.present?
      end

      def console_message
        strong_memoize(:console_message) do
          if key.expired?
            _('INFO: Your SSH key has expired. Please generate a new key.')
          elsif key.expires_soon?
            _('INFO: Your SSH key is expiring soon. Please generate a new key.')
          end
        end
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/ldap/access.rb ====
# frozen_string_literal: true

# LDAP authorization model
#
# * Check if we are allowed access (not blocked)
#
module Gitlab
  module Auth
    module Ldap
      class Access
        attr_reader :provider, :user, :ldap_identity

        def self.open(user, &block)
          Gitlab::Auth::Ldap::Adapter.open(user.ldap_identity.provider) do |adapter|
            yield(self.new(user, adapter))
          end
        end

        def self.allowed?(user, options = {})
          self.open(user) do |access|
            # Whether user is allowed, or not, we should update
            # permissions to keep things clean
            if access.allowed?
              unless Gitlab::Database.read_only?
                access.update_user
                Users::UpdateService.new(user, user: user, last_credential_check_at: Time.now).execute
              end

              true
            else
              false
            end
          end
        end

        def initialize(user, adapter = nil)
          @adapter = adapter
          @user = user
          @ldap_identity = user.ldap_identity
          @provider = adapter&.provider || ldap_identity&.provider
        end

        def allowed?
          if ldap_user
            unless ldap_config.active_directory
              unblock_user(user, 'is available again') if user.ldap_blocked?
              return true
            end

            # Block user in GitLab if they were blocked in AD
            if Gitlab::Auth::Ldap::Person.disabled_via_active_directory?(ldap_identity.extern_uid, adapter)
              block_user(user, 'is disabled in Active Directory')
              false
            else
              unblock_user(user, 'is not disabled anymore') if user.ldap_blocked?
              true
            end
          else
            # Block the user if they no longer exist in LDAP/AD
            block_user(user, 'does not exist anymore')
            false
          end
        rescue LdapConnectionError
          false
        end

        def update_user
          # no-op in CE
        end

        private

        def adapter
          @adapter ||= Gitlab::Auth::Ldap::Adapter.new(provider)
        end

        def ldap_config
          Gitlab::Auth::Ldap::Config.new(provider)
        end

        def ldap_user
          return unless provider

          @ldap_user ||= find_ldap_user
        end

        def find_ldap_user
          Gitlab::Auth::Ldap::Person.find_by_dn(ldap_identity.extern_uid, adapter)
        end

        def block_user(user, reason)
          user.ldap_block

          if provider
            Gitlab::AppLogger.info(
              "LDAP account \"#{ldap_identity.extern_uid}\" #{reason}, " \
              "blocking GitLab user \"#{user.name}\" (#{user.email})"
            )
          else
            Gitlab::AppLogger.info(
              "Account is not provided by LDAP, " \
              "blocking GitLab user \"#{user.name}\" (#{user.email})"
            )
          end
        end

        def unblock_user(user, reason)
          user.activate

          Gitlab::AppLogger.info(
            "LDAP account \"#{ldap_identity.extern_uid}\" #{reason}, " \
            "unblocking GitLab user \"#{user.name}\" (#{user.email})"
          )
        end
      end
    end
  end
end

Gitlab::Auth::Ldap::Access.prepend_mod_with('Gitlab::Auth::Ldap::Access')
==== /workspace/gitlab/lib/gitlab/auth/ldap/adapter.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    module Ldap
      class Adapter
        SEARCH_RETRY_FACTOR = [1, 1, 2, 3].freeze
        MAX_SEARCH_RETRIES = Rails.env.test? ? 1 : SEARCH_RETRY_FACTOR.size

        attr_reader :provider, :ldap

        def self.open(provider, &block)
          Net::LDAP.open(config(provider).adapter_options) do |ldap|
            yield(self.new(provider, ldap))
          end
        end

        def self.config(provider)
          Gitlab::Auth::Ldap::Config.new(provider)
        end

        def initialize(provider, ldap = nil)
          @provider = provider
          @ldap = ldap || renew_connection_adapter
        end

        def config
          Gitlab::Auth::Ldap::Config.new(provider)
        end

        def users(fields, value, limit = nil)
          options = user_options(Array(fields), value, limit)
          users_search(options)
        end

        def user(...)
          users(...).first
        end

        def dn_matches_filter?(dn, filter)
          ldap_search(base: dn,
            filter: filter,
            scope: Net::LDAP::SearchScope_BaseObject,
            attributes: %w[dn]).any?
        end

        def ldap_search(*args)
          retries ||= 0

          # Net::LDAP's `time` argument doesn't work. Use Ruby `Timeout` instead.
          Timeout.timeout(timeout_time(retries)) do
            results = ldap.search(*args)

            if results.nil?
              response = ldap.get_operation_result
              check_empty_response_code(response)
              []
            else
              results
            end
          end
        rescue Net::LDAP::Error, Timeout::Error => error
          retries += 1
          error_message = connection_error_message(error)

          Gitlab::AppLogger.warn(error_message)

          if retries < MAX_SEARCH_RETRIES
            renew_connection_adapter
            retry
          else
            raise LdapConnectionError, error_message
          end
        end

        private

        def timeout_time(retry_number)
          SEARCH_RETRY_FACTOR[retry_number] * config.timeout
        end

        def users_search(options)
          entries = ldap_search(options).select do |entry|
            entry.respond_to? config.uid
          end

          entries.map do |entry|
            Gitlab::Auth::Ldap::Person.new(entry, provider)
          end
        end

        def user_options(fields, value, limit)
          options = {
            attributes: Gitlab::Auth::Ldap::Person.ldap_attributes(config),
            base: config.base
          }

          options[:size] = limit if limit

          if fields.include?('dn')
            raise ArgumentError, 'It is not currently possible to search the DN and other fields at the same time.' if fields.size > 1

            options[:base] = value
            options[:scope] = Net::LDAP::SearchScope_BaseObject
          else
            filter = fields.map { |field| Net::LDAP::Filter.eq(field, value) }.inject(:|)
          end

          options.merge(filter: user_filter(filter))
        end

        def user_filter(filter = nil)
          user_filter = config.constructed_user_filter if config.user_filter.present?

          if user_filter && filter
            Net::LDAP::Filter.join(filter, user_filter)
          elsif user_filter
            user_filter
          else
            filter
          end
        end

        def connection_error_message(exception)
          if exception.is_a?(Timeout::Error)
            "LDAP search timed out after #{config.timeout} seconds"
          else
            "LDAP search raised exception #{exception.class}: #{exception.message}"
          end
        end

        def renew_connection_adapter
          @ldap = Net::LDAP.new(config.adapter_options)
        end

        def check_empty_response_code(response)
          if config.retry_empty_result_with_codes.include?(response.code)
            raise Net::LDAP::Error, "Got empty results with response code: #{response.code}, message: #{response.message}"
          end

          unless response.code == 0
            Gitlab::AppLogger.warn("LDAP search error: #{response.message}")
          end
        end
      end
    end
  end
end

Gitlab::Auth::Ldap::Adapter.prepend_mod_with('Gitlab::Auth::Ldap::Adapter')
==== /workspace/gitlab/lib/gitlab/auth/ldap/authentication.rb ====
# frozen_string_literal: true

# These calls help to authenticate to LDAP by providing username and password
#
# Since multiple LDAP servers are supported, it will loop through all of them
# until a valid bind is found
#

module Gitlab
  module Auth
    module Ldap
      class Authentication < Gitlab::Auth::OAuth::Authentication
        def self.login(login, password)
          return unless Gitlab::Auth::Ldap::Config.enabled?
          return unless login.present? && password.present?

          # return found user that was authenticated by first provider for given login credentials
          providers.find do |provider|
            auth = new(provider)
            break auth.user if auth.login(login, password) # true will exit the loop
          end
        end

        def self.providers
          Gitlab::Auth::Ldap::Config.providers
        end

        def login(login, password)
          result = adapter.bind_as(
            filter: user_filter(login),
            size: 1,
            password: password
          )
          return unless result

          @user = Gitlab::Auth::Ldap::User.find_by_uid_and_provider(result.dn, provider)
        end

        def adapter
          OmniAuth::LDAP::Adaptor.new(config.omniauth_options)
        end

        def config
          Gitlab::Auth::Ldap::Config.new(provider)
        end

        def user_filter(login)
          # Allow LDAP users to authenticate by using their GitLab username in case
          # their LDAP username does not match GitLab username or
          # their LDAP username collide with another user's GitLab username.
          # See https://gitlab.com/gitlab-org/gitlab/-/merge_requests/186848
          uid = if user && user.ldap_user?
                  ::Gitlab::Auth::Ldap::Person.find_by_dn(
                    user.ldap_identity.extern_uid,
                    Gitlab::Auth::Ldap::Adapter.new(provider)
                  )&.uid
                end

          uid ||= login

          filter = Net::LDAP::Filter.equals(config.uid, uid)

          # Apply LDAP user filter if present
          if config.user_filter.present?
            filter = Net::LDAP::Filter.join(filter, config.constructed_user_filter)
          end

          filter
        end
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/ldap/auth_hash.rb ====
# frozen_string_literal: true

# Class to parse and transform the info provided by omniauth
#
module Gitlab
  module Auth
    module Ldap
      class AuthHash < Gitlab::Auth::OAuth::AuthHash
        extend ::Gitlab::Utils::Override

        def uid
          @uid ||= Gitlab::Auth::Ldap::Person.normalize_dn(super)
        end

        def username
          super.tap do |username|
            username.downcase! if ldap_config.lowercase_usernames
          end
        end

        private

        def get_info(key)
          attributes = ldap_config.attributes[key.to_s]
          return super unless attributes

          attributes = Array(attributes)

          value = nil
          attributes.each do |attribute|
            value = get_raw(attribute)
            value = value.first if value
            break if value.present?
          end

          return super unless value

          Gitlab::Utils.force_utf8(value)
          value
        end

        def get_raw(key)
          auth_hash.extra[:raw_info][key] if auth_hash.extra
        end

        def ldap_config
          @ldap_config ||= Gitlab::Auth::Ldap::Config.new(self.provider)
        end

        # Overrding this method as LDAP allows email as the username !
        override :get_username
        def get_username
          username_claims.map { |claim| get_from_auth_hash_or_info(claim) }.find(&:presence)
        end
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/ldap/config.rb ====
# frozen_string_literal: true

# Load a specific server configuration
module Gitlab
  module Auth
    module Ldap
      class Config
        NET_LDAP_ENCRYPTION_METHOD = {
          simple_tls: :simple_tls,
          start_tls: :start_tls,
          plain: nil
        }.freeze

        attr_accessor :provider, :options

        InvalidProvider = Class.new(StandardError)

        def self.enabled?
          Gitlab.config.ldap.enabled
        end

        def self.sign_in_enabled?
          enabled? && !prevent_ldap_sign_in?
        end

        def self.prevent_ldap_sign_in?
          Gitlab.config.ldap.prevent_ldap_sign_in
        end

        def self.servers
          Gitlab.config.ldap.servers&.values || []
        end

        def self.available_servers
          return [] unless enabled?

          _available_servers
        end

        def self._available_servers
          Array.wrap(servers.first)
        end

        def self.providers
          provider_names_from_servers(servers)
        end

        def self.available_providers
          provider_names_from_servers(available_servers)
        end

        def self.provider_names_from_servers(servers)
          servers&.map { |server| server['provider_name'] } || []
        end
        private_class_method :provider_names_from_servers

        def self.valid_provider?(provider)
          providers.include?(provider)
        end

        def self.invalid_provider(provider)
          raise InvalidProvider, "Unknown provider (#{provider}). Available providers: #{providers}"
        end

        def self.encrypted_secrets
          Settings.encrypted(Gitlab.config.ldap.secret_file)
        end

        def initialize(provider)
          if self.class.valid_provider?(provider)
            @provider = provider
          else
            self.class.invalid_provider(provider)
          end

          @options = config_for(@provider) # Use @provider, not provider
        end

        def enabled?
          base_config.enabled
        end

        def adapter_options
          opts = base_options.merge(
            encryption: encryption_options,
            instrumentation_service: ActiveSupport::Notifications
          )

          opts.merge!(auth_options) if has_auth?

          opts
        end

        def omniauth_options
          opts = base_options.merge(
            base: base,
            encryption: encryption,
            filter: omniauth_user_filter,
            name_proc: name_proc,
            disable_verify_certificates: !options['verify_certificates'],
            tls_options: tls_options
          )

          if has_auth?
            opts.merge!(
              bind_dn: auth_username,
              password: auth_password
            )
          end

          opts
        end

        def base
          @base ||= Person.normalize_dn(options['base'])
        end

        def uid
          options['uid']
        end

        def label
          options['label']
        end

        def sync_ssh_keys?
          sync_ssh_keys.present?
        end

        # The LDAP attribute in which the ssh keys are stored
        def sync_ssh_keys
          options['sync_ssh_keys']
        end

        def user_filter
          options['user_filter']
        end

        def constructed_user_filter
          @constructed_user_filter ||= Net::LDAP::Filter.construct(user_filter)
        end

        def group_base
          options['group_base']
        end

        def admin_group
          options['admin_group']
        end

        def duo_add_on_groups
          Array(options['duo_add_on_groups'])
        end

        def active_directory
          options['active_directory']
        end

        def smartcard_ad_cert_field
          options['smartcard_ad_cert_field'] || 'altSecurityIdentities'
        end

        def smartcard_ad_cert_format
          options['smartcard_ad_cert_format']
        end

        def block_auto_created_users
          options['block_auto_created_users']
        end

        def attributes
          default_attributes.merge(options['attributes'])
        end

        def timeout
          options['timeout'].to_i
        end

        def retry_empty_result_with_codes
          options.fetch('retry_empty_result_with_codes', [])
        end

        def external_groups
          options['external_groups'] || []
        end

        def has_auth?
          auth_password || auth_username
        end

        def allow_username_or_email_login
          options['allow_username_or_email_login']
        end

        def lowercase_usernames
          options['lowercase_usernames']
        end

        def sync_name
          options['sync_name']
        end

        def encryption
          options['encryption'] || 'plain'
        end

        def name_proc
          if allow_username_or_email_login
            proc { |name| name.gsub(/@.*\z/, '') }
          else
            proc { |name| name }
          end
        end

        def default_attributes
          {
            'username' => %W[#{uid} uid sAMAccountName userid].uniq,
            'email' => %w[mail email userPrincipalName],
            'name' => 'cn',
            'first_name' => 'givenName',
            'last_name' => 'sn'
          }
        end

        protected

        def base_options
          {
            host: options['host'],
            port: options['port'],
            hosts: options['hosts']
          }
        end

        def base_config
          Gitlab.config.ldap
        end

        def config_for(provider)
          base_config.servers.values.find { |server| server['provider_name'] == provider }
        end

        def encryption_options
          method = translate_method
          return unless method

          {
            method: method,
            tls_options: tls_options
          }
        end

        def translate_method
          NET_LDAP_ENCRYPTION_METHOD[encryption.to_sym]
        end

        def tls_options
          return @tls_options if defined?(@tls_options)

          method = translate_method
          return unless method

          opts = if options['verify_certificates'] && method != 'plain'
                   # Dup so we don't accidentally overwrite the constant
                   OpenSSL::SSL::SSLContext::DEFAULT_PARAMS.dup
                 else
                   # It is important to explicitly set verify_mode for two reasons:
                   # 1. The behavior of OpenSSL is undefined when verify_mode is not set.
                   # 2. The net-ldap gem implementation verifies the certificate hostname
                   #    unless verify_mode is set to VERIFY_NONE.
                   { verify_mode: OpenSSL::SSL::VERIFY_NONE }
                 end

          opts.merge!(custom_tls_options)

          @tls_options = opts
        end

        def custom_tls_options
          return {} unless options['tls_options']

          # Dup so we don't overwrite the original value
          custom_options = options['tls_options'].to_hash.delete_if { |_, value| value.nil? || value.blank? }
          custom_options.symbolize_keys!

          if custom_options[:cert]
            begin
              custom_options[:cert] = OpenSSL::X509::Certificate.new(custom_options[:cert])
            rescue OpenSSL::X509::CertificateError => e
              Gitlab::AppLogger.error "LDAP TLS Options 'cert' is invalid for provider #{provider}: #{e.message}"
            end
          end

          if custom_options[:key]
            begin
              custom_options[:key] = OpenSSL::PKey.read(custom_options[:key])
            rescue OpenSSL::PKey::PKeyError => e
              Gitlab::AppLogger.error "LDAP TLS Options 'key' is invalid for provider #{provider}: #{e.message}"
            end
          end

          custom_options
        end

        def auth_options
          {
            auth: {
              method: :simple,
              username: auth_username,
              password: auth_password
            }
          }
        end

        def secrets
          @secrets ||= self.class.encrypted_secrets[@provider.delete_prefix('ldap').to_sym]
        rescue StandardError => e
          Gitlab::AppLogger.error "LDAP encrypted secrets are invalid: #{e.inspect}"

          nil
        end

        def auth_password
          return options['password'] if options['password']

          secrets&.fetch(:password, nil)&.chomp
        end

        def auth_username
          return options['bind_dn'] if options['bind_dn']

          secrets&.fetch(:bind_dn, nil)&.chomp
        end

        def omniauth_user_filter
          uid_filter = Net::LDAP::Filter.eq(uid, '%{username}')

          if user_filter.present?
            Net::LDAP::Filter.join(uid_filter, constructed_user_filter).to_s
          else
            uid_filter.to_s
          end
        end
      end
    end
  end
end

Gitlab::Auth::Ldap::Config.prepend_mod_with('Gitlab::Auth::Ldap::Config')
==== /workspace/gitlab/lib/gitlab/auth/ldap/dn.rb ====
# frozen_string_literal: true

# Based on the `ruby-net-ldap` gem's `Net::LDAP::DN`
#
# For our purposes, this class is used to normalize DNs in order to allow proper
# comparison.
#
# E.g. DNs should be compared case-insensitively (in basically all LDAP
# implementations or setups), therefore we downcase every DN.

##
# Objects of this class represent an LDAP DN ("Distinguished Name"). A DN
# ("Distinguished Name") is a unique identifier for an entry within an LDAP
# directory. It is made up of a number of other attributes strung together,
# to identify the entry in the tree.
#
# Each attribute that makes up a DN needs to have its value escaped so that
# the DN is valid. This class helps take care of that.
#
# A fully escaped DN needs to be unescaped when analysing its contents. This
# class also helps take care of that.
module Gitlab
  module Auth
    module Ldap
      class DN
        FormatError = Class.new(StandardError)
        MalformedError = Class.new(FormatError)
        UnsupportedError = Class.new(FormatError)

        def self.normalize_value(given_value)
          dummy_dn = "placeholder=#{given_value}"
          normalized_dn = new(*dummy_dn).to_normalized_s
          normalized_dn.delete_prefix('placeholder=')
        end

        ##
        # Initialize a DN, escaping as required. Pass in attributes in name/value
        # pairs. If there is a left over argument, it will be appended to the dn
        # without escaping (useful for a base string).
        #
        # Most uses of this class will be to escape a DN, rather than to parse it,
        # so storing the dn as an escaped String and parsing parts as required
        # with a state machine seems sensible.
        def initialize(*args)
          if args.length > 1
            initialize_array(args)
          else
            initialize_string(args[0])
          end
        end

        ##
        # Parse a DN into key value pairs using ASN from
        # https://www.rfc-editor.org/rfc/rfc2253 section 3.
        # rubocop:disable Metrics/AbcSize
        # rubocop:disable Metrics/CyclomaticComplexity
        # rubocop:disable Metrics/PerceivedComplexity
        def each_pair
          state = :key
          key = StringIO.new
          value = StringIO.new
          hex_buffer = ""

          @dn.each_char.with_index do |char, dn_index|
            case state
            when :key then
              case char
              when 'a'..'z', 'A'..'Z' then
                state = :key_normal
                key << char
              when '0'..'9' then
                state = :key_oid
                key << char
              when ' ' then state = :key
              else raise(MalformedError, "Unrecognized first character of an RDN attribute type name \"#{char}\"")
              end
            when :key_normal then
              case char
              when '=' then state = :value
              when 'a'..'z', 'A'..'Z', '0'..'9', '-', ' ' then key << char
              else raise(MalformedError, "Unrecognized RDN attribute type name character \"#{char}\"")
              end
            when :key_oid then
              case char
              when '=' then state = :value
              when '0'..'9', '.', ' ' then key << char
              else raise(MalformedError, "Unrecognized RDN OID attribute type name character \"#{char}\"")
              end
            when :value then
              case char
              when '\\' then state = :value_normal_escape
              when '"' then state = :value_quoted
              when ' ' then state = :value
              when '#' then
                state = :value_hexstring
                value << char
              when ',' then
                state = :key
                yield key.string.strip, rstrip_except_escaped(value.string, dn_index)
                key = StringIO.new
                value = StringIO.new
              else
                state = :value_normal
                value << char
              end
            when :value_normal then
              case char
              when '\\' then state = :value_normal_escape
              when ',' then
                state = :key
                yield key.string.strip, rstrip_except_escaped(value.string, dn_index)
                key = StringIO.new
                value = StringIO.new
              when '+' then raise(UnsupportedError, "Multivalued RDNs are not supported")
              else value << char
              end
            when :value_normal_escape then
              case char
              when '0'..'9', 'a'..'f', 'A'..'F' then
                state = :value_normal_escape_hex
                hex_buffer = char
              else
                state = :value_normal
                value << char
              end
            when :value_normal_escape_hex then
              case char
              when '0'..'9', 'a'..'f', 'A'..'F' then
                state = :value_normal
                value << "#{hex_buffer}#{char}".to_i(16).chr
              else raise(MalformedError, "Invalid escaped hex code \"\\#{hex_buffer}#{char}\"")
              end
            when :value_quoted then
              case char
              when '\\' then state = :value_quoted_escape
              when '"' then state = :value_end
              else value << char
              end
            when :value_quoted_escape then
              case char
              when '0'..'9', 'a'..'f', 'A'..'F' then
                state = :value_quoted_escape_hex
                hex_buffer = char
              else
                state = :value_quoted
                value << char
              end
            when :value_quoted_escape_hex then
              case char
              when '0'..'9', 'a'..'f', 'A'..'F' then
                state = :value_quoted
                value << "#{hex_buffer}#{char}".to_i(16).chr
              else raise(MalformedError, "Expected the second character of a hex pair inside a double quoted value, but got \"#{char}\"")
              end
            when :value_hexstring then
              case char
              when '0'..'9', 'a'..'f', 'A'..'F' then
                state = :value_hexstring_hex
                value << char
              when ' ' then state = :value_end
              when ',' then
                state = :key
                yield key.string.strip, rstrip_except_escaped(value.string, dn_index)
                key = StringIO.new
                value = StringIO.new
              else raise(MalformedError, "Expected the first character of a hex pair, but got \"#{char}\"")
              end
            when :value_hexstring_hex then
              case char
              when '0'..'9', 'a'..'f', 'A'..'F' then
                state = :value_hexstring
                value << char
              else raise(MalformedError, "Expected the second character of a hex pair, but got \"#{char}\"")
              end
            when :value_end then
              case char
              when ' ' then state = :value_end
              when ',' then
                state = :key
                yield key.string.strip, rstrip_except_escaped(value.string, dn_index)
                key = StringIO.new
                value = StringIO.new
              else raise(MalformedError, "Expected the end of an attribute value, but got \"#{char}\"")
              end
            else raise "Fell out of state machine"
            end
          end

          # Last pair
          raise(MalformedError, 'DN string ended unexpectedly') unless
            [:value, :value_normal, :value_hexstring, :value_end].include? state

          yield key.string.strip, rstrip_except_escaped(value.string, @dn.length)
        end

        def rstrip_except_escaped(str, dn_index)
          str_ends_with_whitespace = str.match(/\s\z/)

          if str_ends_with_whitespace
            dn_part_ends_with_escaped_whitespace = @dn[0, dn_index].match(/\\(\s+)\z/)

            if dn_part_ends_with_escaped_whitespace
              dn_part_rwhitespace = dn_part_ends_with_escaped_whitespace[1]
              num_chars_to_remove = dn_part_rwhitespace.length - 1
              str = str[0, str.length - num_chars_to_remove]
            else
              str.rstrip!
            end
          end

          str
        end

        ##
        # Returns the DN as an array in the form expected by the constructor.
        def to_a
          a = []
          self.each_pair { |key, value| a << key << value } unless @dn.empty?
          a
        end

        ##
        # Return the DN as an escaped string.
        def to_s
          @dn
        end

        ##
        # Return the DN as an escaped and normalized string.
        def to_normalized_s
          self.class.new(*to_a).to_s.downcase
        end

        # https://www.rfc-editor.org/rfc/rfc4514 section 2.4 lists these exceptions
        # for DN values. All of the following must be escaped in any normal string
        # using a single backslash ('\') as escape. The space character is left
        # out here because in a "normalized" string, spaces should only be escaped
        # if necessary (i.e. leading or trailing space).
        NORMAL_ESCAPES = [',', '+', '"', '\\', '<', '>', ';', '='].freeze

        # The following must be represented as escaped hex
        HEX_ESCAPES = {
          "\n" => '\0a',
          "\r" => '\0d'
        }.freeze

        # Compiled character class regexp using the keys from the above hash, and
        # checking for a space or # at the start, or space at the end, of the
        # string.
        ESCAPE_RE = Regexp.new("(^ |^#| $|[" +
                              NORMAL_ESCAPES.map { |e| Regexp.escape(e) }.join +
                              "])")

        HEX_ESCAPE_RE = Regexp.new("([" +
                              HEX_ESCAPES.keys.map { |e| Regexp.escape(e) }.join +
                              "])")

        ##
        # Escape a string for use in a DN value
        def self.escape(string)
          escaped = string.gsub(ESCAPE_RE) { |char| "\\" + char }
          escaped.gsub(HEX_ESCAPE_RE) { |char| HEX_ESCAPES[char] }
        end

        private

        def initialize_array(args)
          buffer = StringIO.new

          args.each_with_index do |arg, index|
            if index.even? # key
              buffer << "," if index > 0
              buffer << arg
            else # value
              buffer << "="
              buffer << self.class.escape(arg)
            end
          end

          @dn = buffer.string
        end

        def initialize_string(arg)
          @dn = arg.to_s
        end

        ##
        # Proxy all other requests to the string object, because a DN is mainly
        # used within the library as a string
        # rubocop:disable GitlabSecurity/PublicSend
        def method_missing(method, *args, &block)
          @dn.send(method, *args, &block)
        end

        ##
        # Redefined to be consistent with redefined `method_missing` behavior
        def respond_to?(sym, include_private = false)
          @dn.respond_to?(sym, include_private)
        end
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/ldap/ldap_connection_error.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    module Ldap
      LdapConnectionError = Class.new(StandardError)
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/ldap/person.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    module Ldap
      class Person
        # Active Directory-specific LDAP filter that checks if bit 2 of the
        # userAccountControl attribute is set.
        # Source: http://ctogonewild.com/2009/09/03/bitmask-searches-in-ldap/
        AD_USER_DISABLED = Net::LDAP::Filter.ex("userAccountControl:1.2.840.113556.1.4.803", "2")

        InvalidEntryError = Class.new(StandardError)

        attr_accessor :provider

        def self.find_by_uid(uid, adapter)
          uid = Net::LDAP::Filter.escape(uid)
          adapter.user(adapter.config.uid, uid)
        end

        def self.find_by_dn(dn, adapter)
          adapter.user('dn', dn)
        end

        def self.find_by_email(email, adapter)
          email_fields = adapter.config.attributes['email']

          adapter.user(email_fields, email)
        end

        def self.disabled_via_active_directory?(dn, adapter)
          adapter.dn_matches_filter?(dn, AD_USER_DISABLED)
        end

        def self.ldap_attributes(config)
          [
            'dn',
            config.uid,
            *config.attributes['name'],
            *config.attributes['email'],
            *config.attributes['username']
          ].compact.uniq.reject(&:blank?)
        end

        def self.normalize_dn(dn)
          ::Gitlab::Auth::Ldap::DN.new(dn).to_normalized_s
        rescue ::Gitlab::Auth::Ldap::DN::FormatError => e
          Gitlab::AppLogger.info("Returning original DN \"#{dn}\" due to error during normalization attempt: #{e.message}")

          dn
        end

        # Returns the UID in a normalized form.
        #
        # 1. Excess spaces are stripped
        # 2. The string is downcased (for case-insensitivity)
        def self.normalize_uid(uid)
          ::Gitlab::Auth::Ldap::DN.normalize_value(uid)
        rescue ::Gitlab::Auth::Ldap::DN::FormatError => e
          Gitlab::AppLogger.info("Returning original UID \"#{uid}\" due to error during normalization attempt: #{e.message}")

          uid
        end

        def initialize(entry, provider)
          Gitlab::AppLogger.debug "Instantiating #{self.class.name} with LDIF:\n#{entry.to_ldif}"
          @entry = entry
          @provider = provider
        end

        def name
          attribute_value(:name)&.first
        end

        def uid
          entry.public_send(config.uid).first # rubocop:disable GitlabSecurity/PublicSend
        end

        def username
          username = attribute_value(:username)

          # Depending on the attribute, multiple values may
          # be returned. We need only one for username.
          # Ex. `uid` returns only one value but `mail` may
          # return an array of multiple email addresses.
          [username].flatten.first.tap do |username|
            username.downcase! if config.lowercase_usernames
          end
        end

        def email
          attribute_value(:email)
        end

        def dn
          self.class.normalize_dn(entry.dn)
        end

        private

        attr_reader :entry

        def config
          @config ||= Gitlab::Auth::Ldap::Config.new(provider)
        end

        # Using the LDAP attributes configuration, find and return the first
        # attribute with a value. For example, by default, when given 'email',
        # this method looks for 'mail', 'email' and 'userPrincipalName' and
        # returns the first with a value.
        def attribute_value(attribute)
          attributes = Array(config.attributes[attribute.to_s])
          selected_attr = attributes.find { |attr| entry.respond_to?(attr) }

          return unless selected_attr

          entry.public_send(selected_attr) # rubocop:disable GitlabSecurity/PublicSend
        end
      end
    end
  end
end

Gitlab::Auth::Ldap::Person.prepend_mod_with('Gitlab::Auth::Ldap::Person')
==== /workspace/gitlab/lib/gitlab/auth/ldap/user.rb ====
# frozen_string_literal: true

# LDAP extension for User model
#
# * Find or create user from omniauth.auth data
# * Links LDAP account with existing user
# * Auth LDAP user with login and password
#
module Gitlab
  module Auth
    module Ldap
      class User < Gitlab::Auth::OAuth::User
        extend ::Gitlab::Utils::Override

        # instance methods
        def find_user
          find_by_uid_and_provider || find_by_email || build_new_user
        end

        override :should_save?
        def should_save?
          gl_user.changed? || gl_user.identities.any?(&:changed?)
        end

        def block_after_signup?
          ldap_config.block_auto_created_users
        end

        def allowed?
          Gitlab::Auth::Ldap::Access.allowed?(gl_user)
        end

        def valid_sign_in?
          # The order is important here: we need to ensure the
          # associated GitLab user entry is valid and persisted in the
          # database. Otherwise, the LDAP access check will fail since
          # the user doesn't have an associated LDAP identity.
          super && allowed?
        end

        def ldap_config
          Gitlab::Auth::Ldap::Config.new(auth_hash.provider)
        end

        def auth_hash=(auth_hash)
          @auth_hash = Gitlab::Auth::Ldap::AuthHash.new(auth_hash)
        end

        def protocol_name
          'LDAP'
        end
      end
    end
  end
end

Gitlab::Auth::Ldap::User.prepend_mod_with('Gitlab::Auth::Ldap::User')
==== /workspace/gitlab/lib/gitlab/auth/o_auth/authentication.rb ====
# frozen_string_literal: true

# These calls help to authenticate to OAuth provider by providing username and password
#

module Gitlab
  module Auth
    module OAuth
      class Authentication
        attr_reader :provider, :user

        def initialize(provider, user = nil)
          @provider = provider
          @user = user
        end

        # Implementation must return user object if login successful
        def login(login, password)
          raise NotImplementedError
        end
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/o_auth/auth_hash.rb ====
# frozen_string_literal: true

# Class to parse and transform the info provided by omniauth
#
module Gitlab
  module Auth
    module OAuth
      class AuthHash
        attr_reader :auth_hash
        attr_accessor :errors

        def initialize(auth_hash)
          @auth_hash = auth_hash
          @errors = {}
        end

        def uid
          @uid ||= Gitlab::Utils.force_utf8(auth_hash.uid.to_s)
        end

        def provider
          @provider ||= auth_hash.provider.to_s
        end

        def name
          @name ||= get_info(:name) || "#{get_info(:first_name)} #{get_info(:last_name)}"
        end

        def username
          @username ||= username_and_email[:username].to_s
        end

        def email
          @email ||= username_and_email[:email].to_s
        end

        def password
          @password ||= Gitlab::Utils.force_utf8(::User.random_password)
        end

        def location
          location = get_info(:address)
          if location.is_a?(Hash)
            [location.locality.presence, location.country.presence].compact.join(', ')
          else
            location
          end
        end

        def organization
          get_info(:organization)
        end

        def job_title
          get_info(:job_title)
        end

        def has_attribute?(attribute)
          case attribute
          when :location
            get_info(:address).present?
          when :organization
            get_info(:organization).present?
          when :job_title
            get_info(:job_title).present?
          else
            get_info(attribute).present?
          end
        end

        private

        def info
          auth_hash['info']
        end

        def coerce_utf8(value)
          value.is_a?(String) ? Gitlab::Utils.force_utf8(value) : value
        end

        def get_info(key)
          coerce_utf8(info[key])
        end

        def provider_config
          Gitlab::Auth::OAuth::Provider.config_for(provider) || {}
        end

        def provider_args
          @provider_args ||= provider_config['args'].presence || {}
        end

        def get_from_auth_hash_or_info(key)
          if auth_hash.key?(key)
            coerce_utf8(auth_hash[key])
          elsif auth_hash.key?(:extra) && auth_hash.extra.key?(:raw_info) && !auth_hash.extra.raw_info[key].blank?
            coerce_utf8(auth_hash.extra.raw_info[key])
          else
            get_info(key)
          end
        end

        # Allow for configuring a custom username claim per provider from
        # the auth hash or use the canonical username or nickname fields
        def gitlab_username_claim
          provider_args['gitlab_username_claim']&.to_sym
        end

        def username_claims
          [gitlab_username_claim, :username, :nickname].compact
        end

        def get_username
          username_claims.map { |claim| get_from_auth_hash_or_info(claim) }
            .find { |name| name.presence }
            &.split("@")
            &.first
        end

        def username_and_email
          @username_and_email ||= begin
            username  = get_username
            email     = get_info(:email).presence

            username ||= generate_username(email)             if email
            email    ||= generate_temporarily_email(username) if username

            {
              username: username,
              email: email
            }
          end
        end

        # Get the first part of the email address (before @)
        # In addition in removes illegal characters
        # Perform length validation twice:
        # - Before normalization to prevent normalizing excessively long strings
        # - After normalization to ensure certain normalized multibyte characters don't exceed length.
        def generate_username(email)
          return unless valid_email_username_length?(email)

          username = mb_chars_unicode_normalize(email.match(/^[^@]*/)[0])
          username if valid_email_username_length?(username)
        end

        def generate_temporarily_email(username)
          "temp-email-for-oauth-#{username}@gitlab.localhost"
        end

        # RFC 3606 and RFC 2821 restrict total email length to
        # 254 characters. Do not allow longer emails to be passed in
        # because unicode normalization can be intensive.
        def valid_email_username_length?(email_or_username)
          return true if email_or_username.length <= 254

          errors[:identity_provider_email] = _("must be 254 characters or less.")
          false
        end

        def mb_chars_unicode_normalize(string)
          string.mb_chars.unicode_normalize(:nfkd).gsub(/[^\x00-\x7F]/, '').to_s
        end
      end
    end
  end
end

Gitlab::Auth::OAuth::AuthHash.prepend_mod_with('Gitlab::Auth::OAuth::AuthHash')
==== /workspace/gitlab/lib/gitlab/auth/o_auth/before_request_phase_oauth_login_counter_increment.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    module OAuth
      module BeforeRequestPhaseOauthLoginCounterIncrement
        def self.counter
          Gitlab::Metrics.counter(:gitlab_omniauth_login_total, 'Counter of initiated OmniAuth login attempts')
        end

        def self.call(env)
          provider = current_provider_name_from(env)
          return unless provider

          counter.increment(omniauth_provider: provider, status: 'initiated')
        end

        private_class_method def self.current_provider_name_from(env)
          env['omniauth.strategy']&.name
        end
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/o_auth/identity_linker.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    module OAuth
      class IdentityLinker < OmniauthIdentityLinkerBase
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/o_auth/oauth_resource_owner_redirect_resolver.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    module OAuth
      class OauthResourceOwnerRedirectResolver
        include ::Gitlab::Routing

        attr_reader :request, :session

        def initialize(request, session)
          @request = request
          @session = session
        end

        def resolve_redirect_url
          new_user_session_url
        end
      end
    end
  end
end

Gitlab::Auth::OAuth::OauthResourceOwnerRedirectResolver.prepend_mod
==== /workspace/gitlab/lib/gitlab/auth/o_auth/provider.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    module OAuth
      class Provider
        LABELS = {
          "alicloud" => "AliCloud",
          "github" => "GitHub",
          "gitlab" => "GitLab.com",
          "google_oauth2" => "Google",
          "azure_oauth2" => "Azure AD (Obsolete)",
          "azure_activedirectory_v2" => "Azure AD v2",
          'atlassian_oauth2' => 'Atlassian'
        }.freeze

        def self.authentication(user, provider)
          return unless user
          return unless enabled?(provider)

          authenticator =
            case provider
            when /crowd/
              Gitlab::Auth::Crowd::Authentication
            when /^ldap/
              Gitlab::Auth::Ldap::Authentication
            when 'database'
              Gitlab::Auth::Database::Authentication
            end

          authenticator&.new(provider, user)
        end

        def self.providers
          ::Devise.omniauth_providers
        end

        def self.enabled?(name)
          return true if name == 'database'
          return true if self.ldap_provider?(name) && providers.include?(name.to_sym)

          Gitlab::Auth.omniauth_enabled? && providers.include?(name.to_sym)
        end

        def self.ldap_provider?(name)
          name.to_s.start_with?('ldap')
        end

        def self.sync_profile_from_provider?(provider)
          return true if ldap_provider?(provider)

          providers = Gitlab.config.omniauth.sync_profile_from_provider

          if providers.is_a?(Array)
            providers.include?(provider)
          else
            providers
          end
        end

        def self.config_for(name)
          name = name.to_s
          if ldap_provider?(name)
            if Gitlab::Auth::Ldap::Config.valid_provider?(name)
              Gitlab::Auth::Ldap::Config.new(name).options
            else
              nil
            end
          else
            provider = Gitlab.config.omniauth.providers.find do |provider|
              provider.name == name ||
                (AuthHelper.oidc_providers.include?(provider.name.to_sym) && provider.dig(:args, :name) == name)
            end
            merge_provider_args_with_defaults!(provider)

            provider
          end
        end

        def self.label_for(name)
          name = name.to_s
          config = config_for(name)
          (config && config['label']) || LABELS[name] || name.titleize
        end

        def self.icon_for(name)
          name = name.to_s
          config = config_for(name)
          config && config['icon']
        end

        def self.merge_provider_args_with_defaults!(provider)
          return unless provider

          provider['args'] ||= {}

          defaults = Gitlab::OmniauthInitializer.default_arguments_for(provider['name'])
          provider['args'].deep_merge!(defaults.deep_stringify_keys)
        end
      end
    end
  end
end

# Added for JiHu
# Used in https://jihulab.com/gitlab-cn/gitlab/-/blob/main-jh/jh/lib/gitlab/auth/o_auth/provider.rb
Gitlab::Auth::OAuth::Provider.singleton_class.prepend_mod_with('Gitlab::Auth::OAuth::Provider::ClassMethods')
==== /workspace/gitlab/lib/gitlab/auth/o_auth/user.rb ====
# frozen_string_literal: true

# OAuth extension for User model
#
# * Find GitLab user based on omniauth uid and provider
# * Create new user from omniauth data
#
module Gitlab
  module Auth
    module OAuth
      class User
        class << self
          # rubocop: disable CodeReuse/ActiveRecord

          def find_by_uid_and_provider(uid, provider)
            identity = ::Identity.with_extern_uid(provider, uid).take

            return unless identity
            raise IdentityWithUntrustedExternUidError unless identity.trusted_extern_uid?

            identity.user
          end
          # rubocop: enable CodeReuse/ActiveRecord
        end

        SignupDisabledError = Class.new(StandardError)
        SigninDisabledForProviderError = Class.new(StandardError)
        IdentityWithUntrustedExternUidError = Class.new(StandardError)
        UnknownAttributeMappingError = Class.new(StandardError)

        attr_reader :auth_hash

        def initialize(auth_hash, user_params = {})
          self.auth_hash = auth_hash
          @user_params = user_params
          update_profile
          add_or_update_user_identities
        end

        def persisted?
          gl_user.try(:persisted?)
        end

        def new?
          !persisted?
        end

        def valid?
          !any_auth_hash_errors? && gl_user.try(:valid?)
        end

        def valid_sign_in?
          valid? && persisted?
        end

        def save(provider = protocol_name)
          return false if any_auth_hash_errors?

          raise SigninDisabledForProviderError if oauth_provider_disabled?
          raise SignupDisabledError unless gl_user

          block_after_save = needs_blocking?

          Users::UpdateService.new(gl_user, user: gl_user).execute!

          gl_user.block_pending_approval if block_after_save
          activate_user_if_user_cap_not_reached

          log.info "(#{provider}) saving user #{auth_hash.email} from login with admin => #{gl_user.admin}, extern_uid => #{auth_hash.uid}"
          gl_user
        rescue ActiveRecord::RecordInvalid => e
          log.info "(#{provider}) Error saving user #{auth_hash.uid} (#{auth_hash.email}): #{gl_user.errors.full_messages}"
          [self, e.record.errors]
        end

        def gl_user
          return @gl_user if defined?(@gl_user)

          @gl_user = find_user
        end

        def find_user
          user = find_by_uid_and_provider

          user ||= find_by_email if auto_link_user?
          user ||= find_or_build_ldap_user if auto_link_ldap_user?
          user ||= build_new_user if signup_enabled?

          user.external = true if external_provider? && user&.new_record?

          user
        end

        def find_and_update!
          save if should_save?

          gl_user
        end

        def bypass_two_factor?
          providers = Gitlab.config.omniauth.allow_bypass_two_factor
          if providers.is_a?(Array)
            providers.include?(auth_hash.provider)
          else
            providers
          end
        end

        def protocol_name
          'OAuth'
        end

        protected

        attr_reader :user_params

        def activate_user_if_user_cap_not_reached
          nil
        end

        def should_save?
          true
        end

        def add_or_update_user_identities
          return unless gl_user

          # find_or_initialize_by doesn't update `gl_user.identities`, and isn't autosaved.
          identity = gl_user.identities.find { |identity| identity.provider == auth_hash.provider }

          identity ||= gl_user.identities.build(provider: auth_hash.provider)
          identity.extern_uid = auth_hash.uid

          if auto_link_ldap_user? && !gl_user.ldap_user? && ldap_person
            log.info "Correct LDAP account has been found. identity to user: #{gl_user.username}."
            gl_user.identities.build(provider: ldap_person.provider, extern_uid: ldap_person.dn)
          end
        end

        def find_or_build_ldap_user
          return unless ldap_person

          user = Gitlab::Auth::Ldap::User.find_by_uid_and_provider(ldap_person.dn, ldap_person.provider)
          if user
            log.info "LDAP account found for user #{user.username}. Building new #{auth_hash.provider} identity."
            return user
          end

          log.info "No user found using #{auth_hash.provider} provider. Creating a new one."
          build_new_user
        end

        # rubocop: disable CodeReuse/ActiveRecord
        def find_by_email
          return unless auth_hash.has_attribute?(:email)

          ::User.find_by(email: auth_hash.email.downcase)
        end
        # rubocop: enable CodeReuse/ActiveRecord

        def auto_link_ldap_user?
          Gitlab.config.omniauth.auto_link_ldap_user
        end

        def creating_linked_ldap_user?
          auto_link_ldap_user? && ldap_person
        end

        def ldap_person
          return @ldap_person if defined?(@ldap_person)

          # Look for a corresponding person with same uid in any of the configured LDAP providers
          Gitlab::Auth::Ldap::Config.providers.each do |provider|
            adapter = Gitlab::Auth::Ldap::Adapter.new(provider)
            @ldap_person = find_ldap_person(auth_hash, adapter)
            break if @ldap_person
          end
          @ldap_person
        end

        def find_ldap_person(auth_hash, adapter)
          Gitlab::Auth::Ldap::Person.find_by_uid(auth_hash.uid, adapter) ||
            Gitlab::Auth::Ldap::Person.find_by_email(auth_hash.uid, adapter) ||
            Gitlab::Auth::Ldap::Person.find_by_email(auth_hash.email, adapter) ||
            Gitlab::Auth::Ldap::Person.find_by_dn(auth_hash.uid, adapter)
        rescue Gitlab::Auth::Ldap::LdapConnectionError
          nil
        end

        def ldap_config
          Gitlab::Auth::Ldap::Config.new(ldap_person.provider) if ldap_person
        end

        def needs_blocking?
          new? && block_after_signup?
        end

        def signup_enabled?
          providers = Gitlab.config.omniauth.allow_single_sign_on
          if providers.is_a?(Array)
            providers.include?(auth_hash.provider)
          else
            providers
          end
        end

        def external_provider?
          Gitlab.config.omniauth.external_providers.include?(auth_hash.provider)
        end

        def block_after_signup?
          if creating_linked_ldap_user?
            ldap_config.block_auto_created_users
          else
            Gitlab.config.omniauth.block_auto_created_users
          end
        end

        def auth_hash=(auth_hash)
          @auth_hash = AuthHash.new(auth_hash)
        end

        def find_by_uid_and_provider
          self.class.find_by_uid_and_provider(auth_hash.uid, auth_hash.provider)
        end

        def build_new_user(skip_confirmation: true)
          augmented_user_params = user_attributes.merge(skip_confirmation: skip_confirmation)
          Users::AuthorizedBuildService.new(nil, augmented_user_params).execute
        end

        def user_attributes
          # Give preference to LDAP for sensitive information when creating a linked account
          if creating_linked_ldap_user?
            username = ldap_person.username.presence
            name = ldap_person.name.presence
            email = ldap_person.email&.first.presence
          end

          username ||= auth_hash.username
          name ||= auth_hash.name
          email ||= auth_hash.email

          valid_username = sanitize_username(username)

          {
            name: name.strip.presence || valid_username,
            username: valid_username,
            email: email,
            password: auth_hash.password,
            password_confirmation: auth_hash.password,
            password_automatically_set: true,
            organization_id: user_params[:organization_id]
          }
        end

        def sanitize_username(username)
          ExternalUsernameSanitizer.new(username).sanitize
        end

        def sync_profile_from_provider?
          Gitlab::Auth::OAuth::Provider.sync_profile_from_provider?(auth_hash.provider)
        end

        def update_profile
          return unless gl_user

          clear_user_synced_attributes_metadata
          return unless sync_profile_from_provider? || creating_linked_ldap_user?

          metadata = gl_user.build_user_synced_attributes_metadata

          if sync_profile_from_provider?
            UserSyncedAttributesMetadata.syncable_attributes(auth_hash.provider).each do |key|
              if assign_value_to_user(gl_user, auth_hash, key)
                metadata.set_attribute_synced(key, true)
              else
                metadata.set_attribute_synced(key, false)
              end
            end

            metadata.provider = auth_hash.provider
          end

          if creating_linked_ldap_user?
            metadata.set_attribute_synced(:name, true) if gl_user.name == ldap_person.name
            metadata.set_attribute_synced(:email, true) if gl_user.email.downcase == ldap_person.email&.first&.downcase
            metadata.provider = ldap_person.provider
          end
        end

        def clear_user_synced_attributes_metadata
          gl_user&.user_synced_attributes_metadata&.destroy
        end

        def log
          Gitlab::AppLogger
        end

        def oauth_provider_disabled?
          Gitlab::CurrentSettings.current_application_settings
                                .disabled_oauth_sign_in_sources
                                .include?(auth_hash.provider)
        end

        def auto_link_user?
          auto_link = Gitlab.config.omniauth.auto_link_user
          return auto_link if [true, false].include?(auto_link)

          auto_link = Array(auto_link)
          auto_link.include?(auth_hash.provider)
        end

        def any_auth_hash_errors?
          return false if auth_hash.errors.empty?

          assign_errors_from_auth_hash
          true
        end

        def assign_errors_from_auth_hash
          auth_hash.errors.each do |attr, error|
            gl_user.errors.add(attr, error)
          end
        end

        private

        def assign_value_to_user(user, auth_hash, key)
          return unless auth_hash.has_attribute?(key) && user.sync_attribute?(key)

          value = auth_hash.public_send(key) # rubocop:disable GitlabSecurity/PublicSend -- we validate that `key` is a supported value by calling `auth_hash.has_attribute?(key)` on L330
          if key.to_sym == :organization
            user.user_detail_organization = value
          elsif user.respond_to?(:"#{key}=")
            user.public_send("#{key}=".to_sym, value) # rubocop:disable GitlabSecurity/PublicSend -- we validate that `key` is a supported value by calling `gl_user.sync_attribute?(key)` on L330
          else
            raise UnknownAttributeMappingError
          end

          true
        end
      end
    end
  end
end

Gitlab::Auth::OAuth::User.prepend_mod_with('Gitlab::Auth::OAuth::User')
==== /workspace/gitlab/lib/gitlab/auth/oidc/step_up_auth_before_request_phase.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    module Oidc
      # Handles the step-up authentication request phase for OAuth flow
      #
      # This module manages the initial phase of step-up authentication,
      # setting up the session state for admin mode authentication.
      module StepUpAuthBeforeRequestPhase
        class << self
          def call(env)
            return if current_user_from(env).blank?
            return if Feature.disabled?(:omniauth_step_up_auth_for_admin_mode, current_user_from(env))

            # If the step-up authentication scope is not included in the request params,
            # then step-up authentication is likely not requested and we do not need to proceed.
            return unless step_up_auth_requested_for_admin_mode?(env)

            session = session_from(env)
            provider = current_provider_from(env)
            step_up_auth_flow =
              ::Gitlab::Auth::Oidc::StepUpAuthentication.build_flow(session: session, provider: provider)

            return unless step_up_auth_flow.enabled_by_config?

            # This method will set the state to 'requested' in the session
            step_up_auth_flow.request!
          end

          private

          def step_up_auth_requested_for_admin_mode?(env)
            request_param_step_up_auth_scope_from(env) ==
              ::Gitlab::Auth::Oidc::StepUpAuthentication::STEP_UP_AUTH_SCOPE_ADMIN_MODE.to_s
          end

          def current_user_from(env)
            env['warden']&.user
          end

          def current_provider_from(env)
            env['omniauth.strategy']&.name
          end

          def request_param_step_up_auth_scope_from(env)
            env.dig('rack.request.query_hash', 'step_up_auth_scope').to_s
          end

          def session_from(env)
            env['rack.session']
          end
        end
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/oidc/step_up_authentication_flow.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    module Oidc
      class StepUpAuthenticationFlow
        STATE_REQUESTED = :requested
        STATE_SUCCEEDED = :succeeded
        STATE_FAILED = :failed

        attr_reader :session, :provider, :scope

        def initialize(session:, provider:, scope:)
          @session = session
          @provider = provider
          @scope = scope
        end

        def requested?
          state.to_s == STATE_REQUESTED.to_s
        end

        def succeeded?
          state.to_s == STATE_SUCCEEDED.to_s
        end

        def rejected?
          state.to_s == STATE_FAILED.to_s
        end

        def enabled_by_config?
          ::Gitlab::Auth::Oidc::StepUpAuthentication.enabled_for_provider?(provider_name: provider, scope: scope)
        end

        def evaluate!(oidc_id_token_claims)
          oidc_id_token_claims =
            ::Gitlab::Auth::Oidc::StepUpAuthentication.slice_relevant_id_token_claims(
              oauth_raw_info: oidc_id_token_claims,
              provider: provider,
              scope: scope
            )

          if conditions_fulfilled?(oidc_id_token_claims)
            succeed!
          else
            fail!
          end
        end

        def request!
          update_session_state(STATE_REQUESTED)
        end

        def succeed!
          update_session_state(STATE_SUCCEEDED)
        end

        def fail!
          update_session_state(STATE_FAILED)
        end

        private

        def state
          provider_scope_session_data&.[]('state').to_s.presence
        end

        def provider_scope_session_data
          omniauth_step_up_auth_session_data&.[](provider.to_s)&.[](scope.to_s)
        end

        def update_session_state(new_state)
          omniauth_step_up_auth_session_data[provider.to_s] ||= {}
          omniauth_step_up_auth_session_data[provider.to_s][scope.to_s] ||= {}
          omniauth_step_up_auth_session_data[provider.to_s][scope.to_s]['state'] = new_state.to_s
        end

        def omniauth_step_up_auth_session_data
          ::Gitlab::Auth::Oidc::StepUpAuthentication.omniauth_step_up_auth_session_data(session)
        end

        def conditions_fulfilled?(oidc_id_token_claims)
          ::Gitlab::Auth::Oidc::StepUpAuthentication
            .conditions_fulfilled?(oauth_extra_metadata: oidc_id_token_claims, provider: provider, scope: scope)
        end
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/oidc/step_up_authentication.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    module Oidc
      # Handles step-up authentication configuration and validation for OAuth providers
      #
      # This module manages the configuration and validation of step-up authentication
      # requirements for OAuth providers, particularly focusing on admin mode access.
      module StepUpAuthentication
        SESSION_STORE_KEY = 'omniauth_step_up_auth'

        STEP_UP_AUTH_SCOPE_ADMIN_MODE = :admin_mode

        class << self
          # Checks if step-up authentication is enabled for the step-up auth scope 'admin_mode'
          #
          # @return [Boolean] true if any OAuth provider requires step-up auth for admin mode
          def enabled_by_config?(scope: STEP_UP_AUTH_SCOPE_ADMIN_MODE)
            oauth_providers.any? do |provider|
              enabled_for_provider?(provider_name: provider, scope: scope)
            end
          end

          # Checks if step-up authentication configuration exists for a provider name
          #
          # @param oauth_provider_name [String] the name of the OAuth provider
          # @param scope [Symbol] the scope to check configuration for (default: :admin_mode)
          # @return [Boolean] true if configuration exists
          def enabled_for_provider?(provider_name:, scope: STEP_UP_AUTH_SCOPE_ADMIN_MODE)
            has_required_claims?(provider_name, scope) ||
              has_included_claims?(provider_name, scope)
          end

          # Verifies if step-up authentication has succeeded for any provider
          # with the step-up auth scope 'admin_mode'
          #
          # @param session [Hash] the session hash containing authentication state
          # @return [Boolean] true if step-up authentication is authenticated
          def succeeded?(session, scope: STEP_UP_AUTH_SCOPE_ADMIN_MODE)
            step_up_auth_flows =
              omniauth_step_up_auth_session_data(session)
                        &.to_h
                        &.flat_map do |provider, step_up_auth_object|
                          step_up_auth_object.map do |step_up_auth_scope, _|
                            build_flow(provider: provider, session: session, scope: step_up_auth_scope)
                          end
                        end
            step_up_auth_flows
              .select do |step_up_auth_flow|
                step_up_auth_flow.scope.to_s == scope.to_s
              end
              .select(&:enabled_by_config?)
              .any?(&:succeeded?)
          end

          # Validates if all step-up authentication conditions are met
          #
          # @param oauth [OAuth2::AccessToken] the OAuth object to validate
          # @param scope [Symbol] the scope to validate conditions for (default: :admin_mode)
          # @return [Boolean] true if all conditions are fulfilled
          def conditions_fulfilled?(oauth_extra_metadata:, provider:, scope: STEP_UP_AUTH_SCOPE_ADMIN_MODE)
            conditions = []

            if has_required_claims?(provider, scope)
              conditions << required_conditions_fulfilled?(oauth_extra_metadata: oauth_extra_metadata,
                provider: provider, scope: scope)
            end

            if has_included_claims?(provider, scope)
              conditions << included_conditions_fulfilled?(oauth_extra_metadata: oauth_extra_metadata,
                provider: provider, scope: scope)
            end

            conditions.present? && conditions.all?
          end

          def build_flow(provider:, session:, scope: STEP_UP_AUTH_SCOPE_ADMIN_MODE)
            Gitlab::Auth::Oidc::StepUpAuthenticationFlow.new(provider: provider, scope: scope, session: session)
          end

          # Slices the relevant ID token claims from the provided OAuth raw information.
          #
          # @param oauth_raw_info [Hash] The raw information received from the OAuth provider.
          # @param provider [String] The name of the OAuth provider.
          # @param scope [String] The scope of the authentication request, default is STEP_UP_AUTH_SCOPE_ADMIN_MODE.
          # @return [Hash] A hash containing only the relevant ID token claims.
          def slice_relevant_id_token_claims(oauth_raw_info:, provider:, scope: STEP_UP_AUTH_SCOPE_ADMIN_MODE)
            relevant_id_token_claims = [
              *get_id_token_claims_required_conditions(provider, scope)&.keys,
              *get_id_token_claims_included_conditions(provider, scope)&.keys
            ]
            oauth_raw_info.slice(*relevant_id_token_claims)
          end

          def omniauth_step_up_auth_session_data(session)
            Gitlab::NamespacedSessionStore.new(SESSION_STORE_KEY, session)
          end

          def disable_step_up_authentication!(session:, scope: STEP_UP_AUTH_SCOPE_ADMIN_MODE)
            omniauth_step_up_auth_session_data(session)
                      &.to_h
                      &.each_value do |step_up_auth_object|
                        step_up_auth_object.delete(scope.to_s)
                      end
          end

          private

          def oauth_providers
            Gitlab::Auth::OAuth::Provider.providers || []
          end

          def has_required_claims?(provider_name, scope)
            get_id_token_claims_required_conditions(provider_name, scope).present?
          end

          def has_included_claims?(provider_name, scope)
            get_id_token_claims_included_conditions(provider_name, scope).present?
          end

          def get_id_token_claims_required_conditions(provider_name, scope)
            dig_provider_config(provider_name, scope, 'required')
          end

          def get_id_token_claims_included_conditions(provider_name, scope)
            dig_provider_config(provider_name, scope, 'included')
          end

          def dig_provider_config(provider_name, scope, claim_type)
            Gitlab::Auth::OAuth::Provider
              .config_for(provider_name.to_s)
              &.dig('step_up_auth', scope.to_s, 'id_token', claim_type)
          end

          def included_conditions_fulfilled?(oauth_extra_metadata:, provider:, scope:)
            conditions = get_id_token_claims_included_conditions(provider, scope)

            raw_info = (oauth_extra_metadata.presence || {}).with_indifferent_access
            conditions.to_h.all? do |claim_key, expected_included_value|
              raw_info_value = raw_info[claim_key]
              next false if raw_info_value.blank?

              Array.wrap(expected_included_value).any? do |v|
                case raw_info_value
                when String, Hash, Array
                  raw_info_value.include?(v)
                else
                  raw_info_value == v
                end
              end
            end
          end

          def required_conditions_fulfilled?(oauth_extra_metadata:, provider:, scope:)
            conditions = get_id_token_claims_required_conditions(provider, scope)

            raw_info = oauth_extra_metadata.presence || {}
            subset?(raw_info, conditions)
          end

          def subset?(hash, subset_hash)
            hash.with_indifferent_access >= subset_hash.with_indifferent_access
          end
        end
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/omniauth_identity_linker_base.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    class OmniauthIdentityLinkerBase
      attr_reader :current_user, :oauth, :session

      def initialize(current_user, oauth, session = {})
        @current_user = current_user
        @oauth = oauth
        @changed = false
        @session = session
      end

      def link
        save if unlinked?
      end

      def changed?
        @changed
      end

      def failed?
        error_message.present?
      end

      # Require user authorization to link identity.
      # False by default, enabled in specific subclasses.
      def authorization_required?
        false
      end

      def error_message
        identity.validate

        identity.errors.full_messages.join(', ')
      end

      def provider
        oauth['provider']
      end

      def uid
        oauth['uid']
      end

      private

      def save
        @changed = identity.save
      end

      def unlinked?
        identity.new_record?
      end

      # rubocop: disable CodeReuse/ActiveRecord
      def identity
        @identity ||= current_user.identities
                                  .with_extern_uid(provider, uid)
                                  .first_or_initialize(extern_uid: uid)
      end
      # rubocop: enable CodeReuse/ActiveRecord
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/otp/duo_auth.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    module Otp
      module DuoAuth
        def duo_auth_enabled?(_user)
          ::Gitlab.config.duo_auth.enabled
        end
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/otp/fortinet.rb ====
# frozen_string_literal: true
module Gitlab
  module Auth
    module Otp
      module Fortinet
        private

        def forti_authenticator_enabled?(user)
          ::Gitlab.config.forti_authenticator.enabled &&
            Feature.enabled?(:forti_authenticator, user)
        end

        def forti_token_cloud_enabled?(user)
          ::Gitlab.config.forti_token_cloud.enabled &&
            Feature.enabled?(:forti_token_cloud, user)
        end
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/otp/strategies/base.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    module Otp
      module Strategies
        class Base
          def initialize(user)
            @user = user
          end

          private

          attr_reader :user

          def success
            { status: :success }
          end

          def error(message, http_status = nil)
            result = { message: message,
                       status: :error }

            result[:http_status] = http_status if http_status

            result
          end

          def error_from_response(response)
            error(response.message, response.code)
          end
        end
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/otp/strategies/devise.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    module Otp
      module Strategies
        class Devise < Base
          def validate(otp_code)
            user.validate_and_consume_otp!(otp_code) ? success : error('invalid OTP code')
          end
        end
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/otp/strategies/duo_auth/manual_otp.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    module Otp
      module Strategies
        module DuoAuth
          class ManualOtp < Base
            include Gitlab::Utils::StrongMemoize

            def validate(otp_code)
              params = { username: user.username, factor: "passcode", passcode: otp_code.to_i }
              response = duo_client.request('POST', "/auth/v2/auth", params)
              approve_or_deny(parse_response(response))
            rescue StandardError => e
              Gitlab::AppLogger.error(e)
              error(e.message)
            end

            private

            def duo_client
              DuoApi.new(::Gitlab.config.duo_auth.integration_key,
                ::Gitlab.config.duo_auth.secret_key,
                ::Gitlab.config.duo_auth.hostname)
            end
            strong_memoize_attr :duo_client

            def parse_response(response)
              Gitlab::Json.parse(response.body)
            end

            def approve_or_deny(parsed_response)
              result_key = parsed_response.dig('response', 'result')
              if result_key.to_s == "allow"
                success
              else
                error(message: parsed_response.dig('response', 'status_msg').to_s)
              end
            end
          end
        end
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/otp/strategies/forti_authenticator/manual_otp.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    module Otp
      module Strategies
        module FortiAuthenticator
          class ManualOtp < Base
            def validate(otp_code)
              @otp_code = otp_code

              response = Gitlab::HTTP.post(
                auth_url,
                headers: { 'Content-Type': 'application/json' },
                body: body.to_json,
                basic_auth: api_credentials)

              # Successful authentication results in HTTP 200: OK
              # Manual OTP - https://docs.fortinet.com/document/fortiauthenticator/6.2.0/rest-api-solution-guide/704555/authentication-auth
              response.ok? ? success : error_from_response(response)
            rescue StandardError => ex
              Gitlab::AppLogger.error(ex)
              error(ex.message)
            end

            private

            def auth_url
              host = ::Gitlab.config.forti_authenticator.host
              port = ::Gitlab.config.forti_authenticator.port
              path = 'api/v1/auth/'

              "https://#{host}:#{port}/#{path}"
            end

            def body
              { username: user.username,
                token_code: @otp_code }
            end

            def api_credentials
              { username: ::Gitlab.config.forti_authenticator.username,
                password: ::Gitlab.config.forti_authenticator.access_token }
            end
          end
        end
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/otp/strategies/forti_authenticator/push_otp.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    module Otp
      module Strategies
        module FortiAuthenticator
          class PushOtp < Base
            def validate
              response = Gitlab::HTTP.post(
                auth_url,
                headers: { 'Content-Type': 'application/json' },
                body: body.to_json,
                basic_auth: api_credentials)

              # Successful authentication results in HTTP 200: OK
              # Push - https://docs.fortinet.com/document/fortiauthenticator/6.2.1/rest-api-solution-guide/943094/push-authentication-pushauth
              response.ok? ? success : error_from_response(response)
            rescue StandardError => ex
              Gitlab::AppLogger.error(ex)
              error(ex.message)
            end

            private

            def auth_url
              host = ::Gitlab.config.forti_authenticator.host
              port = ::Gitlab.config.forti_authenticator.port
              path = 'api/v1/pushauth/'

              "https://#{host}:#{port}/#{path}"
            end

            def body
              { username: user.username }
            end

            def api_credentials
              { username: ::Gitlab.config.forti_authenticator.username,
                password: ::Gitlab.config.forti_authenticator.access_token }
            end
          end
        end
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/otp/strategies/forti_token_cloud.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    module Otp
      module Strategies
        class FortiTokenCloud < Base
          include Gitlab::Utils::StrongMemoize

          BASE_API_URL = 'https://ftc.fortinet.com:9696/api/v1'

          def validate(otp_code)
            if access_token_create_response.created?
              otp_verification_response = verify_otp(otp_code)

              otp_verification_response.ok? ? success : error_from_response(otp_verification_response)
            else
              error_from_response(access_token_create_response)
            end
          end

          private

          # TODO: Cache the access token: https://gitlab.com/gitlab-org/gitlab/-/issues/292437
          def access_token_create_response
            # Returns '201 CREATED' on successful creation of a new access token.
            strong_memoize(:access_token_create_response) do
              post(
                url: url('/login'),
                body: {
                  client_id: ::Gitlab.config.forti_token_cloud.client_id,
                  client_secret: ::Gitlab.config.forti_token_cloud.client_secret
                }.to_json
              )
            end
          end

          def access_token
            Gitlab::Json.parse(access_token_create_response.body)['access_token']
          end

          def verify_otp(otp_code)
            # Returns '200 OK' on successful verification.
            # Uses the access token created via `access_token_create_response` as the auth token.
            post(
              url: url('/auth'),
              headers: { Authorization: "Bearer #{access_token}" },
              body: {
                username: user.username,
                token: otp_code
              }.to_json
            )
          end

          def url(path)
            BASE_API_URL + path
          end

          def post(url:, body:, headers: {})
            Gitlab::HTTP.post(
              url,
              headers: {
                'Content-Type': 'application/json'
              }.merge(headers),
              body: body
            )
          end
        end
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/request_authenticator.rb ====
# frozen_string_literal: true

# Use for authentication only, in particular for Rack::Attack.
# Does not perform authorization of scopes, etc.
module Gitlab
  module Auth
    class RequestAuthenticator
      include AuthFinders

      attr_reader :request

      def initialize(request)
        @request = request
      end

      def find_authenticated_requester(request_formats)
        deploy_token_from_request || user(request_formats)
      end

      def user(request_formats)
        request_formats.each do |format|
          user = find_sessionless_user(format)

          return user if user
        end

        find_user_from_warden
      end

      def runner
        find_runner_from_token
      rescue Gitlab::Auth::AuthenticationError
        nil
      end

      def find_sessionless_user(request_format)
        case request_format
        when :graphql_api
          find_user_for_graphql_api_request
        when :api, :git, :rss, :ics, :blob, :download, :archive, nil
          find_user_from_any_authentication_method(request_format)
        else
          raise ArgumentError, "Unknown request format"
        end
      rescue Gitlab::Auth::AuthenticationError
        nil
      end

      def can_sign_in_bot?(user)
        # Allow bots and service accounts to access both API and archive endpoints
        (user&.project_bot? || user&.service_account?) && (api_request? || archive_request?)
      end

      def valid_access_token?(scopes: [])
        # We may just be checking whether the user has :admin_mode access, so
        # don't construe an auth failure as a real failure.
        validate_and_save_access_token!(scopes: scopes, save_auth_context: false)

        true
      rescue Gitlab::Auth::AuthenticationError
        false
      end

      private

      # Use a minimal subset of find_user_from_any_authentication_method
      # so only token types allowed for GraphQL can authenticate users.
      # CI_JOB_TOKENs are not allowed for now, since their access is too broad.
      #
      # Overridden in EE
      def find_user_for_graphql_api_request
        find_user_from_web_access_token(:api, scopes: graphql_authorization_scopes) ||
          find_user_from_personal_access_token_for_api_or_git
      end

      # Overridden in EE
      def graphql_authorization_scopes
        [:api, :read_api]
      end

      def find_user_from_any_authentication_method(request_format)
        find_user_from_dependency_proxy_token ||
          find_user_from_web_access_token(request_format, scopes: [:api, :read_api]) ||
          find_user_from_feed_token(request_format) ||
          find_user_from_static_object_token(request_format) ||
          find_user_from_job_token ||
          find_user_from_personal_access_token_for_api_or_git ||
          find_user_for_git_or_lfs_request
      end

      def access_token
        strong_memoize(:access_token) do
          super || find_personal_access_token_from_http_basic_auth
        end
      end

      def route_authentication_setting
        @route_authentication_setting ||= {
          job_token_allowed: api_request?,
          basic_auth_personal_access_token: api_request? || git_request?,
          deploy_token_allowed: api_request? || git_request?
        }
      end
    end
  end
end

Gitlab::Auth::RequestAuthenticator.prepend_mod
==== /workspace/gitlab/lib/gitlab/auth/result.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    class Result
      attr_reader :actor, :project, :type, :authentication_abilities, :authentication_context

      def initialize(actor, project, type, authentication_abilities, authentication_context = {})
        @actor = actor
        @project = project
        @type = type
        @authentication_abilities = authentication_abilities
        @authentication_context = authentication_context
      end

      EMPTY = self.new(nil, nil, nil, nil).freeze

      def ci?(for_project)
        type == :ci &&
          project &&
          project == for_project
      end

      def lfs_deploy_token?(for_project)
        type == :lfs_deploy_token &&
          actor.try(:has_access_to?, for_project)
      end

      def success?
        actor.present? || type == :ci
      end

      def failed?
        !success?
      end

      def auth_user
        actor.is_a?(User) ? actor : nil
      end
      alias_method :user, :auth_user

      def deploy_token
        actor.is_a?(DeployToken) ? actor : nil
      end

      def can?(action)
        actor&.can?(action)
      end

      def can_perform_action_on_project?(action, given_project)
        Ability.allowed?(actor, action, given_project)
      end

      def authentication_abilities_include?(ability)
        return false if authentication_abilities.blank?

        authentication_abilities.include?(ability)
      end
    end
  end
end

Gitlab::Auth::Result.prepend_mod_with('Gitlab::Auth::Result')
==== /workspace/gitlab/lib/gitlab/auth/saml/auth_hash.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    module Saml
      class AuthHash < Gitlab::Auth::OAuth::AuthHash
        def groups
          Array.wrap(get_raw(Gitlab::Auth::Saml::Config.new(auth_hash.provider).groups))
        end

        def azure_group_overage_claim?
          get_raw('http://schemas.microsoft.com/claims/groups.link').present?
        end

        def authn_context
          response_object = auth_hash.extra[:response_object]
          return unless response_object.is_a?(OneLogin::RubySaml::Response)

          response_object.authn_context_class_ref
        end

        private

        def get_raw(key)
          # Needs to call `all` because of https://git.io/vVo4u
          # otherwise just the first value is returned
          auth_hash.extra[:raw_info].all[key]
        end
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/saml/config.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    module Saml
      class Config
        DEFAULT_NICKNAME_ATTRS = %w[username nickname].freeze
        DEFAULT_NAME_ATTRS = %w[
          http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name
          http://schemas.microsoft.com/ws/2008/06/identity/claims/name
        ].freeze
        DEFAULT_EMAIL_ATTRS = %w[
          http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress
          http://schemas.microsoft.com/ws/2008/06/identity/claims/emailaddress
        ].freeze
        DEFAULT_FIRST_NAME_ATTRS = %w[
          http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname
          http://schemas.microsoft.com/ws/2008/06/identity/claims/givenname
        ].freeze
        DEFAULT_LAST_NAME_ATTRS = %w[
          http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname
          http://schemas.microsoft.com/ws/2008/06/identity/claims/surname
        ].freeze

        class << self
          def enabled?
            ::AuthHelper.saml_providers.any?
          end

          def default_attribute_statements
            defaults = OmniAuth::Strategies::SAML.default_options[:attribute_statements].to_hash.deep_symbolize_keys
            defaults[:nickname] = DEFAULT_NICKNAME_ATTRS.dup
            defaults[:name].concat(DEFAULT_NAME_ATTRS)
            defaults[:email].concat(DEFAULT_EMAIL_ATTRS)
            defaults[:first_name].concat(DEFAULT_FIRST_NAME_ATTRS)
            defaults[:last_name].concat(DEFAULT_LAST_NAME_ATTRS)

            defaults
          end
        end

        DEFAULT_PROVIDER_NAME = 'saml'

        def initialize(provider = DEFAULT_PROVIDER_NAME)
          @provider = provider
        end

        def options
          Gitlab::Auth::OAuth::Provider.config_for(@provider)
        end

        def upstream_two_factor_authn_contexts
          options.args[:upstream_two_factor_authn_contexts]
        end

        def groups
          options[:groups_attribute]
        end

        def external_groups
          options[:external_groups]
        end

        def admin_groups
          options[:admin_groups]
        end
      end
    end
  end
end

Gitlab::Auth::Saml::Config.prepend_mod_with('Gitlab::Auth::Saml::Config')
==== /workspace/gitlab/lib/gitlab/auth/saml/identity_linker.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    module Saml
      class IdentityLinker < OmniauthIdentityLinkerBase
        extend ::Gitlab::Utils::Override

        UnverifiedRequest = Class.new(StandardError)

        override :link
        def link
          raise_unless_request_is_gitlab_initiated! if unlinked?

          super
        end

        protected

        def raise_unless_request_is_gitlab_initiated!
          raise UnverifiedRequest unless valid_gitlab_initiated_request?
        end

        def valid_gitlab_initiated_request?
          OriginValidator.new(session).gitlab_initiated?(saml_response)
        end

        def saml_response
          oauth.fetch(:extra, {}).fetch(:response_object, {})
        end
      end
    end
  end
end

Gitlab::Auth::Saml::IdentityLinker.prepend_mod
==== /workspace/gitlab/lib/gitlab/auth/saml/origin_validator.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    module Saml
      class OriginValidator
        AUTH_REQUEST_SESSION_KEY = "last_authn_request_id"

        def initialize(session)
          @session = session || {}
        end

        def store_origin(authn_request)
          session[AUTH_REQUEST_SESSION_KEY] = authn_request.uuid
        end

        def gitlab_initiated?(saml_response)
          return false if identity_provider_initiated?(saml_response)

          matches?(saml_response)
        end

        private

        attr_reader :session

        def matches?(saml_response)
          saml_response.in_response_to == expected_request_id
        end

        def identity_provider_initiated?(saml_response)
          saml_response.in_response_to.blank?
        end

        def expected_request_id
          session[AUTH_REQUEST_SESSION_KEY]
        end
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/saml/user.rb ====
# frozen_string_literal: true

# SAML extension for User model
#
# * Find GitLab user based on SAML uid and provider
# * Create new user from SAML data
#
module Gitlab
  module Auth
    module Saml
      class User < Gitlab::Auth::OAuth::User
        extend ::Gitlab::Utils::Override

        def find_user
          user = find_by_uid_and_provider

          user ||= find_by_email if auto_link_saml_user?
          user ||= find_or_build_ldap_user if auto_link_ldap_user?
          user ||= build_new_user if signup_enabled?

          user&.external = external_user? if any_external_config_present?

          user
        end

        override :should_save?
        def should_save?
          return true unless gl_user

          gl_user.changed? || gl_user.identities.any?(&:changed?)
        end

        def bypass_two_factor?
          saml_config.upstream_two_factor_authn_contexts&.include?(auth_hash.authn_context)
        end

        def protocol_name
          'SAML'
        end

        protected

        def saml_config
          Gitlab::Auth::Saml::Config.new(auth_hash.provider)
        end

        def auto_link_saml_user?
          Gitlab.config.omniauth.auto_link_saml_user
        end

        def external_users_enabled?
          !saml_config.external_groups.nil?
        end

        def any_external_config_present?
          external_provider? || external_users_enabled?
        end

        def auth_hash=(auth_hash)
          @auth_hash = Gitlab::Auth::Saml::AuthHash.new(auth_hash)
        end

        private

        def external_user?
          return true if external_provider?
          return intersecting_external_groups? if external_users_enabled?

          false
        end

        def intersecting_external_groups?
          !(auth_hash.groups & saml_config.external_groups).empty?
        end
      end
    end
  end
end

Gitlab::Auth::Saml::User.prepend_mod_with('Gitlab::Auth::Saml::User')
==== /workspace/gitlab/lib/gitlab/auth/scope_validator.rb ====
# frozen_string_literal: true

# Wrapper around a RequestAuthenticator to
# perform authorization of scopes. Access is limited to
# only those methods needed to validate that an API user
# has at least one permitted scope.
module Gitlab
  module Auth
    class ScopeValidator
      def initialize(api_user, request_authenticator)
        @api_user = api_user
        @request_authenticator = request_authenticator
      end

      def valid_for?(permitted)
        return true unless @api_user
        return true if permitted.none?

        scopes = permitted.map { |s| API::Scope.new(s) }
        @request_authenticator.valid_access_token?(scopes: scopes)
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/session_expire_from_init_enforcer.rb ====
# frozen_string_literal: true

# code inspired by Devise Timeoutable
# https://github.com/heartcombo/devise/blob/fec67f98f26fcd9a79072e4581b1bd40d0c7fa1d/lib/devise/hooks/timeoutable.rb#L8
module Gitlab
  module Auth
    class SessionExpireFromInitEnforcer
      SESSION_NAMESPACE = :sefie

      attr_reader :warden, :opts

      def self.session_expires_at(controller_session = Session.current)
        warden_session = controller_session['warden.user.user.session']
        session = Gitlab::NamespacedSessionStore.new(SESSION_NAMESPACE, warden_session)
        signed_in_at = session['signed_in_at']
        return 0 unless signed_in_at.present?

        signed_in_at + timeout_value
      end

      def self.enabled?
        Gitlab::CurrentSettings.session_expire_from_init
      end

      def self.timeout_value
        Gitlab::CurrentSettings.session_expire_delay * 60
      end

      def initialize(warden, opts)
        @warden = warden
        @opts = opts
      end

      def enabled?
        self.class.enabled?
      end

      def set_login_time
        return unless enabled?

        set_signed_in_at
      end

      def enforce!
        return unless enabled?

        signed_in_at = session['signed_in_at']

        # immediately after the setting is enabled, users may not have this value set
        # we set it here so users don't have to log out and log back in to set the expiry
        unless signed_in_at.present?
          set_signed_in_at
          return
        end

        time_since_sign_in = Time.current.utc.to_i - signed_in_at

        return unless time_since_sign_in > timeout_value

        ::Devise.sign_out_all_scopes ? proxy.sign_out : proxy.sign_out(scope)
        throw :warden, scope: scope, message: :timeout # rubocop:disable Cop/BanCatchThrow -- this is called from a Warden hook, which depends on throw :warden to halt and redirect
      end

      private

      def set_signed_in_at
        session['signed_in_at'] = Time.current.utc.to_i
      end

      def timeout_value
        self.class.timeout_value
      end

      def proxy
        @proxy ||= ::Devise::Hooks::Proxy.new(warden)
      end

      def scope
        opts[:scope]
      end

      def session
        return @session if @session

        session = warden.session(scope)
        @session = Gitlab::NamespacedSessionStore.new(SESSION_NAMESPACE, session)
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/too_many_ips.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    class TooManyIps < StandardError
      attr_reader :user_id, :ip, :unique_ips_count

      def initialize(user_id, ip, unique_ips_count)
        @user_id = user_id
        @ip = ip
        @unique_ips_count = unique_ips_count
      end

      def message
        "User #{user_id} from IP: #{ip} tried logging from too many ips: #{unique_ips_count}"
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/two_factor_auth_verifier.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    class TwoFactorAuthVerifier
      attr_reader :current_user, :request

      def initialize(current_user, request = nil)
        @current_user = current_user
        @request = request
      end

      def two_factor_authentication_enforced?
        two_factor_authentication_required? && two_factor_grace_period_expired?
      end

      # -- Admin mode does not matter in the context of verifying for two factor statuses
      def two_factor_authentication_required?
        return false if allow_2fa_bypass_for_provider

        Gitlab::CurrentSettings.require_two_factor_authentication? ||
          current_user&.require_two_factor_authentication_from_group? ||
          (Gitlab::CurrentSettings.require_admin_two_factor_authentication && current_user&.can_access_admin_area?)
      end

      def two_factor_authentication_reason
        if Gitlab::CurrentSettings.require_two_factor_authentication?
          :global
        elsif Gitlab::CurrentSettings.require_admin_two_factor_authentication && current_user&.can_access_admin_area?
          :admin_2fa
        elsif current_user&.require_two_factor_authentication_from_group?
          :group
        else
          false
        end
      end

      def current_user_needs_to_setup_two_factor?
        current_user && !current_user.temp_oauth_email? && !current_user.two_factor_enabled?
      end

      def two_factor_grace_period
        periods = [Gitlab::CurrentSettings.two_factor_grace_period]
        periods << current_user.two_factor_grace_period if current_user&.require_two_factor_authentication_from_group?
        periods.min
      end

      def two_factor_grace_period_expired?
        time = current_user&.otp_grace_period_started_at

        return false unless time

        two_factor_grace_period.hours.since(time).past?
      end

      def allow_2fa_bypass_for_provider
        request.session[:provider_2FA].present? if request
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/unique_ips_limiter.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    class UniqueIpsLimiter
      USER_UNIQUE_IPS_PREFIX = 'user_unique_ips'

      class << self
        def limit_user_id!(user_id)
          if config.unique_ips_limit_enabled
            ip = RequestContext.instance.client_ip
            unique_ips = update_and_return_ips_count(user_id, ip)

            if unique_ips > config.unique_ips_limit_per_user
              Gitlab::AuthLogger.error(
                message: 'too_many_ips',
                remote_ip: ip,
                unique_ips_count: unique_ips,
                user_id: user_id,
                **Gitlab::ApplicationContext.current
              )

              raise TooManyIps.new(user_id, ip, unique_ips)
            end
          end
        end

        def limit_user!(user = nil)
          user ||= yield if block_given?
          limit_user_id!(user.id) unless user.nil?
          user
        end

        def config
          Gitlab::CurrentSettings.current_application_settings
        end

        def update_and_return_ips_count(user_id, ip)
          time = Time.now.utc.to_i
          key = "#{USER_UNIQUE_IPS_PREFIX}:#{user_id}"

          Gitlab::Redis::SharedState.with do |redis|
            redis.multi do |r|
              r.zadd(key, time, ip.to_s)
              r.zremrangebyscore(key, 0, time - config.unique_ips_limit_time_window)
              r.zcard(key)
            end.last
          end
        end
      end
    end
  end
end
==== /workspace/gitlab/lib/gitlab/auth/user_access_denied_reason.rb ====
# frozen_string_literal: true

module Gitlab
  module Auth
    class UserAccessDeniedReason
      def initialize(user)
        @user = user
      end

      def rejection_message
        case rejection_type
        when :internal
          "This action cannot be performed by internal users"
        when :blocked_pending_approval
          "Your account is pending approval from your administrator and hence blocked."
        when :terms_not_accepted
          "You (#{@user.to_reference}) must accept the Terms of Service in order to perform this action. "\
          "To accept these terms, please access GitLab from a web browser at #{Gitlab.config.gitlab.url}."
        when :deactivated
          "Your account has been deactivated by your administrator. "\
          "Please log back in from a web browser to reactivate your account at #{Gitlab.config.gitlab.url}"
        when :unconfirmed
          "Your primary email address is not confirmed. "\
          "Please check your inbox for the confirmation instructions. "\
          "In case the link is expired, you can request a new confirmation email at #{Rails.application.routes.url_helpers.new_user_confirmation_url}"
        when :blocked
          "Your account has been blocked."
        when :password_expired
          "Your password expired. "\
          "Please access GitLab from a web browser to update your password."
        else
          "Your request has been rejected for an unknown reason."\
          "Please contact your GitLab administrator and/or GitLab Support."
        end
      end

      private

      def rejection_type
        if @user.internal?
          :internal
        elsif @user.blocked_pending_approval?
          :blocked_pending_approval
        elsif @user.required_terms_not_accepted?
          :terms_not_accepted
        elsif @user.deactivated?
          :deactivated
        elsif !@user.confirmed?
          :unconfirmed
        elsif @user.blocked?
          :blocked
        elsif @user.password_expired?
          :password_expired
        else
          :blocked
        end
      end
    end
  end
end

Gitlab::Auth::UserAccessDeniedReason.prepend_mod
==== /workspace/gitlab/lib/gitlab/auth/visitor_location.rb ====
# frozen_string_literal: true

# Takes in an incoming request and extracts contextual information such as location.
#
# Information about country and city of the request is taken from its headers set by Cloudflare WAF.
# See: https://developers.cloudflare.com/rules/transform/managed-transforms/reference/#add-visitor-location-headers
#
module Gitlab
  module Auth
    class VisitorLocation
      attr_reader :request

      HEADERS = {
        country: 'Cf-Ipcountry',
        city: 'Cf-Ipcity'
      }.freeze

      # @param [ActionDispatch::Request] request
      def initialize(request)
        @request = request
      end

      def country
        code = request.headers[HEADERS[:country]] # 2-letter country code, e.g. "JP" for Japan
        # If country name is not known for local language, default to English. Or just display country code
        I18nData.countries(I18n.locale)[code] || code
      rescue I18nData::NoTranslationAvailable
        I18nData.countries[code] || code
      end

      def city
        request.headers[HEADERS[:city]]
      end
    end
  end
end
