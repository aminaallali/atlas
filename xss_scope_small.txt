==== app/assets/javascripts/alert.js ====
import Vue from 'vue';
import isEmpty from 'lodash/isEmpty';
import { GlAlert, GlLink, GlSprintf } from '@gitlab/ui';
import * as Sentry from '~/sentry/sentry_browser_wrapper';
import { __ } from '~/locale';
import { sanitize } from '~/lib/dompurify';

export const VARIANT_SUCCESS = 'success';
export const VARIANT_WARNING = 'warning';
export const VARIANT_DANGER = 'danger';
export const VARIANT_INFO = 'info';
export const VARIANT_TIP = 'tip';

/**
 * Render an alert at the top of the page, or, optionally an
 * arbitrary existing container. This alert is always dismissible.
 *
 * @example
 * // Render a new alert
 * import { createAlert, VARIANT_WARNING } from '~/alert';
 *
 * createAlert({ message: 'My error message' });
 * createAlert({ message: 'My warning message', variant: VARIANT_WARNING });
 *
 * @example
 * // Dismiss this alert programmatically
 * const alert = createAlert({ message: 'Message' });
 *
 * // ...
 *
 * alert.dismiss();
 *
 * @example
 * // Respond to the alert being dismissed
 * createAlert({ message: 'Message', onDismiss: () => {} });
 *
 * @example
 * // Add inline link in the message
 * createAlert({ message: 'Read more at %{exampleLinkStart}example page%{exampleLinkEnd}.', messageLinks: { exampleLink: 'https://example.com' } });
 *
 * @example
 * // Add inline links in the message with custom GlLink props
 * createAlert({ message: 'Read more at %{exampleLinkStart}example page%{exampleLinkEnd}.', messageLinks: { exampleLink: { href: 'https://example.com', target: '_blank', isUnsafeLink: true }} });
 *
 * @param {object} options - Options to control the flash message
 * @param {string} options.message - Alert message text
 * @param {string} [options.title] - Alert title
 * @param {VARIANT_SUCCESS|VARIANT_WARNING|VARIANT_DANGER|VARIANT_INFO|VARIANT_TIP} [options.variant] - Which GlAlert variant to use; it defaults to VARIANT_DANGER.
 * @param {object} [options.parent] - Reference to parent element under which alert needs to appear. Defaults to `document`.
 * @param {boolean} [options.dismissible] - Set to `false` to make an alert non-dismissible. Defaults to `true`.
 * @param {Function} [options.onDismiss] - Handler to call when this alert is dismissed.
 * @param {string} [options.containerSelector] - Selector for the container of the alert
 * @param {boolean} [options.preservePrevious] - Set to `true` to preserve previous alerts. Defaults to `false`.
 * @param {object} [options.primaryButton] - Object describing primary button of alert
 * @param {string} [options.primaryButton.link] - Href of primary button
 * @param {string} [options.primaryButton.text] - Text of primary button
 * @param {Function} [options.primaryButton.clickHandler] - Handler to call when primary button is clicked on. The click event is sent as an argument.
 * @param {object} [options.secondaryButton] - Object describing secondary button of alert
 * @param {string} [options.secondaryButton.link] - Href of secondary button
 * @param {string} [options.secondaryButton.text] - Text of secondary button
 * @param {Function} [options.secondaryButton.clickHandler] - Handler to call when secondary button is clicked on. The click event is sent as an argument.
 * @param {object} [options.messageLinks] - Object containing mapping of sprintf tokens to URLs, used to format links within the message. If needed, you can pass a full props object for GlLink instead of a URL string
 * @param {boolean} [options.captureError] - Whether to send error to Sentry
 * @param {object} [options.error] - Error to be captured in Sentry
 */
export const createAlert = ({
  message,
  title,
  variant = VARIANT_DANGER,
  parent = document,
  containerSelector = '.flash-container',
  preservePrevious = false,
  primaryButton = null,
  secondaryButton = null,
  onDismiss = null,
  captureError = false,
  error = null,
  messageLinks = null,
  dismissible = true,
  renderMessageHTML = false,
}) => {
  if (captureError && error) Sentry.captureException(error);

  const alertContainer = parent.querySelector(containerSelector);
  if (!alertContainer) return null;

  const el = document.createElement('div');
  if (preservePrevious) {
    alertContainer.appendChild(el);
  } else {
    alertContainer.replaceChildren(el);
  }

  const createMessageNodes = (h) => {
    if (renderMessageHTML) {
      return [
        h('div', {
          domProps: {
            innerHTML: sanitize(message, {
              ALLOWED_TAGS: ['a'],
              ALLOWED_ATTR: ['href', 'rel', 'target'],
            }),
          },
        }),
      ];
    }

    if (isEmpty(messageLinks)) {
      return message;
    }

    const normalizeLinkProps = (hrefOrProps) => {
      const { href, ...otherLinkProps } =
        typeof hrefOrProps === 'string' ? { href: hrefOrProps } : hrefOrProps;

      return { href, linkProps: otherLinkProps };
    };

    return [
      h(GlSprintf, {
==== app/assets/javascripts/authentication/webauthn/flow.js ====
import { template } from 'lodash';

/**
 * Generic abstraction for WebAuthnFlows, especially for register / authenticate
 */
export default class WebAuthnFlow {
  constructor(container, templates) {
    this.container = container;
    this.templates = templates;
  }

  renderTemplate(name, params) {
    const templateString = document.querySelector(this.templates[name]).innerHTML;
    const compiledTemplate = template(templateString);
    this.container.html(compiledTemplate(params));
  }

  renderError(error) {
    this.renderTemplate('error', {
      error_message: error.message(),
      error_name: error.errorName,
    });
  }
}
==== app/assets/javascripts/batch_comments/components/preview_item.vue ====
<script>
import { GlBadge, GlSprintf, GlIcon, GlButton } from '@gitlab/ui';
import { mapState } from 'pinia';
import { IMAGE_DIFF_POSITION_TYPE } from '~/diffs/constants';
import { sprintf, __ } from '~/locale';
import {
  getStartLineNumber,
  getEndLineNumber,
  getLineClasses,
} from '~/notes/components/multiline_comment_utils';
import { useLegacyDiffs } from '~/diffs/stores/legacy_diffs';
import { useNotes } from '~/notes/store/legacy_notes';
import resolvedStatusMixin from '../mixins/resolved_status';

export default {
  components: {
    GlBadge,
    GlIcon,
    GlSprintf,
    GlButton,
  },
  mixins: [resolvedStatusMixin],
  props: {
    draft: {
      type: Object,
      required: true,
    },
  },
  computed: {
    ...mapState(useLegacyDiffs, ['getDiffFileByHash']),
    ...mapState(useNotes, ['getDiscussion']),
    iconName() {
      return this.isDiffDiscussion || this.draft.line_code ? 'doc-text' : 'comment';
    },
    discussion() {
      return this.getDiscussion(this.draft.discussion_id);
    },
    isDiffDiscussion() {
      return this.discussion && this.discussion.diff_discussion;
    },
    titleText() {
      const file = this.discussion ? this.discussion.diff_file : this.draft;

      if (file?.file_path) {
        return file.file_path;
      }

      if (this.discussion) {
        return sprintf(
          __("%{authorsName}'s thread"),
          {
            authorsName: this.discussion.notes.find((note) => !note.system).author.name,
          },
          false,
        );
      }

      return __('Your new comment');
    },
    linePosition() {
      if (this.position?.position_type === IMAGE_DIFF_POSITION_TYPE) {
        // eslint-disable-next-line @gitlab/require-i18n-strings
        return `${this.position.x}x ${this.position.y}y`;
      }

      return this.position?.new_line || this.position?.old_line;
    },
    content() {
      const el = document.createElement('div');
      // eslint-disable-next-line no-unsanitized/property
      el.innerHTML = this.draft.note_html;

      return el.textContent;
    },
    showLinePosition() {
      return this.draft.file_hash || this.isDiffDiscussion;
    },
    position() {
      return this.draft.position || this.discussion.position;
    },
    startLineNumber() {
      if (this.position?.position_type === IMAGE_DIFF_POSITION_TYPE) {
        // eslint-disable-next-line @gitlab/require-i18n-strings
        return `${this.position.x}x ${this.position.y}y`;
      }
      return getStartLineNumber(this.position?.line_range);
    },
    endLineNumber() {
      return getEndLineNumber(this.position?.line_range);
    },
  },
  methods: {
    getLineClasses(lineNumber) {
      return getLineClasses(lineNumber);
    },
  },
  showStaysResolved: false,
};
</script>

<template>
  <div class="pending-review-item gl-relative gl-mb-4 gl-flex gl-gap-3">
    <div
      class="review-comment-icon gl-inline-flex gl-items-center gl-justify-center gl-self-baseline gl-rounded-full gl-bg-strong"
    >
      <gl-icon class="flex-shrink-0" :name="iconName" :size="14" />
    </div>

    <div class="gl-mt-2 gl-flex gl-flex-col gl-gap-2">
      <gl-button
        variant="link"
        class="!gl-justify-start"
        data-testid="preview-item-header"
        @click="$emit('click', draft)"
      >
        <span class="gl-truncate gl-font-semibold" data-testid="review-preview-item-header-text">{{
          titleText
        }}</span>
        <template v-if="showLinePosition">
          <template v-if="startLineNumber === endLineNumber">
==== app/assets/javascripts/behaviors/copy_code.js ====
import { uniqueId } from 'lodash';
import { __ } from '~/locale';
import { spriteIcon } from '~/lib/utils/common_utils';
import { setAttributes } from '~/lib/utils/dom_utils';

class CopyCodeButton extends HTMLElement {
  connectedCallback() {
    if (this.querySelector('.btn')) return;

    this.for = uniqueId('code-');

    const target = this.parentNode.querySelector('pre');
    if (!target || this.closest('.suggestions')) return;

    target.setAttribute('id', this.for);

    this.appendChild(this.createButton());
  }

  createButton() {
    const button = document.createElement('button');

    setAttributes(button, {
      type: 'button',
      class: 'btn btn-default btn-md gl-button btn-icon has-tooltip',
      'data-title': __('Copy to clipboard'),
      'aria-label': __('Copy to clipboard'),
      'data-clipboard-target': `pre#${this.for}`,
    });

    // eslint-disable-next-line no-unsanitized/property
    button.innerHTML = spriteIcon('copy-to-clipboard');

    return button;
  }
}

function addCodeButton() {
  [...document.querySelectorAll('pre.code.js-syntax-highlight:not(.content-editor-code-block)')]
    .filter((el) => el.getAttribute('lang') !== 'mermaid')
    .filter((el) => !el.closest('.js-markdown-code'))
    .forEach((el) => {
      const copyCodeEl = document.createElement('copy-code');
      copyCodeEl.setAttribute('for', uniqueId('code-'));

      const wrapper = document.createElement('div');
      wrapper.className = 'gl-relative markdown-code-block js-markdown-code';
      wrapper.appendChild(el.cloneNode(true));
      wrapper.appendChild(copyCodeEl);

      el.parentNode.insertBefore(wrapper, el);

      el.remove();
    });
}

export const initCopyCodeButton = (selector = '#content-body') => {
  if (!customElements.get('copy-code')) {
    customElements.define('copy-code', CopyCodeButton);
  }

  const exclude = document.querySelector('.file-content.code'); // this behavior is not needed when viewing raw file content, so excluding it as the unnecessary dom lookups can become expensive
  const el = document.querySelector(selector);

  if (!el || exclude) return () => {};

  const observer = new MutationObserver(() => addCodeButton());

  observer.observe(document.querySelector(selector), {
    childList: true,
    subtree: true,
  });

  return () => observer.disconnect();
};
==== app/assets/javascripts/behaviors/gl_emoji.js ====
import {
  initEmojiMap,
  getEmojiInfo,
  emojiFallbackImageSrc,
  emojiImageTag,
  findCustomEmoji,
} from '../emoji';
import isEmojiUnicodeSupported from '../emoji/support';

class GlEmoji extends HTMLElement {
  connectedCallback() {
    this.initialize();
  }
  initialize() {
    let emojiUnicode = this.textContent.trim();
    const { fallbackSpriteClass, fallbackSrc } = this.dataset;
    let { name, unicodeVersion } = this.dataset;

    return initEmojiMap().then(() => {
      if (!unicodeVersion) {
        const emojiInfo = getEmojiInfo(name);

        if (emojiInfo) {
          if (name !== emojiInfo.name) {
            ({ name } = emojiInfo);
            this.dataset.name = emojiInfo.name;
          }
          unicodeVersion = emojiInfo.u;
          this.dataset.unicodeVersion = unicodeVersion;

          emojiUnicode = emojiInfo.e;
          this.textContent = emojiInfo.e;

          this.title = emojiInfo.d;
        }
      }

      const isEmojiUnicode =
        this.childNodes &&
        Array.prototype.every.call(this.childNodes, (childNode) => childNode.nodeType === 3);

      const customEmoji = findCustomEmoji(name);
      const hasImageFallback = fallbackSrc?.length > 0;
      const hasCssSpriteFallback = fallbackSpriteClass?.length > 0;

      if (emojiUnicode && isEmojiUnicode && isEmojiUnicodeSupported(emojiUnicode, unicodeVersion)) {
        // noop
      } else if (hasCssSpriteFallback) {
        if (!gon.emoji_sprites_css_added && gon.emoji_sprites_css_path) {
          const emojiSpriteLinkTag = document.createElement('link');
          emojiSpriteLinkTag.setAttribute('rel', 'stylesheet');
          emojiSpriteLinkTag.setAttribute('href', gon.emoji_sprites_css_path);
          document.head.appendChild(emojiSpriteLinkTag);
          gon.emoji_sprites_css_added = true;
        }
        // IE 11 doesn't like adding multiple at once :(
        this.classList.add('emoji-icon');
        this.classList.add(fallbackSpriteClass);
      } else if (hasImageFallback) {
        this.innerHTML = '';
        this.appendChild(emojiImageTag(name, customEmoji?.src || fallbackSrc));
      } else {
        const src = emojiFallbackImageSrc(name);
        this.innerHTML = '';
        this.appendChild(emojiImageTag(name, src));
      }
    });
  }
}

export default function installGlEmojiElement() {
  if (!customElements.get('gl-emoji')) {
    customElements.define('gl-emoji', GlEmoji);
  }
}
==== app/assets/javascripts/behaviors/markdown/copy_as_gfm.js ====
import $ from 'jquery';
import { sanitize } from '~/lib/dompurify';
import { getSelectedFragment, insertText } from '~/lib/utils/common_utils';

export class CopyAsGFM {
  constructor() {
    // iOS currently does not support clipboardData.setData(). This bug should
    // be fixed in iOS 12, but for now we'll disable this for all iOS browsers
    // ref: https://trac.webkit.org/changeset/222228/webkit
    const userAgent = (typeof navigator !== 'undefined' && navigator.userAgent) || '';
    const isIOS = /\b(iPad|iPhone|iPod)(?=;)/.test(userAgent);
    if (isIOS) return;

    $(document).on('copy', '.md, .duo-chat-message', (e) => {
      CopyAsGFM.copyAsGFM(e, CopyAsGFM.transformGFMSelection);
    });
    $(document).on('copy', 'pre.code.highlight, table.code td.line_content', (e) => {
      CopyAsGFM.copyAsGFM(e, CopyAsGFM.transformCodeSelection);
    });
    $(document).on('paste', '.js-gfm-input', CopyAsGFM.pasteGFM);
  }

  static copyAsGFM(e, transformer) {
    const { clipboardData } = e.originalEvent;
    if (!clipboardData) return;

    const documentFragment = getSelectedFragment();
    if (!documentFragment) return;

    const el = transformer(documentFragment.cloneNode(true), e.currentTarget);
    if (!el) return;

    e.preventDefault();
    e.stopPropagation();

    const div = document.createElement('div');
    div.appendChild(el.cloneNode(true));
    const html = div.innerHTML;

    clipboardData.setData('text/plain', el.textContent);
    clipboardData.setData('text/html', html);
    // We are also setting this as fallback to transform the selection to gfm on paste
    clipboardData.setData('text/x-gfm-html', html);

    CopyAsGFM.nodeToGFM(el)
      .then((res) => {
        clipboardData.setData('text/x-gfm', res);
      })
      .catch(() => {
        // Not showing the error as Firefox might doesn't allow
        // it or other browsers who have a time limit on the execution
        // of the copy event
      });
  }

  static pasteGFM(e) {
    const { clipboardData } = e.originalEvent;
    if (!clipboardData) return;

    const text = clipboardData.getData('text/plain');
    const gfm = clipboardData.getData('text/x-gfm');
    const gfmHtml = clipboardData.getData('text/x-gfm-html');
    if (!gfm && !gfmHtml) return;

    e.preventDefault();
    // See: https://gitlab.com/gitlab-org/gitlab/-/merge_requests/178942#note_2325656736
    e.stopImmediatePropagation();

    // We have the original selection already converted to gfm
    if (gfm) {
      CopyAsGFM.insertPastedText(e.target, text, gfm);
    } else {
      // Due to the async copy call we are not able to produce gfm so we transform the cached HTML
      const div = document.createElement('div');
      div.innerHTML = sanitize(gfmHtml);
      CopyAsGFM.nodeToGFM(div)
        .then((transformedGfm) => {
          CopyAsGFM.insertPastedText(e.target, text, transformedGfm);
        })
        .catch(() => {});
    }
  }

  static insertPastedText(target, text, gfm) {
    insertText(target, (textBefore) => {
      // If the text before the cursor contains an odd number of backticks,
      // we are either inside an inline code span that starts with 1 backtick
      // or a code block that starts with 3 backticks.
      // This logic still holds when there are one or more _closed_ code spans
      // or blocks that will have 2 or 6 backticks.
      // This will break down when the actual code block contains an uneven
      // number of backticks, but this is a rare edge case.
      const backtickMatch = textBefore.match(/`/g);
      const insideCodeBlock = backtickMatch && backtickMatch.length % 2 === 1;

      if (insideCodeBlock) {
        return text;
      }

      return gfm;
    });
  }

  static transformGFMSelection(documentFragment) {
    const gfmElements = documentFragment.querySelectorAll('.md');
    switch (gfmElements.length) {
      case 0: {
        return documentFragment;
      }
      case 1: {
        return gfmElements[0];
      }
      default: {
        const allGfmElement = document.createElement('div');

        for (let i = 0; i < gfmElements.length; i += 1) {
          const gfmElement = gfmElements[i];
          allGfmElement.appendChild(gfmElement);
          allGfmElement.appendChild(document.createTextNode('\n\n'));
        }
==== app/assets/javascripts/behaviors/markdown/render_json_table.js ====
import { memoize } from 'lodash';
import Vue from 'vue';
import { __ } from '~/locale';
import { createAlert } from '~/alert';
import { parseBoolean } from '~/lib/utils/common_utils';

// Async import component since we might not need it...
const JSONTable = memoize(
  () => import(/* webpackChunkName: 'gfm_json_table' */ '../components/json_table.vue'),
);

const mountParseError = (element) => {
  // Let the error container be a sibling to the element.
  // Otherwise, dismissing the alert causes the copy button to be misplaced.
  const container = document.createElement('div');
  element.insertAdjacentElement('beforebegin', container);

  // We need to create a child element with a known selector for `createAlert`
  const el = document.createElement('div');
  el.classList.add('js-json-table-error');

  container.insertAdjacentElement('afterbegin', el);

  return createAlert({
    message: __('Unable to parse JSON'),
    variant: 'warning',
    parent: container,
    containerSelector: '.js-json-table-error',
  });
};

const mountJSONTableVueComponent = (userData, element, isHtmlSafe = false) => {
  const { fields = [], items = [], filter, caption } = userData;
  const container = document.createElement('div');

  element.classList.add('js-json-table');
  element.replaceChildren(container);

  const props = {
    fields,
    items,
    hasFilter: filter,
    isHtmlSafe,
  };

  if (caption) {
    props.caption = caption;
  }

  return new Vue({
    el: container,
    render(h) {
      return h(JSONTable, { props });
    },
  });
};

const renderTable = (element) => {
  // Avoid rendering multiple times
  if (!element || element.classList.contains('js-json-table')) {
    return;
  }

  try {
    mountJSONTableVueComponent(JSON.parse(element.textContent), element);
  } catch (e) {
    mountParseError(element);
  }
};

const renderTableHTML = (element) => {
  const parent = element.parentElement;

  // Avoid rendering multiple times
  if (!parent || parent.classList.contains('js-json-table')) {
    return;
  }

  try {
    // Extract data from rendered HTML table
    const fields = JSON.parse(element.dataset.tableFields);
    const filter = parseBoolean(element.dataset.tableFilter);
    const markdown = parseBoolean(element.dataset.tableMarkdown);

    // The caption was processed with markdown, so it's wrapped in a <p>.
    // We want that removed so it will fit semantically within a <small>.
    const captionNode = element.querySelector('caption p');
    const caption = captionNode ? captionNode.innerHTML : null;

    const items = Array.from(element.querySelectorAll('tbody tr').values()).map((row) =>
      fields.reduce(
        (item, field, index) => ({
          ...item,
          [field.key]: row.querySelectorAll('td').item(index).innerHTML,
        }),
        {},
      ),
    );

    mountJSONTableVueComponent({ fields, filter, caption, items }, parent, Boolean(markdown));
  } catch (e) {
    mountParseError(parent);
  }
};

export const renderJSONTable = (elements) => {
  elements.forEach(renderTable);
};

export const renderJSONTableHTML = (elements) => {
  elements.forEach(renderTableHTML);
};
==== app/assets/javascripts/behaviors/markdown/render_math.js ====
import { GlAlert } from '@gitlab/ui';
import { escape } from 'lodash';
import Vue from 'vue';
import { differenceInMilliseconds } from '~/lib/utils/datetime_utility';
import { s__, sprintf } from '~/locale';

// Renders math using KaTeX in an element.
//
// Typically for elements with the `js-render-math` class such as
//   <code class="js-render-math"></code>
//
// See app/assets/javascripts/behaviors/markdown/render_gfm.js

const MAX_MATH_CHARS = 1000;
const MAX_MACRO_EXPANSIONS = 1000;
const MAX_USER_SPECIFIED_EMS = 20;
const MAX_RENDER_TIME_MS = 2000;
const LAZY_ALERT_SHOWN_CLASS = 'lazy-alert-shown';

// Wait for the browser to reflow the layout. Reflowing SVG takes time.
// This has to wrap the inner function, otherwise IE/Edge throw "invalid calling object".
const waitForReflow = (fn) => {
  window.requestIdleCallback(fn);
};

const katexOptions = (el) => {
  const options = {
    displayMode: el.dataset.mathStyle === 'display',
    throwOnError: true,
    trust: (context) =>
      // this config option restores the KaTeX pre-v0.11.0
      // behavior of allowing certain commands and protocols
      // eslint-disable-next-line @gitlab/require-i18n-strings
      ['\\url', '\\href'].includes(context.command) &&
      ['http', 'https', 'mailto', '_relative'].includes(context.protocol),
  };

  if (gon.math_rendering_limits_enabled) {
    options.maxSize = MAX_USER_SPECIFIED_EMS;
    // See https://gitlab.com/gitlab-org/gitlab/-/merge_requests/111107 for
    // reasoning behind this value
    options.maxExpand = MAX_MACRO_EXPANSIONS;
  } else {
    // eslint-disable-next-line @gitlab/require-i18n-strings
    options.maxExpand = 'Infinity';
  }

  return options;
};

/**
 * Renders math blocks sequentially while protecting against DoS attacks. Math blocks have a maximum character limit of MAX_MATH_CHARS. If rendering math takes longer than MAX_RENDER_TIME_MS, all subsequent math blocks are skipped and an error message is shown.
 */
class SafeMathRenderer {
  /*
  How this works:

  The performance bottleneck in rendering math is in the browser trying to reflow the generated SVG.
  During this time, the JS is blocked and the page becomes unresponsive.
  We want to render math blocks one by one until a certain time is exceeded, after which we stop
  rendering subsequent math blocks, to protect against DoS. However, browsers do reflowing in an
  asynchronous task, so we can't time it synchronously.

  SafeMathRenderer essentially does the following:
  1. Replaces all math blocks with placeholders so that they're not mistakenly rendered twice.
  2. Places each placeholder element in a queue.
  3. Renders the element at the head of the queue and waits for reflow.
  4. After reflow, gets the elapsed time since step 3 and repeats step 3 until the queue is empty.
   */
  queue = [];
  totalMS = 0;

  constructor(elements, katex) {
    this.elements = elements;
    this.katex = katex;

    this.renderElement = this.renderElement.bind(this);
    this.render = this.render.bind(this);
    this.pageName = document.querySelector('body').dataset.page;
  }

  renderElement(chosenEl) {
    if (!this.queue.length && !chosenEl) {
      return;
    }

    const el = chosenEl || this.queue.shift();
    const forceRender = Boolean(chosenEl) || !gon.math_rendering_limits_enabled;
    const text = el.textContent;
    const isTextTooLong = text.length > MAX_MATH_CHARS;

    el.removeAttribute('style');
    if (!forceRender && (this.totalMS >= MAX_RENDER_TIME_MS || isTextTooLong)) {
      if (!el.classList.contains(LAZY_ALERT_SHOWN_CLASS)) {
        el.classList.add(LAZY_ALERT_SHOWN_CLASS);

        // Show un-rendered math code
        const codeElement = document.createElement('pre');
        codeElement.className = 'code';
        codeElement.textContent = el.textContent;
        codeElement.dataset.mathStyle = el.dataset.mathStyle;
        el.replaceChildren(codeElement);

        this.renderAlert({
          // We do not want to put the alert in the <copy-code> element's nearest
          // positioned ancestor, otherwise it will display over the alert instead of
          // the code block. Instead, put the alert *before* that ancestor.
          mountBeforeEl: el.closest('.js-markdown-code'),
          isTextTooLong,
          onDisplayAnyway: () => {
            this.renderElement(codeElement);
          },
        });
      }

      // Render the next math
      this.renderElement();
    } else {
      this.startTime = Date.now();

==== app/assets/javascripts/blob/3d_viewer/index.js ====
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import { STLLoader } from 'three/examples/jsm/loaders/STLLoader';
import * as THREE from 'three';
import MeshObject from './mesh_object';

export default class Renderer {
  constructor(container) {
    this.renderWrapper = this.render.bind(this);
    this.objects = [];

    this.container = container;
    this.width = this.container.offsetWidth;
    this.height = 500;

    this.loader = new STLLoader();

    this.fov = 45;
    this.camera = new THREE.PerspectiveCamera(this.fov, this.width / this.height, 1, 1000);

    this.scene = new THREE.Scene();

    this.scene.add(this.camera);

    // Set up the viewer
    this.setupRenderer();
    this.setupGrid();
    this.setupLight();

    // Set up OrbitControls
    this.controls = new OrbitControls(this.camera, this.renderer.domElement);
    this.controls.minDistance = 5;
    this.controls.maxDistance = 30;
    this.controls.enableKeys = false;

    this.loadFile();
  }

  setupRenderer() {
    this.renderer = new THREE.WebGLRenderer({
      antialias: true,
    });

    this.renderer.setClearColor(0xffffff);
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.setSize(this.width, this.height);
  }

  setupLight() {
    // Point light illuminates the object
    const pointLight = new THREE.PointLight(0xffffff, 2, 0);

    pointLight.castShadow = true;

    this.camera.add(pointLight);

    // Ambient light illuminates the scene
    const ambientLight = new THREE.AmbientLight(0xffffff, 1);
    this.scene.add(ambientLight);
  }

  setupGrid() {
    this.grid = new THREE.GridHelper(20, 20, 0x000000, 0x000000);

    this.scene.add(this.grid);
  }

  loadFile() {
    this.loader.load(this.container.dataset.endpoint, (geo) => {
      const obj = new MeshObject(geo);

      this.objects.push(obj);
      this.scene.add(obj);

      this.start();
      this.setDefaultCameraPosition();
    });
  }

  start() {
    // Empty the container first
    this.container.innerHTML = '';

    // Add to DOM
    this.container.appendChild(this.renderer.domElement);

    // Make controls visible
    this.container.parentNode.classList.remove('is-stl-loading');

    this.render();
  }

  render() {
    this.renderer.render(this.scene, this.camera);

    requestAnimationFrame(this.renderWrapper);
  }

  changeObjectMaterials(material) {
    this.objects.forEach((obj) => {
      obj.changeMaterial(material);
    });
  }

  setDefaultCameraPosition() {
    const obj = this.objects[0];
    const radius = obj.geometry.boundingSphere.radius / 1.5;
    const dist = radius / Math.sin((this.fov * (Math.PI / 180)) / 2);

    this.camera.position.set(0, dist + 1, dist);

    this.camera.lookAt(this.grid);
    this.controls.update();
  }
}
==== app/assets/javascripts/blob/viewer/index.js ====
import $ from 'jquery';
import { sanitize } from '~/lib/dompurify';
import { renderGFM } from '~/behaviors/markdown/render_gfm';
import { createAlert } from '~/alert';
import { __ } from '~/locale';
import {
  REPO_BLOB_LOAD_VIEWER_START,
  REPO_BLOB_LOAD_VIEWER_FINISH,
  REPO_BLOB_LOAD_VIEWER,
  REPO_BLOB_SWITCH_TO_VIEWER_START,
  REPO_BLOB_SWITCH_VIEWER,
} from '~/performance/constants';
import { performanceMarkAndMeasure } from '~/performance/utils';
import { fixTitle } from '~/tooltips';
import axios from '~/lib/utils/axios_utils';
import { handleLocationHash } from '~/lib/utils/common_utils';
import eventHub from '~/notes/event_hub';

const loadRichBlobViewer = (type) => {
  switch (type) {
    case 'notebook':
      return import(/* webpackChunkName: 'notebook_viewer' */ '../notebook_viewer');
    case 'openapi':
      return import(/* webpackChunkName: 'openapi_viewer' */ '../openapi_viewer');
    case 'csv':
      return import(/* webpackChunkName: 'csv_viewer' */ '../csv_viewer');
    case 'pdf':
      return import(/* webpackChunkName: 'pdf_viewer' */ '../pdf_viewer');
    case 'sketch':
      return import(/* webpackChunkName: 'sketch_viewer' */ '../sketch_viewer');
    case 'stl':
      return import(/* webpackChunkName: 'stl_viewer' */ '../stl_viewer');
    default:
      return Promise.resolve();
  }
};

const loadViewer = (viewerParam) => {
  const viewer = viewerParam;
  const { url } = viewer.dataset;

  if (!url || viewer.dataset.loaded || viewer.dataset.loading) {
    return Promise.resolve(viewer);
  }

  viewer.dataset.loading = 'true';

  return axios.get(url).then(({ data }) => {
    const unsafeHtml = data.html;
    viewer.innerHTML = sanitize(unsafeHtml);

    window.requestIdleCallback(() => {
      delete viewer.dataset.loading;
    });

    return viewer;
  });
};

export const initAuxiliaryViewer = () => {
  const auxiliaryViewer = document.querySelector('.blob-viewer[data-type="auxiliary"]');
  if (!auxiliaryViewer) return;

  loadViewer(auxiliaryViewer);
};

export const handleBlobRichViewer = (viewer, type) => {
  if (!viewer || !type) return;

  loadRichBlobViewer(type)
    .then((module) => module?.default(viewer))
    .catch((error) => {
      createAlert({
        message: __('Error loading file viewer.'),
      });
      throw error;
    });
};

export class BlobViewer {
  constructor() {
    performanceMarkAndMeasure({
      mark: REPO_BLOB_LOAD_VIEWER_START,
    });
    const viewer = document.querySelector('.blob-viewer[data-type="rich"]');
    const type = viewer?.dataset?.richType;
    initAuxiliaryViewer();

    handleBlobRichViewer(viewer, type);

    this.initMainViewers();
  }

  initMainViewers() {
    this.$fileHolder = $('.file-holder');
    if (!this.$fileHolder.length) return;

    this.switcher = document.querySelector('.js-blob-viewer-switcher');
    this.switcherBtns = document.querySelectorAll('.js-blob-viewer-switch-btn');
    this.copySourceBtn = document.querySelector('.js-copy-blob-source-btn');
    this.copySourceBtnTooltip = document.querySelector('.js-copy-blob-source-btn-tooltip');

    this.simpleViewer = this.$fileHolder[0].querySelector('.blob-viewer[data-type="simple"]');
    this.richViewer = this.$fileHolder[0].querySelector('.blob-viewer[data-type="rich"]');

    this.initBindings();

    this.switchToInitialViewer();
  }

  switchToInitialViewer() {
    const initialViewer = this.$fileHolder[0].querySelector('.blob-viewer:not(.hidden)');
    let initialViewerName = initialViewer.dataset.type;

    if (this.switcher && window.location.hash.indexOf('#L') === 0) {
      initialViewerName = 'simple';
    }

    this.switchToViewer(initialViewerName);
  }
==== app/assets/javascripts/code_navigation/utils/dom_utils.js ====
import { sanitize } from '~/lib/dompurify';

const TEXT_NODE = 3;

const isTextNode = ({ nodeType }) => nodeType === TEXT_NODE;

const isBlank = (str) => !str || /^\s*$/.test(str);

const isMatch = (s1, s2) => !isBlank(s1) && s1.trim() === s2.trim();

const createSpan = (content, classList) => {
  const span = document.createElement('span');
  span.innerText = content;
  span.classList = classList || '';
  return span;
};

const wrapSpacesWithSpans = (text) =>
  text.replace(/ /g, createSpan(' ').outerHTML).replace(/\t/g, createSpan('	').outerHTML);

// eslint-disable-next-line max-params
const wrapTextWithSpan = (el, text, classList, dataset) => {
  if (isTextNode(el) && isMatch(el.textContent, text)) {
    const newEl = createSpan(text.trim(), classList);
    Object.assign(newEl.dataset, dataset);
    el.replaceWith(newEl);
  }
};

const wrapNodes = (text, classList, dataset) => {
  const wrapper = createSpan();
  const unSafeHtml = wrapSpacesWithSpans(text);
  wrapper.innerHTML = sanitize(unSafeHtml);
  wrapper.childNodes.forEach((el) => wrapTextWithSpan(el, text, classList, dataset));
  return wrapper.childNodes;
};

export { wrapNodes, isTextNode };
==== app/assets/javascripts/content_editor/extensions/copy_paste.js ====
import OrderedMap from 'orderedmap';
import { Extension } from '@tiptap/core';
import { Plugin, PluginKey } from '@tiptap/pm/state';
import { Schema, DOMParser as ProseMirrorDOMParser, DOMSerializer } from '@tiptap/pm/model';
import { uniqueId } from 'lodash';
import { __ } from '~/locale';
import { VARIANT_DANGER } from '~/alert';
import createMarkdownDeserializer from '../services/gl_api_markdown_deserializer';
import { ALERT_EVENT, EXTENSION_PRIORITY_HIGHEST } from '../constants';
import CodeBlockHighlight from './code_block_highlight';
import CodeSuggestion from './code_suggestion';
import Diagram from './diagram';
import Frontmatter from './frontmatter';
import { loadingPlugin, findLoader } from './loading';

const TEXT_FORMAT = 'text/plain';
const GFM_FORMAT = 'text/x-gfm';
const HTML_FORMAT = 'text/html';
const VS_CODE_FORMAT = 'vscode-editor-data';
const CODE_BLOCK_NODE_TYPES = [
  CodeBlockHighlight.name,
  CodeSuggestion.name,
  Diagram.name,
  Frontmatter.name,
];

function parseHTML(schema, html) {
  const parser = new DOMParser();
  const startTag = '<body>';
  const endTag = '</body>';
  const { body } = parser.parseFromString(startTag + html + endTag, 'text/html');
  return { document: ProseMirrorDOMParser.fromSchema(schema).parse(body) };
}

export default Extension.create({
  name: 'copyPaste',
  priority: EXTENSION_PRIORITY_HIGHEST,
  addOptions() {
    return {
      renderMarkdown: null,
      serializer: null,
    };
  },
  addCommands() {
    return {
      pasteContent:
        (content = '', processMarkdown = true) =>
        () => {
          const { editor, options } = this;
          const { renderMarkdown, eventHub } = options;
          const deserializer = createMarkdownDeserializer({ render: renderMarkdown });

          const pasteSchemaSpec = { ...editor.schema.spec };
          pasteSchemaSpec.marks = OrderedMap.from(pasteSchemaSpec.marks).remove('span');
          pasteSchemaSpec.nodes = OrderedMap.from(pasteSchemaSpec.nodes)
            .remove('div')
            .remove('pre');
          const pasteSchema = new Schema(pasteSchemaSpec);

          const promise = processMarkdown
            ? deserializer.deserialize({ schema: pasteSchema, markdown: content })
            : Promise.resolve(parseHTML(pasteSchema, content));
          const loaderId = uniqueId('loading');

          Promise.resolve()
            .then(() => {
              editor
                .chain()
                .deleteSelection()
                .setMeta(loadingPlugin, {
                  add: { loaderId, pos: editor.state.selection.from },
                })
                .run();

              return promise;
            })
            .then(async ({ document }) => {
              if (!document) return;

              const pos = findLoader(editor.state, loaderId);
              if (!pos) return;

              const { firstChild, childCount } = document.content;
              const toPaste =
                childCount === 1 && firstChild.type.name === 'paragraph'
                  ? firstChild.content
                  : document.content;

              editor
                .chain()
                .setMeta(loadingPlugin, { remove: { loaderId } })
                .insertContentAt(pos, toPaste.toJSON(), {
                  updateSelection: false,
                })
                .run();
            })
            .catch(() => {
              eventHub.$emit(ALERT_EVENT, {
                message: __(
                  'An error occurred while pasting text in the editor. Please try again.',
                ),
                variant: VARIANT_DANGER,
              });
            });

          return true;
        },
    };
  },
  addProseMirrorPlugins() {
    let pasteRaw = false;

    const handleCutAndCopy = (view, event) => {
      const slice = view.state.selection.content();
      let gfmContent = this.options.serializer.serialize({ doc: slice.content });
      const gfmContentWithoutSingleTableCell = gfmContent.replace(
        /^<table>[\s\n]*<tr>[\s\n]*<t[hd]>|<\/t[hd]>[\s\n]*<\/tr>[\s\n]*<\/table>[\s\n]*$/gim,
        '',
      );
      const containsSingleTableCell = !/<t[hd]>/.test(gfmContentWithoutSingleTableCell);
==== app/assets/javascripts/content_editor/extensions/loading.js ====
import { Node } from '@tiptap/core';
import { Decoration, DecorationSet } from '@tiptap/pm/view';
import { Plugin } from '@tiptap/pm/state';

const createDotsLoader = () => {
  const root = document.createElement('span');
  root.classList.add('gl-inline-flex', 'gl-items-center');
  root.innerHTML = '<span class="gl-dots-loader gl-mx-2"><span></span></span>';
  return root;
};

export const loadingPlugin = new Plugin({
  state: {
    init() {
      return DecorationSet.empty;
    },
    apply(tr, set) {
      let transformedSet = set.map(tr.mapping, tr.doc);
      const action = tr.getMeta(this);

      if (action?.add) {
        const deco = Decoration.widget(action.add.pos, createDotsLoader(), {
          id: action.add.loaderId,
          side: -1,
        });
        transformedSet = transformedSet.add(tr.doc, [deco]);
      } else if (action?.remove) {
        transformedSet = transformedSet.remove(
          transformedSet.find(null, null, (spec) => spec.id === action.remove.loaderId),
        );
      }
      return transformedSet;
    },
  },
  props: {
    decorations(state) {
      return this.getState(state);
    },
  },
});

export const findLoader = (state, loaderId) => {
  const decos = loadingPlugin.getState(state);
  const found = decos.find(null, null, (spec) => spec.id === loaderId);

  return found.length ? found[0].from : null;
};

export const findAllLoaders = (state) => loadingPlugin.getState(state).find();

export default Node.create({
  name: 'loading',
  inline: true,
  group: 'inline',

  addAttributes() {
    return {
      id: {
        default: null,
      },
    };
  },

  addProseMirrorPlugins() {
    return [loadingPlugin];
  },
});
==== app/assets/javascripts/deprecated_jquery_dropdown/render.js ====
import { slugify } from '~/lib/utils/text_utility';

const renderersByType = {
  divider(element) {
    element.classList.add('divider');

    return element;
  },
  separator(element) {
    element.classList.add('separator');

    return element;
  },
  header(element, data) {
    element.classList.add('dropdown-header');
    // eslint-disable-next-line no-unsanitized/property
    element.innerHTML = data.content;

    return element;
  },
};

// eslint-disable-next-line max-params
function getPropertyWithDefault(data, options, property, defaultValue = '') {
  let result;

  if (options[property] != null) {
    result = options[property](data);
  } else {
    result = data[property] != null ? data[property] : defaultValue;
  }

  return result;
}

function getHighlightTextBuilder(text, data, options) {
  if (options.highlight) {
    return data.template
      ? options.highlightTemplate(text, data.template)
      : options.highlightText(text);
  }

  return text;
}

function getIconTextBuilder(text, data, options) {
  if (options.icon) {
    const wrappedText = `<span>${text}</span>`;
    return data.icon ? `${data.icon}${wrappedText}` : wrappedText;
  }

  return text;
}

function getLinkText(data, options) {
  const text = getPropertyWithDefault(data, options, 'text');

  return [getHighlightTextBuilder, getIconTextBuilder].reduce(
    (acc, fn) => fn(acc, data, options),
    text,
  );
}

function escape(text) {
  return text ? String(text).replace(/'/g, "\\'") : text;
}

function getOptionValue(data, options) {
  if (options.renderRow) {
    return undefined;
  }

  return escape(options.id ? options.id(data) : data.id);
}

function shouldHide(data, { options }) {
  const value = getOptionValue(data, options);

  return options.hideRow && options.hideRow(value);
}

function hideElement(element) {
  element.style.display = 'none';

  return element;
}

function checkSelected(data, options) {
  const value = getOptionValue(data, options);

  if (!options.parent) {
    return !data.id;
  }
  if (value) {
    return (
      options.parent.querySelector(`input[name='${options.fieldName}'][value='${value}']`) != null
    );
  }

  return options.parent.querySelector(`input[name='${options.fieldName}']`) == null;
}

// eslint-disable-next-line max-params
function createLink(data, selected, options, index) {
  const link = document.createElement('a');

  link.href = getPropertyWithDefault(data, options, 'url', '#');

  if (options.icon) {
    link.classList.add('gl-flex', 'align-items-center');
  }

  if (options.trackSuggestionClickedLabel) {
    link.dataset.trackAction = 'click_text';
    link.dataset.trackLabel = options.trackSuggestionClickedLabel;
    link.dataset.trackValue = index;
    link.dataset.trackProperty = slugify(data.category || 'no-category');
  }

  link.classList.toggle('is-active', selected);
==== app/assets/javascripts/diffs/components/commit_item.vue ====
<script>
import { GlButtonGroup, GlButton, GlTooltipDirective, GlFormCheckbox } from '@gitlab/ui';
import SafeHtml from '~/vue_shared/directives/safe_html';

import CommitPipelineStatus from '~/projects/tree/components/commit_pipeline_status.vue';
import ModalCopyButton from '~/vue_shared/components/modal_copy_button.vue';
import TimeAgoTooltip from '~/vue_shared/components/time_ago_tooltip.vue';
import UserAvatarLink from '~/vue_shared/components/user_avatar/user_avatar_link.vue';

/**
 * CommitItem
 *
 * -----------------------------------------------------------------
 * WARNING: Please keep changes up-to-date with the following files:
 * - `views/projects/commits/_commit.html.haml`
 * -----------------------------------------------------------------
 *
 * This Component was cloned from a HAML view. For the time being they
 * coexist, but there is an issue to remove the duplication.
 * https://gitlab.com/gitlab-org/gitlab-foss/issues/51613
 *
 */

export default {
  components: {
    UserAvatarLink,
    ModalCopyButton,
    TimeAgoTooltip,
    CommitPipelineStatus,
    GlButtonGroup,
    GlButton,
    GlFormCheckbox,
  },
  directives: {
    GlTooltip: GlTooltipDirective,
    SafeHtml,
  },
  props: {
    isSelectable: {
      type: Boolean,
      required: false,
      default: false,
    },
    commit: {
      type: Object,
      required: true,
    },
    checked: {
      type: Boolean,
      required: false,
      default: false,
    },
    collapsible: {
      type: Boolean,
      required: false,
      default: true,
    },
  },
  computed: {
    author() {
      return this.commit.author || {};
    },
    authorName() {
      return this.author.name || this.commit.author_name;
    },
    authorClass() {
      return this.author.name ? 'js-user-link' : '';
    },
    authorId() {
      return this.author.id ? this.author.id : '';
    },
    authorUrl() {
      return this.author.web_url || `mailto:${this.commit.author_email}`;
    },
    authorAvatar() {
      return this.author.avatar_url || this.commit.author_gravatar_url;
    },
    commitDescription() {
      // Strip the newline at the beginning
      return this.commit.description_html.replace(/^&#x000A;/, '');
    },
  },
  safeHtmlConfig: {
    ADD_TAGS: ['gl-emoji'],
  },
};
</script>

<template>
  <li :class="{ 'js-toggle-container': collapsible }" class="commit">
    <div class="gl-block gl-flex-row-reverse gl-items-start gl-justify-between sm:gl-flex">
      <div class="commit-actions gl-hidden gl-flex-row gl-items-center gl-justify-end sm:gl-flex">
        <div
          v-if="commit.signature_html"
          v-html="commit.signature_html /* eslint-disable-line vue/no-v-html */"
        ></div>
        <commit-pipeline-status
          v-if="commit.pipeline_status_path"
          :endpoint="commit.pipeline_status_path"
          class="mb-2 gl-inline-flex"
        />
        <gl-button-group class="gl-ml-4" data-testid="commit-sha-group">
          <gl-button label class="gl-font-monospace" data-testid="commit-sha-short-id">{{
            commit.short_id
          }}</gl-button>
          <modal-copy-button
            :text="commit.id"
            :title="__('Copy commit SHA')"
            class="input-group-text"
          />
        </gl-button-group>
      </div>
      <div>
        <div class="float-left align-self-start gl-flex gl-items-center">
          <gl-form-checkbox
            v-if="isSelectable"
            :checked="checked"
            class="gl-mt-3"
            @change="$emit('handleCheckboxChange', !checked)"
          />
==== app/assets/javascripts/diffs/components/diff_row.vue ====
<script>
/* eslint-disable vue/no-v-html */
/**
NOTE: This file uses v-html over v-safe-html for performance reasons, see:
https://gitlab.com/gitlab-org/gitlab/-/merge_requests/57842
* */
import { memoize } from 'lodash';
import { isLoggedIn } from '~/lib/utils/common_utils';
import { compatFunctionalMixin } from '~/lib/utils/vue3compat/compat_functional_mixin';
import {
  PARALLEL_DIFF_VIEW_TYPE,
  CONFLICT_MARKER_THEIR,
  CONFLICT_OUR,
  CONFLICT_THEIR,
  CONFLICT_MARKER,
} from '../constants';
import {
  getInteropInlineAttributes,
  getInteropOldSideAttributes,
  getInteropNewSideAttributes,
} from '../utils/interoperability';
import DiffGutterAvatars from './diff_gutter_avatars.vue';
import * as utils from './diff_row_utils';

export default {
  DiffGutterAvatars,
  InlineFindingsGutterIconDropdown: () =>
    import('ee_component/diffs/components/inline_findings_gutter_icon_dropdown.vue'),

  // Temporary mixin for migration from Vue.js 2 to @vue/compat
  mixins: [compatFunctionalMixin],

  props: {
    fileHash: {
      type: String,
      required: true,
    },
    filePath: {
      type: String,
      required: true,
    },
    line: {
      type: Object,
      required: true,
    },
    isCommented: {
      type: Boolean,
      required: false,
      default: false,
    },
    coverageLoaded: {
      type: Boolean,
      required: false,
      default: false,
    },
    inline: {
      type: Boolean,
      required: false,
      default: false,
    },
    index: {
      type: Number,
      required: true,
    },
    isHighlighted: {
      type: Boolean,
      required: true,
    },
    isFirstHighlightedLine: {
      type: Boolean,
      required: false,
      default: false,
    },
    isLastHighlightedLine: {
      type: Boolean,
      required: false,
      default: false,
    },
    fileLineCoverage: {
      type: Function,
      required: true,
    },
  },
  classNameMap: memoize(
    (props) => {
      return {
        [PARALLEL_DIFF_VIEW_TYPE]: !props.inline,
        commented: props.isCommented,
      };
    },
    (props) => [!props.inline, props.isCommented].join(':'),
  ),
  parallelViewLeftLineType: memoize(
    (props) => {
      return utils.parallelViewLeftLineType({
        line: props.line,
        highlighted: props.isHighlighted,
        commented: props.isCommented,
        selectionStart: props.isFirstHighlightedLine,
        selectionEnd: props.isLastHighlightedLine,
      });
    },
    (props) =>
      [
        props.line.left?.type,
        props.line.right?.type,
        props.isHighlighted,
        props.isCommented,
        props.isFirstHighlightedLine,
        props.isLastHighlightedLine,
      ].join(':'),
  ),
  coverageStateLeft: memoize(
    (props) => {
      if (!props.inline || !props.line.left) return {};
      return props.fileLineCoverage(props.filePath, props.line.left.new_line);
    },
    (props) =>
      [props.inline, props.filePath, props.line.left?.new_line, props.coverageLoaded].join(':'),
  ),
==== app/assets/javascripts/editor/extensions/source_editor_markdown_livepreview_ext.js ====
import { KeyMod, KeyCode, Emitter } from 'monaco-editor';
import { debounce } from 'lodash';
import { BLOB_PREVIEW_ERROR } from '~/blob_edit/constants';
import { createAlert } from '~/alert';
import { sanitize } from '~/lib/dompurify';
import axios from '~/lib/utils/axios_utils';
import { renderGFM } from '~/behaviors/markdown/render_gfm';
import {
  EXTENSION_MARKDOWN_PREVIEW_PANEL_CLASS,
  EXTENSION_MARKDOWN_PREVIEW_ACTION_ID,
  EXTENSION_MARKDOWN_PREVIEW_HIDE_ACTION_ID,
  EXTENSION_MARKDOWN_PREVIEW_PANEL_WIDTH,
  EXTENSION_MARKDOWN_PREVIEW_PANEL_PARENT_CLASS,
  EXTENSION_MARKDOWN_PREVIEW_UPDATE_DELAY,
  EXTENSION_MARKDOWN_PREVIEW_LABEL,
  EXTENSION_MARKDOWN_HIDE_PREVIEW_LABEL,
} from '../constants';

const fetchPreview = (text, previewMarkdownPath) => {
  return axios
    .post(previewMarkdownPath, {
      text,
    })
    .then(({ data }) => {
      return data.body;
    });
};

const setupDomElement = ({ injectToEl = null } = {}) => {
  const previewEl = document.createElement('div');
  previewEl.classList.add(EXTENSION_MARKDOWN_PREVIEW_PANEL_CLASS);
  previewEl.style.display = 'none';
  if (injectToEl) {
    injectToEl.appendChild(previewEl);
  }
  return previewEl;
};

export class EditorMarkdownPreviewExtension {
  static get extensionName() {
    return 'EditorMarkdownPreview';
  }

  onSetup(instance, setupOptions) {
    this.preview = {
      el: undefined,
      actions: {
        preview: undefined,
        hide: undefined,
      },
      shown: false,
      modelChangeListener: undefined,
      path: setupOptions.previewMarkdownPath,
      actionShowPreviewCondition: instance.createContextKey('toggleLivePreview', true),
      eventEmitter: new Emitter(),
    };
    this.toolbarButtons = [];

    this.setupPreviewAction(instance);

    const debouncedResizeHandler = debounce((entries) => {
      for (const entry of entries) {
        const { width: newInstanceWidth } = entry.contentRect;
        if (instance.markdownPreview?.shown) {
          const newWidth = newInstanceWidth * EXTENSION_MARKDOWN_PREVIEW_PANEL_WIDTH;
          EditorMarkdownPreviewExtension.resizePreviewLayout(instance, newWidth);
        }
      }
    }, 50);

    this.resizeObserver = new ResizeObserver(debouncedResizeHandler);

    this.preview.eventEmitter.event(this.togglePreview.bind(this, instance));
  }

  onBeforeUnuse(instance) {
    this.cleanup(instance);
    const ids = this.toolbarButtons.map((item) => item.id);
    if (instance.toolbar) {
      instance.toolbar.removeItems(ids);
    }
  }

  cleanup(instance) {
    this.resizeObserver.disconnect();
    if (this.preview.modelChangeListener) {
      this.preview.modelChangeListener.dispose();
    }
    this.preview.actions.preview.dispose();
    this.preview.actions.hide.dispose();
    if (this.preview.shown) {
      this.togglePreviewPanel(instance);
      this.togglePreviewLayout(instance);
    }
    this.preview.shown = false;
  }

  static resizePreviewLayout(instance, width) {
    const { height } = instance.getLayoutInfo();
    instance.layout({ width, height });
  }

  togglePreviewLayout(instance) {
    const { width } = instance.getLayoutInfo();
    let newWidth;
    if (this.preview.shown) {
      // This means the preview is to be closed at the next step
      newWidth = width / EXTENSION_MARKDOWN_PREVIEW_PANEL_WIDTH;
      this.resizeObserver.disconnect();
    } else {
      // The preview is hidden, but is in the process to be opened
      newWidth = width * EXTENSION_MARKDOWN_PREVIEW_PANEL_WIDTH;
      this.resizeObserver.observe(instance.getContainerDomNode());
    }
    EditorMarkdownPreviewExtension.resizePreviewLayout(instance, newWidth);
  }

  togglePreviewPanel(instance) {
    const parentEl = instance.getDomNode().parentElement;
    const { el: previewEl } = this.preview;
==== app/assets/javascripts/entrypoints/graphql_explorer.js ====
import '~/webpack';
import gitlabLogo from '@gitlab/svgs/dist/illustrations/gitlab_logo.svg?raw';
import { gql } from '@apollo/client';
import { GraphiQL } from 'graphiql';
/* eslint-disable no-restricted-imports */
import React from 'react';
import { createRoot } from 'react-dom/client';
import { Mousetrap } from '~/lib/mousetrap';
import { DOCS_URL_IN_EE_DIR } from 'jh_else_ce/lib/utils/url_utility';
/* eslint-enable no-restricted-imports */
import createDefaultClient, { fetchPolicies } from '~/lib/graphql';
import { keysFor, TOGGLE_PERFORMANCE_BAR } from '~/behaviors/shortcuts/keybindings';
import Shortcuts from '~/behaviors/shortcuts/shortcuts';

const apolloClient = createDefaultClient(
  {},
  {
    fetchPolicy: fetchPolicies.NO_CACHE,
    cacheConfig: { addTypename: false, typePolicies: {}, possibleTypes: {} },
  },
);

const defaultQuery = `# Welcome to GraphQL explorer (GraphiQL)
#
# Full documentation: ${DOCS_URL_IN_EE_DIR}/api/graphql
#
# GraphQL explorer is an in-browser tool for writing, validating, and
# testing GraphQL queries.
#
# Type queries into this side of the screen, and you will see intelligent
# typeaheads aware of the current GraphQL type schema and live syntax and
# validation errors highlighted within the text.
#
# GraphQL queries typically start with a "{" character. Lines that start
# with a # are ignored.
#
# For example, to get a specific project and the title of issue #2:
#
# {
#   project(fullPath: "gitlab-org/graphql-sandbox") {
#     name
#     issue(iid: "2") {
#       title
#     }
#   }
# }
#
# Keyboard shortcuts:
#
#   Prettify query:  Shift-Ctrl-P (or press the prettify button)
#
#  Merge fragments:  Shift-Ctrl-M (or press the merge button)
#
#        Run Query:  Ctrl-Enter (or press the play button)
#
#    Auto Complete:  Ctrl-Space (or just start typing)
#
`;

const GraphiQLLogo = React.createElement(
  GraphiQL.Logo,
  {},
  React.createElement('a', {
    href: `${DOCS_URL_IN_EE_DIR}/api/graphql`,
    target: '_blank',
    title: 'GraphQL API documentation',
    dangerouslySetInnerHTML: { __html: gitlabLogo },
  }),
);

const graphiqlContainer = document.getElementById('graphiql-container');

function apolloFetcher(graphQLParams, { headers }) {
  let query = gql(graphQLParams.query);

  /*
    GraphiQL allows multiple named operations to be declared in the editor.
    When the user clicks execute, they are prompted to select one of the operations.
    We must filter the query to only contain the selected operation so we execute the correct query
    and avoid an `Ambiguous GraphQL document: contains 2 operations` error.
  */
  if (graphQLParams.operationName) {
    query = {
      ...query,
      definitions: query.definitions.filter((definition) => {
        return (
          definition.kind !== 'OperationDefinition' ||
          definition.name.value === graphQLParams.operationName
        );
      }),
    };
  }

  const apolloObject = {
    query,
    variables: graphQLParams.variables,
    operationName: graphQLParams.operationName,
  };

  if (headers?.REQUEST_PATH) {
    apolloObject.context = {
      uri: headers?.REQUEST_PATH,
    };
  }

  return apolloClient.subscribe(apolloObject);
}

createRoot(graphiqlContainer).render(
  React.createElement(
    GraphiQL,
    { defaultQuery, fetcher: apolloFetcher, inputValueDeprecation: true },
    GraphiQLLogo,
  ),
);

Mousetrap.bind(keysFor(TOGGLE_PERFORMANCE_BAR), Shortcuts.onTogglePerfBar);
==== app/assets/javascripts/filterable_list.js ====
import $ from 'jquery';
import { debounce } from 'lodash';
import axios from './lib/utils/axios_utils';

/**
 * Makes search request for content when user types a value in the search input.
 * Updates the html content of the page with the received one.
 */

export default class FilterableList {
  // eslint-disable-next-line max-params
  constructor(form, filter, holder, filterInputField = 'filter_groups') {
    this.filterForm = form;
    this.listFilterElement = filter;
    this.listHolderElement = holder;
    this.filterInputField = filterInputField;
    this.isBusy = false;
  }

  getFilterEndpoint() {
    return this.getPagePath();
  }

  getPagePath() {
    const action = this.filterForm.getAttribute('action');
    // eslint-disable-next-line no-jquery/no-serialize
    const params = $(this.filterForm).serialize();
    return `${action}${action.indexOf('?') > 0 ? '&' : '?'}${params}`;
  }

  initSearch() {
    // Wrap to prevent passing event arguments to .filterResults;
    this.debounceFilter = debounce(this.onFilterInput.bind(this), 500);

    this.unbindEvents();
    this.bindEvents();
  }

  onFilterInput() {
    const $form = $(this.filterForm);
    const queryData = {};
    const filterGroupsParam = $form.find(`[name="${this.filterInputField}"]`).val();

    if (filterGroupsParam) {
      queryData[this.filterInputField] = filterGroupsParam;
    }

    this.filterResults(queryData);

    if (this.setDefaultFilterOption) {
      this.setDefaultFilterOption();
    }
  }

  bindEvents() {
    this.listFilterElement.addEventListener('input', this.debounceFilter);
  }

  unbindEvents() {
    this.listFilterElement.removeEventListener('input', this.debounceFilter);
  }

  filterResults(params) {
    if (this.isBusy) {
      return false;
    }

    $(this.listHolderElement).addClass('gl-opacity-5');

    this.isBusy = true;

    return axios
      .get(this.getFilterEndpoint(), {
        params,
      })
      .then((res) => {
        this.onFilterSuccess(res, params);
        this.onFilterComplete();
      })
      .catch(() => this.onFilterComplete());
  }

  onFilterSuccess(response, queryData) {
    if (response.data.html) {
      // eslint-disable-next-line no-unsanitized/property
      this.listHolderElement.innerHTML = response.data.html;
    }

    // Change url so if user reload a page - search results are saved
    const currentPath = this.getPagePath(queryData);

    return window.history.replaceState(
      {
        page: currentPath,
      },
      document.title,
      currentPath,
    );
  }

  onFilterComplete() {
    this.isBusy = false;
    $(this.listHolderElement).removeClass('gl-opacity-5');
  }
}
==== app/assets/javascripts/filtered_search/droplab/drop_down.js ====
import { SELECTED_CLASS, IGNORE_CLASS } from './constants';
import utils from './utils';

class DropDown {
  constructor(list, config = {}) {
    this.currentIndex = 0;
    this.hidden = true;
    this.list = typeof list === 'string' ? document.querySelector(list) : list;
    this.items = [];
    this.eventWrapper = {};
    this.hideOnClick = config.hideOnClick !== false;

    if (config.addActiveClassToDropdownButton) {
      this.dropdownToggle = this.list.parentNode.querySelector('.js-dropdown-toggle');
    }

    this.getItems();
    this.initTemplateString();
    this.addEvents();

    this.initialState = list.innerHTML;
  }

  getItems() {
    this.items = [].slice.call(this.list.querySelectorAll('li'));
    return this.items;
  }

  initTemplateString() {
    const items = this.items || this.getItems();

    let templateString = '';
    if (items.length > 0) templateString = items[items.length - 1].outerHTML;
    this.templateString = templateString;

    return this.templateString;
  }

  clickEvent(e) {
    if (e.target.tagName === 'UL') return;
    if (e.target.closest(`.${IGNORE_CLASS}`)) return;

    const selected = e.target.closest('li');
    if (!selected) return;

    this.addSelectedClass(selected);

    e.preventDefault();
    if (this.hideOnClick) {
      this.hide();
    }

    const listEvent = new CustomEvent('click.dl', {
      detail: {
        list: this,
        selected,
        data: e.target.dataset,
      },
    });
    this.list.dispatchEvent(listEvent);
  }

  addSelectedClass(selected) {
    this.removeSelectedClasses();
    selected.classList.add(SELECTED_CLASS);
  }

  removeSelectedClasses() {
    const items = this.items || this.getItems();

    items.forEach((item) => item.classList.remove(SELECTED_CLASS));
  }

  addEvents() {
    this.eventWrapper.clickEvent = this.clickEvent.bind(this);
    this.eventWrapper.closeDropdown = this.closeDropdown.bind(this);

    this.list.addEventListener('click', this.eventWrapper.clickEvent);
    this.list.addEventListener('keyup', this.eventWrapper.closeDropdown);
  }

  closeDropdown(event) {
    // `ESC` key closes the dropdown.
    if (event.keyCode === 27) {
      event.preventDefault();
      return this.toggle();
    }

    return true;
  }

  setData(data) {
    this.data = data;
    this.render(data);
  }

  addData(data) {
    this.data = (this.data || []).concat(data);
    this.render(this.data);
  }

  render(data) {
    const children = data ? data.map(this.renderChildren.bind(this)) : [];

    if (this.list.querySelector('.filter-dropdown-loading')) {
      return;
    }

    const renderableList = this.list.querySelector('ul[data-dynamic]') || this.list;
    // eslint-disable-next-line no-unsanitized/property
    renderableList.innerHTML = children.join('');

    const listEvent = new CustomEvent('render.dl', {
      detail: {
        list: this,
      },
    });
    this.list.dispatchEvent(listEvent);
  }

==== app/assets/javascripts/filtered_search/droplab/hook_button.js ====
import Hook from './hook';

class HookButton extends Hook {
  // eslint-disable-next-line max-params
  constructor(trigger, list, plugins, config) {
    super(trigger, list, plugins, config);

    this.type = 'button';
    this.event = 'click';

    this.eventWrapper = {};

    this.addEvents();
    this.addPlugins();
  }

  addPlugins() {
    this.plugins.forEach((plugin) => plugin.init(this));
  }

  clicked(e) {
    e.preventDefault();

    const buttonEvent = new CustomEvent('click.dl', {
      detail: {
        hook: this,
      },
      bubbles: true,
      cancelable: true,
    });
    e.target.dispatchEvent(buttonEvent);

    this.list.toggle();
  }

  addEvents() {
    this.eventWrapper.clicked = this.clicked.bind(this);
    this.trigger.addEventListener('click', this.eventWrapper.clicked);
  }

  removeEvents() {
    this.trigger.removeEventListener('click', this.eventWrapper.clicked);
  }

  restoreInitialState() {
    // eslint-disable-next-line no-unsanitized/property
    this.list.list.innerHTML = this.list.initialState;
  }

  removePlugins() {
    this.plugins.forEach((plugin) => plugin.destroy());
  }

  destroy() {
    this.restoreInitialState();

    this.removeEvents();
    this.removePlugins();
  }
}

export default HookButton;
==== app/assets/javascripts/filtered_search/droplab/hook_input.js ====
import Hook from './hook';

class HookInput extends Hook {
  // eslint-disable-next-line max-params
  constructor(trigger, list, plugins, config) {
    super(trigger, list, plugins, config);

    this.type = 'input';
    this.event = 'input';

    this.eventWrapper = {};

    this.addEvents();
    this.addPlugins();
  }

  addPlugins() {
    this.plugins.forEach((plugin) => plugin.init(this));
  }

  addEvents() {
    this.eventWrapper.mousedown = this.mousedown.bind(this);
    this.eventWrapper.input = this.input.bind(this);
    this.eventWrapper.keyup = this.keyup.bind(this);
    this.eventWrapper.keydown = this.keydown.bind(this);

    this.trigger.addEventListener('mousedown', this.eventWrapper.mousedown);
    this.trigger.addEventListener('input', this.eventWrapper.input);
    this.trigger.addEventListener('keyup', this.eventWrapper.keyup);
    this.trigger.addEventListener('keydown', this.eventWrapper.keydown);
  }

  removeEvents() {
    this.hasRemovedEvents = true;

    this.trigger.removeEventListener('mousedown', this.eventWrapper.mousedown);
    this.trigger.removeEventListener('input', this.eventWrapper.input);
    this.trigger.removeEventListener('keyup', this.eventWrapper.keyup);
    this.trigger.removeEventListener('keydown', this.eventWrapper.keydown);
  }

  input(e) {
    if (this.hasRemovedEvents) return;

    this.list.show();

    const inputEvent = new CustomEvent('input.dl', {
      detail: {
        hook: this,
        text: e.target.value,
      },
      bubbles: true,
      cancelable: true,
    });
    e.target.dispatchEvent(inputEvent);
  }

  mousedown(e) {
    if (this.hasRemovedEvents) return;

    const mouseEvent = new CustomEvent('mousedown.dl', {
      detail: {
        hook: this,
        text: e.target.value,
      },
      bubbles: true,
      cancelable: true,
    });
    e.target.dispatchEvent(mouseEvent);
  }

  keyup(e) {
    if (this.hasRemovedEvents) return;

    this.keyEvent(e, 'keyup.dl');
  }

  keydown(e) {
    if (this.hasRemovedEvents) return;

    this.keyEvent(e, 'keydown.dl');
  }

  keyEvent(e, eventName) {
    this.list.show();

    const keyEvent = new CustomEvent(eventName, {
      detail: {
        hook: this,
        text: e.target.value,
        which: e.which,
        key: e.key,
      },
      bubbles: true,
      cancelable: true,
    });
    e.target.dispatchEvent(keyEvent);
  }

  restoreInitialState() {
    // eslint-disable-next-line no-unsanitized/property
    this.list.list.innerHTML = this.list.initialState;
  }

  removePlugins() {
    this.plugins.forEach((plugin) => plugin.destroy());
  }

  destroy() {
    this.restoreInitialState();

    this.removeEvents();
    this.removePlugins();

    this.list.destroy();
  }
}

export default HookInput;
==== app/assets/javascripts/filtered_search/droplab/plugins/ajax_filter.js ====
/* eslint-disable */

import AjaxCache from '~/lib/utils/ajax_cache';
import { mergeUrlParams } from '~/lib/utils/url_utility';

const AjaxFilter = {
  init: function (hook) {
    this.destroyed = false;
    this.hook = hook;
    this.notLoading();

    this.eventWrapper = {};
    this.eventWrapper.debounceTrigger = this.debounceTrigger.bind(this);
    this.hook.trigger.addEventListener('keydown.dl', this.eventWrapper.debounceTrigger);
    this.hook.trigger.addEventListener('focus', this.eventWrapper.debounceTrigger);

    this.trigger(true);
  },

  notLoading: function notLoading() {
    this.loading = false;
  },

  debounceTrigger: function debounceTrigger(e) {
    var NON_CHARACTER_KEYS = [16, 17, 18, 20, 37, 38, 39, 40, 91, 93];
    var invalidKeyPressed = NON_CHARACTER_KEYS.indexOf(e.detail.which || e.detail.keyCode) > -1;
    var focusEvent = e.type === 'focus';
    if (invalidKeyPressed || this.loading) {
      return;
    }
    if (this.timeout) {
      clearTimeout(this.timeout);
    }
    this.timeout = setTimeout(this.trigger.bind(this, focusEvent), 200);
  },

  trigger: function trigger(getEntireList) {
    var config = this.hook.config.AjaxFilter;
    var searchValue = this.trigger.value;
    if (!config || !config.endpoint || !config.searchKey) {
      return;
    }
    if (config.searchValueFunction) {
      searchValue = config.searchValueFunction();
    }
    if (
      (config.loadingTemplate && this.hook.list.data === undefined) ||
      this.hook.list.data.length === 0
    ) {
      var dynamicList = this.hook.list.list.querySelector('[data-dynamic]');
      var loadingTemplate = document.createElement('div');
      loadingTemplate.innerHTML = config.loadingTemplate;
      loadingTemplate.setAttribute('data-loading-template', true);
      this.listTemplate = dynamicList.outerHTML;
      dynamicList.outerHTML = loadingTemplate.outerHTML;
    }
    if (getEntireList) {
      searchValue = '';
    }
    if (config.searchKey === searchValue) {
      return this.list.show();
    }
    this.loading = true;
    var params = config.params || {};
    params[config.searchKey] = searchValue;
    var url = mergeUrlParams(params, config.endpoint, { spreadArrays: true });
    return AjaxCache.retrieve(url)
      .then((data) => {
        this._loadData(data, config);
        if (config.onLoadingFinished) {
          config.onLoadingFinished(data);
        }
      })
      .catch(config.onError);
  },

  _loadData(data, config) {
    const list = this.hook.list;
    if ((config.loadingTemplate && list.data === undefined) || list.data.length === 0) {
      const dataLoadingTemplate = list.list.querySelector('[data-loading-template]');
      if (dataLoadingTemplate) {
        dataLoadingTemplate.outerHTML = this.listTemplate;
      }
    }
    if (!this.destroyed) {
      var hookListChildren = list.list.children;
      var onlyDynamicList =
        hookListChildren.length === 1 && hookListChildren[0].hasAttribute('data-dynamic');
      if (onlyDynamicList && data.length === 0) {
        list.hide();
      }
      list.setData.call(list, data);
    }
    this.notLoading();
    list.currentIndex = 0;
  },

  buildParams: function (params) {
    if (!params) return '';
    var paramsArray = Object.keys(params).map(function (param) {
      return param + '=' + (params[param] || '');
    });
    return '?' + paramsArray.join('&');
  },

  destroy: function destroy() {
    if (this.timeout) clearTimeout(this.timeout);
    this.destroyed = true;

    this.hook.trigger.removeEventListener('keydown.dl', this.eventWrapper.debounceTrigger);
    this.hook.trigger.removeEventListener('focus', this.eventWrapper.debounceTrigger);
  },
};

export default AjaxFilter;
==== app/assets/javascripts/filtered_search/droplab/plugins/ajax.js ====
/* eslint-disable */

import AjaxCache from '~/lib/utils/ajax_cache';

const Ajax = {
  _loadData: function _loadData(data, config, self) {
    if (config.loadingTemplate) {
      var dataLoadingTemplate = self.hook.list.list.querySelector('[data-loading-template]');
      if (dataLoadingTemplate) dataLoadingTemplate.outerHTML = self.listTemplate;
    }

    if (!self.destroyed) self.hook.list[config.method].call(self.hook.list, data);
  },
  preprocessing: function preprocessing(config, data) {
    let results = data;

    if (config.preprocessing && !data.preprocessed) {
      results = config.preprocessing(data);
      AjaxCache.override(config.endpoint, results);
    }

    return results;
  },
  init: function init(hook) {
    var self = this;
    self.destroyed = false;
    var config = hook.config.Ajax;
    this.hook = hook;
    if (!config || !config.endpoint || !config.method) {
      return;
    }
    if (config.method !== 'setData' && config.method !== 'addData') {
      return;
    }
    if (config.loadingTemplate) {
      var dynamicList = hook.list.list.querySelector('[data-dynamic]');
      var loadingTemplate = document.createElement('div');
      loadingTemplate.innerHTML = config.loadingTemplate;
      loadingTemplate.setAttribute('data-loading-template', '');
      this.listTemplate = dynamicList.outerHTML;
      dynamicList.outerHTML = loadingTemplate.outerHTML;
    }

    return AjaxCache.retrieve(config.endpoint)
      .then(self.preprocessing.bind(null, config))
      .then((data) => self._loadData(data, config, self))
      .catch(config.onError);
  },
  destroy: function () {
    this.destroyed = true;
  },
};

export default Ajax;
==== app/assets/javascripts/filtered_search/filtered_search_dropdown.js ====
import { loadingIconForLegacyJS } from '~/loading_icon_for_legacy_js';
import { FILTER_TYPE } from './constants';
import DropdownUtils from './dropdown_utils';
import FilteredSearchDropdownManager from './filtered_search_dropdown_manager';
import FilteredSearchVisualTokens from './filtered_search_visual_tokens';

const DATA_DROPDOWN_TRIGGER = 'data-dropdown-trigger';

export default class FilteredSearchDropdown {
  constructor({ droplab, dropdown, input, filter }) {
    this.droplab = droplab;
    this.hookId = input && input.id;
    this.input = input;
    this.filter = filter;
    this.dropdown = dropdown;
    this.loadingTemplate = `<div class="filter-dropdown-loading">
      ${loadingIconForLegacyJS().outerHTML}
    </div>`;
    this.bindEvents();
  }

  bindEvents() {
    this.itemClickedWrapper = this.itemClicked.bind(this);
    this.dropdown.addEventListener('click.dl', this.itemClickedWrapper);
  }

  unbindEvents() {
    this.dropdown.removeEventListener('click.dl', this.itemClickedWrapper);
  }

  getCurrentHook() {
    return this.droplab.hooks.filter((h) => h.id === this.hookId)[0] || null;
  }

  itemClicked(e, getValueFunction) {
    const { selected } = e.detail;
    if (selected.tagName === 'LI' && selected.innerHTML) {
      const { lastVisualToken: visualToken } =
        FilteredSearchVisualTokens.getLastVisualTokenBeforeInput();
      const { tokenOperator } = DropdownUtils.getVisualTokenValues(visualToken);

      const dataValueSet = DropdownUtils.setDataValueIfSelected(
        this.filter,
        tokenOperator,
        selected,
      );

      if (!dataValueSet) {
        const value = getValueFunction(selected);
        FilteredSearchDropdownManager.addWordToInput({
          tokenName: this.filter,
          tokenOperator,
          tokenValue: value,
          clicked: true,
        });
      }

      this.resetFilters();
      this.dismissDropdown();
      this.dispatchInputEvent();
    }
  }

  setAsDropdown() {
    this.input.setAttribute(DATA_DROPDOWN_TRIGGER, `#${this.dropdown.id}`);
  }

  setOffset(offset = 0) {
    if (window.innerWidth > 480) {
      this.dropdown.style.left = `${offset}px`;
    } else {
      this.dropdown.style.left = '0px';
    }
  }

  renderContent(forceShowList = false) {
    const currentHook = this.getCurrentHook();

    FilteredSearchDropdown.hideDropdownItemsforNotOperator(currentHook);

    if (forceShowList && currentHook && currentHook.list.hidden) {
      currentHook.list.show();
    }
  }

  render(forceRenderContent = false, forceShowList = false, hideNotEqual = false) {
    this.setAsDropdown();

    const currentHook = this.getCurrentHook();
    const firstTimeInitialized = currentHook === null;

    if (firstTimeInitialized || forceRenderContent) {
      this.renderContent(forceShowList, hideNotEqual);
    } else if (currentHook.list.list.id !== this.dropdown.id) {
      this.renderContent(forceShowList, hideNotEqual);
    }
  }

  dismissDropdown() {
    // Focusing on the input will dismiss dropdown
    // (default droplab functionality)
    this.input.focus();
  }

  dispatchInputEvent() {
    // Propagate input change to FilteredSearchDropdownManager
    // so that it can determine which dropdowns to open
    this.input.dispatchEvent(
      new CustomEvent('input', {
        bubbles: true,
        cancelable: true,
      }),
    );
  }

  dispatchFormSubmitEvent() {
    // dispatchEvent() is necessary as form.submit() does not
    // trigger event handlers
    this.input.form.dispatchEvent(new Event('submit'));
  }
==== app/assets/javascripts/filtered_search/filtered_search_visual_tokens.js ====
import { spriteIcon } from '~/lib/utils/common_utils';
import { objectToQuery } from '~/lib/utils/url_utility';
import { FILTERED_SEARCH_TERM } from '~/vue_shared/components/filtered_search_bar/constants';
import { __ } from '~/locale';
import FilteredSearchContainer from './container';
import VisualTokenValue from './visual_token_value';

export default class FilteredSearchVisualTokens {
  static permissibleOperatorValues = ['=', '!='];

  static getOperatorToken(value) {
    let token = null;

    FilteredSearchVisualTokens.permissibleOperatorValues.forEach((operatorToken) => {
      if (value.startsWith(operatorToken)) {
        token = operatorToken;
      }
    });

    return token;
  }

  static getValueToken(value) {
    let newValue = value;

    FilteredSearchVisualTokens.permissibleOperatorValues.forEach((operatorToken) => {
      if (value.startsWith(operatorToken)) {
        newValue = value.slice(operatorToken.length);
      }
    });

    return newValue;
  }

  static getLastVisualTokenBeforeInput() {
    const inputLi = FilteredSearchContainer.container.querySelector('.input-token');
    const lastVisualToken = inputLi && inputLi.previousElementSibling;

    return {
      lastVisualToken,
      isLastVisualTokenValid:
        lastVisualToken === null ||
        lastVisualToken.className.indexOf(FILTERED_SEARCH_TERM) !== -1 ||
        (lastVisualToken &&
          lastVisualToken.querySelector('.operator') !== null &&
          lastVisualToken.querySelector('.value') !== null),
    };
  }

  static unselectTokens() {
    const otherTokens = FilteredSearchContainer.container.querySelectorAll(
      '.js-visual-token .selectable.selected',
    );
    [].forEach.call(otherTokens, (t) => t.classList.remove('selected'));
  }

  static selectToken(tokenButton, forceSelection = false) {
    const selected = tokenButton.classList.contains('selected');
    FilteredSearchVisualTokens.unselectTokens();

    if (!selected || forceSelection) {
      tokenButton.classList.add('selected');
    }
  }

  static removeSelectedToken() {
    const selected = FilteredSearchContainer.container.querySelector('.js-visual-token .selected');

    if (selected) {
      const li = selected.closest('.js-visual-token');
      li.parentElement.removeChild(li);
    }
  }

  static createVisualTokenElementHTML(options = {}) {
    const {
      canEdit = true,
      hasOperator = false,
      uppercaseTokenName = false,
      capitalizeTokenValue = false,
    } = options;

    return `
      <div class="${canEdit ? 'selectable' : 'hidden'}" role="button">
        <div class="${uppercaseTokenName ? 'text-uppercase' : ''} name"></div>
        ${hasOperator ? '<div class="operator"></div>' : ''}
        <div class="value-container">
          <div class="${capitalizeTokenValue ? 'text-capitalize' : ''} value"></div>
          <div class="remove-token" role="button" aria-label="${__('Remove search filter')}">
            ${spriteIcon('close', 's16 close-icon')}
          </div>
        </div>
      </div>
    `;
  }

  // eslint-disable-next-line max-params
  static renderVisualTokenValue(parentElement, tokenName, tokenValue, tokenOperator) {
    const tokenType = tokenName.toLowerCase();
    const tokenValueContainer = parentElement.querySelector('.value-container');
    const tokenValueElement = tokenValueContainer.querySelector('.value');
    tokenValueElement.textContent = tokenValue;

    const visualTokenValue = new VisualTokenValue(tokenValue, tokenType, tokenOperator);

    visualTokenValue.render(tokenValueContainer, tokenValueElement);
  }

  static addVisualTokenElement({ name, operator, value, options = {} }) {
    const {
      isSearchTerm = false,
      canEdit,
      uppercaseTokenName,
      capitalizeTokenValue,
      tokenClass = `search-token-${name.toLowerCase()}`,
    } = options;
    const li = document.createElement('li');
    li.classList.add('js-visual-token');
    li.classList.add(isSearchTerm ? FILTERED_SEARCH_TERM : 'filtered-search-token');

==== app/assets/javascripts/filtered_search/visual_token_value.js ====
import { escape } from 'lodash';
import { USER_TOKEN_TYPES } from 'ee_else_ce/filtered_search/constants';
import * as Emoji from '~/emoji';
import FilteredSearchContainer from '~/filtered_search/container';
import DropdownUtils from '~/filtered_search/dropdown_utils';
import FilteredSearchVisualTokens from '~/filtered_search/filtered_search_visual_tokens';
import { createAlert } from '~/alert';
import AjaxCache from '~/lib/utils/ajax_cache';
import UsersCache from '~/lib/utils/users_cache';
import { __ } from '~/locale';
import { TOKEN_TYPE_LABEL } from '~/vue_shared/components/filtered_search_bar/constants';

export default class VisualTokenValue {
  constructor(tokenValue, tokenType, tokenOperator) {
    this.tokenValue = tokenValue;
    this.tokenType = tokenType;
    this.tokenOperator = tokenOperator;
  }

  render(tokenValueContainer, tokenValueElement) {
    const { tokenType, tokenValue } = this;

    if (['none', 'any'].includes(tokenValue.toLowerCase())) {
      return;
    }

    if (tokenType === TOKEN_TYPE_LABEL) {
      this.updateLabelTokenColor(tokenValueContainer);
    } else if (USER_TOKEN_TYPES.includes(tokenType)) {
      this.updateUserTokenAppearance(tokenValueContainer, tokenValueElement);
    } else if (tokenType === 'my-reaction') {
      this.updateEmojiTokenAppearance(tokenValueContainer, tokenValueElement);
    } else if (tokenType === 'epic') {
      this.updateEpicLabel(tokenValueContainer, tokenValueElement);
    }
  }

  updateUserTokenAppearance(tokenValueContainer, tokenValueElement) {
    const { tokenValue } = this;
    const username = this.tokenValue.replace(/^@/, '');

    return (
      UsersCache.retrieve(username)
        .then((user) => {
          if (!user) {
            return;
          }

          /* eslint-disable no-param-reassign */
          tokenValueContainer.dataset.originalValue = tokenValue;
          // eslint-disable-next-line no-unsanitized/property
          tokenValueElement.innerHTML = `
          <img class="avatar s16 !gl-mr-2" src="${user.avatar_url}" alt="">
          ${escape(user.name)}
        `;
          /* eslint-enable no-param-reassign */
        })
        // ignore error and leave username in the search bar
        .catch(() => {})
    );
  }

  updateLabelTokenColor(tokenValueContainer) {
    const { tokenValue } = this;
    const filteredSearchInput = FilteredSearchContainer.container.querySelector('.filtered-search');
    const { labelsEndpoint } = filteredSearchInput.dataset;
    const labelsEndpointWithParams = FilteredSearchVisualTokens.getEndpointWithQueryParams(
      `${labelsEndpoint}.json`,
      filteredSearchInput.dataset.endpointQueryParams,
    );

    return AjaxCache.retrieve(labelsEndpointWithParams)
      .then((labels) => {
        const matchingLabel = (labels || []).find(
          (label) => `~${DropdownUtils.getEscapedText(label.title)}` === tokenValue,
        );

        if (!matchingLabel) {
          return;
        }

        VisualTokenValue.setTokenStyle(
          tokenValueContainer,
          matchingLabel.color,
          matchingLabel.text_color,
        );
      })
      .catch(() =>
        createAlert({
          message: __('An error occurred while fetching label colors.'),
        }),
      );
  }

  updateEpicLabel(tokenValueContainer) {
    const tokenValue = this.tokenValue.replace(/^&/, '');
    const filteredSearchInput = FilteredSearchContainer.container.querySelector('.filtered-search');
    const { epicsEndpoint } = filteredSearchInput.dataset;
    const epicsEndpointWithParams = FilteredSearchVisualTokens.getEndpointWithQueryParams(
      `${epicsEndpoint}.json`,
      filteredSearchInput.dataset.endpointQueryParams,
    );

    return AjaxCache.retrieve(epicsEndpointWithParams)
      .then((epics) => {
        const matchingEpic = (epics || []).find((epic) => epic.id === Number(tokenValue));

        if (!matchingEpic) {
          return;
        }

        VisualTokenValue.replaceEpicTitle(tokenValueContainer, matchingEpic.title, matchingEpic.id);
      })
      .catch(() =>
        createAlert({
          message: __('An error occurred while adding formatted title for epic'),
        }),
      );
  }

==== app/assets/javascripts/glql/utils/copy_as_gfm.js ====
import { CopyAsGFM } from '~/behaviors/markdown/copy_as_gfm';

export async function copyGLQLNodeAsGFM(el) {
  const transform = (e) => {
    [...e.querySelectorAll('time[title]')].forEach((time) => {
      // eslint-disable-next-line no-param-reassign
      time.textContent = time.title;
    });
  };

  const div = document.createElement('div');
  div.appendChild(el.cloneNode(true));
  transform(div);

  const html = div.innerHTML;
  const markdown = await CopyAsGFM.nodeToGFM(el);

  const clipboardItem = new ClipboardItem({
    'text/plain': new Blob([markdown], { type: 'text/plain' }),
    'text/html': new Blob([html], { type: 'text/html' }),
  });

  navigator.clipboard.write([clipboardItem]);
}
==== app/assets/javascripts/homepage/components/activity_widget.vue ====
<script>
import { GlSkeletonLoader, GlCollapsibleListbox } from '@gitlab/ui';
import * as Sentry from '~/sentry/sentry_browser_wrapper';
import axios from '~/lib/utils/axios_utils';
import SafeHtml from '~/vue_shared/directives/safe_html';
import { localTimeAgo } from '~/lib/utils/datetime_utility';
import { s__ } from '~/locale';
import VisibilityChangeDetector from './visibility_change_detector.vue';

const MAX_EVENTS = 5;
const FILTER_OPTIONS = [
  {
    value: null,
    text: s__('HomepageActivityWidget|Your activity'),
  },
  {
    value: 'starred',
    text: s__('HomepageActivityWidget|Starred projects'),
  },
  {
    value: 'followed',
    text: s__('HomepageActivityWidget|Followed users'),
  },
];

export default {
  components: {
    GlSkeletonLoader,
    GlCollapsibleListbox,
    VisibilityChangeDetector,
  },
  directives: {
    SafeHtml,
  },
  props: {
    activityPath: {
      type: String,
      required: true,
    },
  },
  data() {
    return {
      activityFeedHtml: null,
      isLoading: true,
      hasError: false,
      filter: this.getPersistedFilter(),
    };
  },
  watch: {
    filter: {
      handler: 'onFilterChange',
      immediate: false,
    },
  },
  created() {
    this.reload();
  },
  methods: {
    getPersistedFilter() {
      try {
        const savedFilter = sessionStorage.getItem('homepage-activity-filter');
        const validValues = this.$options.FILTER_OPTIONS.map((option) => option.value);
        return validValues.includes(savedFilter) ? savedFilter : null;
      } catch (e) {
        return null;
      }
    },

    onFilterChange(newFilter) {
      try {
        if (newFilter === null) {
          sessionStorage.removeItem('homepage-activity-filter');
        } else {
          sessionStorage.setItem('homepage-activity-filter', newFilter);
        }
      } catch (e) {
        return null;
      }
      this.reload();
      return null;
    },

    async reload() {
      this.isLoading = true;

      try {
        /**
         * As part of this widget's first iteration, we have slightly changed how the `UsersController`
         * controller behaves so that it returns an empty response when the user has no activity and
         * the `is_personal_homepage` param is present. This is a temporary workaround until we can
         * move away from an HTML endpoint and handle empty states more gracefully in the client.
         * We'll need to remove the `is_personal_homepage` logic from `UsersController` once we have
         * a proper GraphQL endpoint here.
         */
        const url = this.filter
          ? `/dashboard/activity?limit=${MAX_EVENTS}&offset=0&filter=${this.filter}`
          : `/users/${encodeURIComponent(gon.current_username)}/activity?limit=${MAX_EVENTS}&is_personal_homepage=1`;
        const { data } = await axios.get(url);
        if (data?.html) {
          const parser = new DOMParser();
          const resp = parser.parseFromString(data.html, 'text/html');
          const timestamps = resp.querySelectorAll('.js-timeago');
          if (timestamps.length > 0) {
            localTimeAgo(timestamps);
          }
          this.activityFeedHtml = resp.body.innerHTML;
        }
      } catch (e) {
        Sentry.captureException(e);
        this.hasError = true;
      } finally {
        this.isLoading = false;
      }
    },
  },
  FILTER_OPTIONS,
};
</script>

<template>
==== app/assets/javascripts/image_diff/helpers/badge_helper.js ====
import { spriteIcon } from '~/lib/utils/common_utils';

export function createImageBadge(noteId, { x, y }, classNames = []) {
  const buttonEl = document.createElement('button');
  const classList = classNames.concat(['js-image-badge']);
  classList.forEach((className) => buttonEl.classList.add(className));
  buttonEl.setAttribute('type', 'button');
  buttonEl.setAttribute('disabled', true);
  buttonEl.dataset.noteId = noteId;
  buttonEl.style.left = `${x}px`;
  buttonEl.style.top = `${y}px`;

  return buttonEl;
}

export function addImageBadge(containerEl, { coordinate, badgeText, noteId }) {
  const buttonEl = createImageBadge(noteId, coordinate, [
    'gl-flex',
    'gl-items-center',
    'gl-justify-center',
    'gl-text-sm',
    'design-note-pin',
    'on-image',
    'gl-absolute',
  ]);
  buttonEl.textContent = badgeText;

  containerEl.appendChild(buttonEl);
}

export function addImageCommentBadge(containerEl, { coordinate, noteId }) {
  const buttonEl = createImageBadge(noteId, coordinate, ['image-comment-badge']);
  // eslint-disable-next-line no-unsanitized/property
  buttonEl.innerHTML = spriteIcon('image-comment-dark');

  containerEl.appendChild(buttonEl);
}

export function addAvatarBadge(el, event) {
  const { noteId, badgeNumber } = event.detail;

  // Add design pin to new comment
  const avatarBadgeEl = el.querySelector(`#${noteId} .design-note-pin`);
  avatarBadgeEl.textContent = badgeNumber;
  avatarBadgeEl.classList.remove('hidden');
}
==== app/assets/javascripts/image_diff/helpers/comment_indicator_helper.js ====
import { spriteIcon } from '~/lib/utils/common_utils';

export function addCommentIndicator(containerEl, { x, y }) {
  const buttonEl = document.createElement('button');
  buttonEl.classList.add('gl-border-0');
  buttonEl.classList.add('gl-bg-transparent');
  buttonEl.classList.add('comment-indicator');
  buttonEl.setAttribute('type', 'button');
  buttonEl.style.left = `${x}px`;
  buttonEl.style.top = `${y}px`;

  // eslint-disable-next-line no-unsanitized/property
  buttonEl.innerHTML = spriteIcon('image-comment-dark');

  containerEl.appendChild(buttonEl);
}

export function removeCommentIndicator(imageFrameEl) {
  const commentIndicatorEl = imageFrameEl.querySelector('.comment-indicator');
  const imageEl = imageFrameEl.querySelector('img');
  const willRemove = Boolean(commentIndicatorEl);
  let meta = {};

  if (willRemove) {
    meta = {
      x: parseInt(commentIndicatorEl.style.left, 10),
      y: parseInt(commentIndicatorEl.style.top, 10),
      image: {
        width: imageEl.width,
        height: imageEl.height,
      },
    };

    commentIndicatorEl.remove();
  }

  return { ...meta, removed: willRemove };
}

export function showCommentIndicator(imageFrameEl, coordinate) {
  const { x, y } = coordinate;
  const commentIndicatorEl = imageFrameEl.querySelector('.comment-indicator');

  if (commentIndicatorEl) {
    commentIndicatorEl.style.left = `${x}px`;
    commentIndicatorEl.style.top = `${y}px`;
  } else {
    addCommentIndicator(imageFrameEl, coordinate);
  }
}

export function commentIndicatorOnClick(event) {
  // Prevent from triggering onAddImageDiffNote in notes.js
  event.stopPropagation();

  const buttonEl = event.currentTarget;
  const diffViewerEl = buttonEl.closest('.diff-viewer');
  const textareaEl = diffViewerEl.querySelector('.note-container .note-textarea');
  textareaEl.focus();
}
==== app/assets/javascripts/init_deprecated_notes.js ====
import Notes from './deprecated_notes';

export default () => {
  const dataEl = document.querySelector('.js-notes-data');
  const { notesUrl, now, diffView, enableGFM } = JSON.parse(dataEl.innerHTML);

  // Create a singleton so that we don't need to assign
  // into the window object, we can just access the current isntance with Notes.instance
  Notes.initialize(notesUrl, now, diffView, enableGFM);
};
==== app/assets/javascripts/integrations/edit/index.js ====
import Vue from 'vue';
import { GlToast } from '@gitlab/ui';
import { convertObjectPropsToCamelCase, parseBoolean } from '~/lib/utils/common_utils';

import IntegrationForm from './components/integration_form.vue';
import { createStore } from './store';

Vue.use(GlToast);

function parseBooleanInData(data) {
  const result = {};
  Object.entries(data).forEach(([key, value]) => {
    result[key] = parseBoolean(value);
  });
  return result;
}

function parseDatasetToProps(data) {
  const {
    id,
    type,
    projectId,
    groupId,
    commentDetail,
    projectKey,
    projectKeys,
    learnMorePath,
    aboutPricingUrl,
    triggerEvents,
    sections,
    fields,
    inheritFromId,
    integrationLevel,
    cancelPath,
    testPath,
    resetPath,
    formPath,
    vulnerabilitiesIssuetype,
    jiraIssueTransitionAutomatic,
    jiraIssueTransitionId,
    jiraAllowedStatusesAsString,
    artifactRegistryPath,
    workloadIdentityFederationPath,
    workloadIdentityFederationProjectNumber,
    workloadIdentityPoolId,
    wlifIssuer,
    amazonQSubmitUrl,
    amazonQDisconnectUrl,
    amazonQRoleArn,
    amazonQAvailability,
    amazonQInstanceUid,
    amazonQAwsProviderUrl,
    amazonQAwsAudience,
    jwtClaims,
    redirectTo,
    upgradeSlackUrl,
    ...booleanAttributes
  } = data;
  const {
    manualActivation,
    activated,
    operating,
    activateDisabled,
    editable,
    canTest,
    commitEvents,
    mergeRequestEvents,
    enableComments,
    showJiraIssuesIntegration,
    showJiraVulnerabilitiesIntegration,
    enableJiraIssues,
    enableJiraVulnerabilities,
    jiraCheckEnabled,
    jiraExistsCheckEnabled,
    jiraAssigneeCheckEnabled,
    jiraStatusCheckEnabled,
    shouldUpgradeSlack,
    customizeJiraIssueEnabled,
    amazonQReady,
    amazonQAutoReviewEnabled,
  } = parseBooleanInData(booleanAttributes);

  return {
    initialActivated: activated,
    operating,
    manualActivation,
    activateDisabled,
    type,
    cancelPath,
    editable,
    canTest,
    testPath,
    resetPath,
    formPath,
    triggerFieldsProps: {
      initialTriggerCommit: commitEvents,
      initialTriggerMergeRequest: mergeRequestEvents,
      initialEnableComments: enableComments,
      initialCommentDetail: commentDetail,
      initialJiraIssueTransitionAutomatic: jiraIssueTransitionAutomatic,
      initialJiraIssueTransitionId: jiraIssueTransitionId,
    },
    jiraIssuesProps: {
      showJiraIssuesIntegration,
      showJiraVulnerabilitiesIntegration,
      initialEnableJiraIssues: enableJiraIssues,
      initialEnableJiraVulnerabilities: enableJiraVulnerabilities,
      initialVulnerabilitiesIssuetype: vulnerabilitiesIssuetype,
      initialProjectKey: projectKey,
      initialProjectKeys: projectKeys,
      initialCustomizeJiraIssueEnabled: customizeJiraIssueEnabled,
    },
    jiraVerificationProps: {
      showJiraIssuesIntegration,
      initialJiraCheckEnabled: jiraCheckEnabled,
      initialJiraExistsCheckEnabled: jiraExistsCheckEnabled,
      initialJiraAssigneeCheckEnabled: jiraAssigneeCheckEnabled,
      initialJiraStatusCheckEnabled: jiraStatusCheckEnabled,
      initialJiraAllowedStatusesAsString: jiraAllowedStatusesAsString,
    },
==== app/assets/javascripts/issues/show/components/description.vue ====
<!-- eslint-disable vue/multi-word-component-names -->
<script>
import { GlToast } from '@gitlab/ui';
import Sortable from 'sortablejs';
import Vue from 'vue';
import getIssueDetailsQuery from 'ee_else_ce/work_items/graphql/get_issue_details.query.graphql';
import SafeHtml from '~/vue_shared/directives/safe_html';
import { convertToGraphQLId } from '~/graphql_shared/utils';
import { TYPENAME_ISSUE, TYPENAME_WORK_ITEM } from '~/graphql_shared/constants';
import { createAlert } from '~/alert';
import { TYPE_ISSUE } from '~/issues/constants';
import { __, s__, sprintf } from '~/locale';
import { getSortableDefaultOptions, isDragging } from '~/sortable/utils';
import TaskList from '~/task_list';
import { addHierarchyChild, removeHierarchyChild } from '~/work_items/graphql/cache_utils';
import createWorkItemMutation from '~/work_items/graphql/create_work_item.mutation.graphql';
import deleteWorkItemMutation from '~/work_items/graphql/delete_work_item.mutation.graphql';
import namespaceWorkItemTypesQuery from '~/work_items/graphql/namespace_work_item_types.query.graphql';
import {
  I18N_WORK_ITEM_ERROR_CREATING,
  I18N_WORK_ITEM_ERROR_DELETING,
  NAME_TO_TEXT_LOWERCASE_MAP,
  WORK_ITEM_TYPE_NAME_TASK,
} from '~/work_items/constants';
import { renderGFM } from '~/behaviors/markdown/render_gfm';
import eventHub from '../event_hub';
import animateMixin from '../mixins/animate';
import {
  convertDescriptionWithNewSort,
  deleteTaskListItem,
  extractTaskTitleAndDescription,
  insertNextToTaskListItemText,
} from '../utils';
import TaskListItemActions from './task_list_item_actions.vue';

Vue.use(GlToast);

export default {
  directives: {
    SafeHtml,
  },
  mixins: [animateMixin],
  inject: ['fullPath', 'hasIterationsFeature'],
  props: {
    canUpdate: {
      type: Boolean,
      required: true,
    },
    descriptionHtml: {
      type: String,
      required: true,
    },
    descriptionText: {
      type: String,
      required: false,
      default: '',
    },
    issuableType: {
      type: String,
      required: false,
      default: TYPE_ISSUE,
    },
    updateUrl: {
      type: String,
      required: false,
      default: null,
    },
    lockVersion: {
      type: Number,
      required: false,
      default: 0,
    },
    issueId: {
      type: String,
      required: false,
      default: null,
    },
    isUpdating: {
      type: Boolean,
      required: false,
      default: false,
    },
  },
  data() {
    return {
      hasTaskListItemActions: false,
      preAnimation: false,
      pulseAnimation: false,
      initialUpdate: true,
      issueDetails: {},
      workItemTypes: [],
    };
  },
  apollo: {
    issueDetails: {
      query: getIssueDetailsQuery,
      variables() {
        return {
          id: convertToGraphQLId(TYPENAME_ISSUE, this.issueId),
        };
      },
      update: (data) => data.issue,
      skip() {
        return !this.canUpdate || !this.issueId;
      },
    },
    workItemTypes: {
      query: namespaceWorkItemTypesQuery,
      variables() {
        return {
          fullPath: this.fullPath,
        };
      },
      update(data) {
        return data.workspace?.workItemTypes?.nodes;
      },
      skip() {
        return !this.canUpdate;
      },
    },
==== app/assets/javascripts/issues/show/utils/update_description.js ====
/**
 * Function that replaces the open attribute for the <details> element.
 *
 * @param {String} descriptionHtml - The html string passed back from the server as a result of polling
 * @param {Array} details - All detail nodes inside of the issue description.
 */

const updateDescription = (descriptionHtml = '', details) => {
  let detailNodes = details;

  if (!details.length) {
    detailNodes = [];
  }

  const placeholder = document.createElement('div');
  // eslint-disable-next-line no-unsanitized/property
  placeholder.innerHTML = descriptionHtml;

  const newDetails = placeholder.getElementsByTagName('details');

  if (newDetails.length !== detailNodes.length) {
    return descriptionHtml;
  }

  Array.from(newDetails).forEach((el, i) => {
    /*
     * <details> has an open attribute that can have a value, "", "true", "false"
     * and will show the dropdown, which is why we are setting the attribute
     * explicitly to true.
     */
    if (detailNodes[i].open) el.setAttribute('open', true);
  });

  return placeholder.innerHTML;
};

export default updateDescription;
==== app/assets/javascripts/labels/labels_select.js ====
/* eslint-disable func-names, no-underscore-dangle, no-new, consistent-return, no-shadow, no-param-reassign, no-lonely-if, no-empty */
/* global Issuable */

import $ from 'jquery';
import { difference, isEqual, escape, sortBy, template, union } from 'lodash';
import initDeprecatedJQueryDropdown from '~/deprecated_jquery_dropdown';
import IssuableBulkUpdateActions from '~/issuable/issuable_bulk_update_actions';
import { isScopedLabel } from '~/lib/utils/common_utils';
import { createAlert } from '~/alert';
import axios from '~/lib/utils/axios_utils';
import { sprintf, __ } from '~/locale';
import CreateLabelDropdown from './create_label_dropdown';

export default class LabelsSelect {
  constructor(els, options = {}) {
    const _this = this;

    let $els = $(els);

    if (!els) {
      $els = $('.js-label-select');
    }

    $els.each((i, dropdown) => {
      const $dropdown = $(dropdown);
      const $dropdownContainer = $dropdown.closest('.labels-filter');
      const namespacePath = $dropdown.data('namespacePath');
      const projectPath = $dropdown.data('projectPath');
      const issueUpdateURL = $dropdown.data('issueUpdate');
      let selectedLabel = $dropdown.data('selected');
      if (selectedLabel != null && !$dropdown.hasClass('js-multiselect')) {
        selectedLabel = selectedLabel.split(',');
      }
      const showNo = $dropdown.data('showNo');
      const showAny = $dropdown.data('showAny');
      const showMenuAbove = $dropdown.data('showMenuAbove');
      const defaultLabel = $dropdown.data('defaultLabel') || __('Label');
      const abilityName = $dropdown.data('abilityName');
      const $selectbox = $dropdown.closest('.selectbox');
      const $block = $selectbox.closest('.block');
      const $form = $dropdown.closest('form, .js-issuable-update');
      const $sidebarCollapsedValue = $block.find('.sidebar-collapsed-icon span');
      const $value = $block.find('.value');
      const $loading = $block.find('.block-loading').addClass('gl-hidden');
      const fieldName = $dropdown.data('fieldName');
      let initialSelected = $selectbox
        .find(`input[name="${$dropdown.data('fieldName')}"]`)
        .map(function () {
          return this.value;
        })
        .get();
      const scopedLabels = $dropdown.data('scopedLabels');
      const { handleClick } = options;

      if ($dropdown.closest('.dropdown').find('.dropdown-new-label').length) {
        new CreateLabelDropdown(
          $dropdown.closest('.dropdown').find('.dropdown-new-label'),
          namespacePath,
          projectPath,
        );
      }

      const saveLabelData = function () {
        const selected = $dropdown
          .closest('.selectbox')
          .find(`input[name='${fieldName}']`)
          .map(function () {
            return this.value;
          })
          .get();

        if (isEqual(initialSelected, selected)) return;
        initialSelected = selected;

        const data = {};
        data[abilityName] = {};
        data[abilityName].label_ids = selected;
        if (!selected.length) {
          data[abilityName].label_ids = [''];
        }
        $loading.removeClass('gl-hidden');
        $dropdown.trigger('loading.gl.dropdown');
        axios
          .put(issueUpdateURL, data)
          .then(({ data }) => {
            let template;
            $loading.addClass('gl-hidden');
            $dropdown.trigger('loaded.gl.dropdown');
            $selectbox.hide();
            data.issueUpdateURL = issueUpdateURL;
            let labelCount = 0;
            if (data.labels.length && issueUpdateURL) {
              template = LabelsSelect.getLabelTemplate({
                labels: sortBy(data.labels, 'title'),
                issueUpdateURL,
                enableScopedLabels: scopedLabels,
              });
              labelCount = data.labels.length;

              // EE Specific
              if (IS_EE) {
                /**
                 * For Scoped labels, the last label selected with the
                 * same key will be applied to the current issuable.
                 *
                 * If these are the labels - priority::1, priority::2; and if
                 * we apply them in the same order, only priority::2 will stick
                 * with the issuable.
                 *
                 * In the current dropdown implementation, we keep track of all
                 * the labels selected via a hidden DOM element. Since a User
                 * can select priority::1 and priority::2 at the same time, the
                 * DOM will have 2 hidden input and the dropdown will show both
                 * the items selected but in reality server only applied
                 * priority::2.
                 *
                 * We find all the labels then find all the labels server accepted
                 * and then remove the excess ones.
                 */
                const toRemoveIds = Array.from(
==== app/assets/javascripts/lib/mermaid.js ====
import mermaid from 'mermaid';
import { getParameterByName } from '~/lib/utils/url_utility';
import { resetServiceWorkersPublicPath } from '~/lib/utils/webpack';

const resetWebpackPublicPath = () => {
  window.gon = { relative_url_root: getParameterByName('relativeRootPath') };
  resetServiceWorkersPublicPath();
};

resetWebpackPublicPath();
const setIframeRenderedSize = (h, w) => {
  const { origin } = window.location;
  window.parent.postMessage({ h, w }, origin);
};

const drawDiagram = async (source) => {
  const element = document.getElementById('app');
  const insertSvg = (svgCode) => {
    // eslint-disable-next-line no-unsanitized/property
    element.innerHTML = svgCode;

    element.firstElementChild.removeAttribute('height');
    const { height, width } = element.firstElementChild.getBoundingClientRect();

    setIframeRenderedSize(height, width);
  };

  const { svg } = await mermaid.mermaidAPI.render('mermaid', source);
  insertSvg(svg);
};

const darkModeEnabled = () => getParameterByName('darkMode') === 'true';

const initMermaid = () => {
  let theme = 'neutral';

  if (darkModeEnabled()) {
    theme = 'dark';
  }

  mermaid.initialize({
    // mermaid core options
    mermaid: {
      startOnLoad: false,
    },
    // mermaidAPI options
    theme,
    flowchart: {
      useMaxWidth: true,
      htmlLabels: true,
    },
    secure: ['secure', 'securityLevel', 'startOnLoad', 'maxTextSize', 'htmlLabels'],
    securityLevel: 'strict',
    dompurifyConfig: {
      ADD_TAGS: ['foreignObject'],
      HTML_INTEGRATION_POINTS: { foreignobject: true },
    },
  });
};

const addListener = () => {
  window.addEventListener(
    'message',
    (event) => {
      if (event.origin !== window.location.origin) {
        return;
      }
      drawDiagram(event.data);
    },
    false,
  );
};

addListener();
initMermaid();
export default {};
==== app/assets/javascripts/lib/utils/highlight.js ====
import fuzzaldrinPlus from 'fuzzaldrin-plus';
import { sanitize } from '~/lib/dompurify';

/**
 * Wraps substring matches with HTML `<span>` elements.
 * Inputs are sanitized before highlighting, so this
 * filter is safe to use with `v-html` (as long as `matchPrefix`
 * and `matchSuffix` are not being dynamically generated).
 *
 * Note that this function can't be used inside `v-html` as a filter
 * (Vue filters cannot be used inside `v-html`).
 *
 * @param {String} string The string to highlight
 * @param {String} match The substring match to highlight in the string
 * @param {String} matchPrefix The string to insert at the beginning of a match
 * @param {String} matchSuffix The string to insert at the end of a match
 */
// eslint-disable-next-line max-params
export default function highlight(string, match = '', matchPrefix = '<b>', matchSuffix = '</b>') {
  if (!string) {
    return '';
  }

  if (!match) {
    return sanitize(string.toString(), { ALLOWED_TAGS: [] });
  }

  const sanitizedValue = sanitize(string.toString(), { ALLOWED_TAGS: [] });

  // occurrences is an array of character indices that should be
  // highlighted in the original string, i.e. [3, 4, 5, 7]
  const occurrences = fuzzaldrinPlus.match(sanitizedValue, match.toString());

  return sanitizedValue
    .split('')
    .map((character, i) => {
      if (occurrences.includes(i)) {
        return `${matchPrefix}${character}${matchSuffix}`;
      }

      return character;
    })
    .join('');
}
==== app/assets/javascripts/lib/utils/text_utility.js ====
import { isString, memoize } from 'lodash';
import { sprintf, __ } from '~/locale';
import { base64ToBuffer, bufferToBase64 } from '~/authentication/webauthn/util';
import {
  TRUNCATE_WIDTH_DEFAULT_WIDTH,
  TRUNCATE_WIDTH_DEFAULT_FONT_SIZE,
} from '~/lib/utils/constants';

export const COLON = ':';
export const HYPHEN = '-';
export const NEWLINE = '\n';

/**
 * Adds a , to a string composed by numbers, at every 3 chars.
 *
 * 2333 -> 2,333
 * 232324 -> 232,324
 *
 * @param {String} text
 * @returns {String}
 */
export const addDelimiter = (text) =>
  text ? text.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',') : text;

/**
 * Returns '99+' for numbers bigger than 99.
 *
 * @param {Number} count
 * @return {Number|String}
 */
export const highCountTrim = (count) => (count > 99 ? '99+' : count);

/**
 * Converts first char to uppercase and replaces the given separator with spaces
 * @param {String} string - The string to humanize
 * @param {String} separator - The separator used to separate words (defaults to "_")
 * @requires {String}
 * @returns {String}
 */
export const humanize = (string, separator = '_') => {
  const replaceRegex = new RegExp(separator, 'g');

  return string.charAt(0).toUpperCase() + string.replace(replaceRegex, ' ').slice(1);
};

/**
 * Replaces underscores with dashes
 * @param {*} str
 * @returns {String}
 */
export const dasherize = (str) => str.replace(/[_\s]+/g, '-');

/**
 * Replaces whitespace and non-sluggish characters with a given separator
 * @param {String} str - The string to slugify
 * @param {String=} separator - The separator used to separate words (defaults to "-")
 * @returns {String}
 */
export const slugify = (str, separator = '-') => {
  const slug = str
    .trim()
    .toLowerCase()
    .replace(/[^a-zA-Z0-9_.-]+/g, separator)
    // Remove any duplicate separators or separator prefixes/suffixes
    .split(separator)
    .filter(Boolean)
    .join(separator);

  return slug === separator ? '' : slug;
};

/**
 * Replaces whitespace and non-sluggish characters with underscores
 * @param {String} str
 * @returns {String}
 */
export const slugifyWithUnderscore = (str) => slugify(str, '_');

/**
 * Truncates given text
 *
 * @param {String} string
 * @param {Number} maxLength
 * @returns {String}
 */
export const truncate = (string, maxLength) => {
  if (string.length - 1 > maxLength) {
    return `${string.substr(0, maxLength - 1)}`;
  }

  return string;
};

/**
 * This function calculates the average char width. It does so by placing a string in the DOM and measuring the width.
 * NOTE: This will cause a reflow and should be used sparsely!
 * The default fontFamily is 'sans-serif' and 12px in ECharts, so that is the default basis for calculating the average with.
 * https://echarts.apache.org/en/option.html#xAxis.nameTextStyle.fontFamily
 * https://echarts.apache.org/en/option.html#xAxis.nameTextStyle.fontSize
 * @param  {Object} options
 * @param  {Number} options.fontSize style to size the text for measurement
 * @param  {String} options.fontFamily style of font family to measure the text with
 * @param  {String} options.chars string of chars to use as a basis for calculating average width
 * @return {Number}
 */
const getAverageCharWidth = memoize((options = {}) => {
  const {
    fontSize = 12,
    fontFamily = 'sans-serif',
    // eslint-disable-next-line @gitlab/require-i18n-strings
    chars = ' ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',
  } = options;
  const div = document.createElement('div');

  div.style.fontFamily = fontFamily;
  div.style.fontSize = `${fontSize}px`;
  // Place outside of view
  div.style.position = 'absolute';
  div.style.left = -1000;
  div.style.top = -1000;
==== app/assets/javascripts/merge_request_tabs.js ====
/* eslint-disable class-methods-use-this */
import $ from 'jquery';
import Vue from 'vue';
import VueApollo from 'vue-apollo';
import createDefaultClient from '~/lib/graphql';
import { createAlert } from '~/alert';
import {
  getCookie,
  isMetaClick,
  NO_SCROLL_TO_HASH_CLASS,
  parseBoolean,
  scrollToElement,
} from '~/lib/utils/common_utils';
import { parseUrlPathname, visitUrl } from '~/lib/utils/url_utility';
import createEventHub from '~/helpers/event_hub_factory';
import { renderGFM } from '~/behaviors/markdown/render_gfm';
import BlobForkSuggestion from './blob/blob_fork_suggestion';
import Diff from './diff';
import { initDiffStatsDropdown } from './init_diff_stats_dropdown';
import axios from './lib/utils/axios_utils';

import { localTimeAgo } from './lib/utils/datetime_utility';
import { isInVueNoteablePage } from './lib/utils/dom_utils';
import { __, s__ } from './locale';
import syntaxHighlight from './syntax_highlight';

Vue.use(VueApollo);

const apolloProvider = new VueApollo({
  defaultClient: createDefaultClient(),
});

// MergeRequestTabs
//
// Handles persisting and restoring the current tab selection and lazily-loading
// content on the MergeRequests#show page.
//
// ### Example Markup
//
//   <ul class="nav-links merge-request-tabs">
//     <li class="notes-tab active">
//       <a data-action="notes" data-target="#notes" data-toggle="tab" href="/foo/bar/-/merge_requests/1">
//         Discussion
//       </a>
//     </li>
//     <li class="commits-tab">
//       <a data-action="commits" data-target="#commits" data-toggle="tab" href="/foo/bar/-/merge_requests/1/commits">
//         Commits
//       </a>
//     </li>
//     <li class="diffs-tab">
//       <a data-action="diffs" data-target="#diffs" data-toggle="tab" href="/foo/bar/-/merge_requests/1/diffs">
//         Diffs
//       </a>
//     </li>
//   </ul>
//
//   <div class="tab-content">
//     <div class="notes tab-pane active" id="notes">
//       Notes Content
//     </div>
//     <div class="commits tab-pane" id="commits">
//       Commits Content
//     </div>
//     <div class="diffs tab-pane" id="diffs">
//       Diffs Content
//     </div>
//   </div>
//
//   <div class="mr-loading-status">
//     <div class="loading">
//       Loading Animation
//     </div>
//   </div>
//

// <100ms is typically indistinguishable from "instant" for users, but allows for re-rendering
const FAST_DELAY_FOR_RERENDER = 75;
// Store the `location` object, allowing for easier stubbing in tests
let { location } = window;

function scrollToContainer(container) {
  if (location.hash) {
    const $el = $(`${container} ${location.hash}:not(.match)`);

    if ($el.length) {
      scrollToElement($el[0]);
    }
  }
}

function mountPipelines() {
  const pipelineTableViewEl = document.querySelector('#commit-pipeline-table-view');
  const { mrWidgetData } = gl;
  const table = new Vue({
    components: {
      MergeRequestPipelinesTable: () => {
        return gon.features.mrPipelinesGraphql
          ? import('~/ci/merge_requests/components/pipelines_table_wrapper.vue')
          : import('~/commit/pipelines/legacy_pipelines_table_wrapper.vue');
      },
    },
    apolloProvider,
    provide: {
      artifactsEndpoint: pipelineTableViewEl.dataset.artifactsEndpoint,
      artifactsEndpointPlaceholder: pipelineTableViewEl.dataset.artifactsEndpointPlaceholder,
      targetProjectFullPath: mrWidgetData?.target_project_full_path || '',
      fullPath: pipelineTableViewEl.dataset.fullPath,
      graphqlPath: pipelineTableViewEl.dataset.graphqlPath,
      manualActionsLimit: 50,
      mergeRequestId: mrWidgetData ? mrWidgetData.iid : null,
      sourceProjectFullPath: mrWidgetData?.source_project_full_path || '',
      useFailedJobsWidget: true,
    },
    render(createElement) {
      return createElement('merge-request-pipelines-table', {
        props: {
          endpoint: pipelineTableViewEl.dataset.endpoint,
          emptyStateSvgPath: pipelineTableViewEl.dataset.emptyStateSvgPath,
          errorStateSvgPath: pipelineTableViewEl.dataset.errorStateSvgPath,
==== app/assets/javascripts/milestones/milestone.js ====
import { createAlert } from '~/alert';
import { sanitize } from '~/lib/dompurify';
import axios from '~/lib/utils/axios_utils';
import { __ } from '~/locale';
import { GlTabsBehavior, TAB_SHOWN_EVENT, HISTORY_TYPE_HASH } from '~/tabs';

export default class Milestone {
  constructor() {
    this.tabsEl = document.querySelector('.js-milestone-tabs');
    this.loadedTabs = new WeakSet();

    this.bindTabsSwitching();
    // eslint-disable-next-line no-new
    new GlTabsBehavior(this.tabsEl, { history: HISTORY_TYPE_HASH });
  }

  bindTabsSwitching() {
    this.tabsEl.addEventListener(TAB_SHOWN_EVENT, (event) => {
      const tab = event.target;
      const { activeTabPanel } = event.detail;
      this.loadTab(tab, activeTabPanel);
    });
  }

  loadTab(tab, tabPanel) {
    const { endpoint } = tab.dataset;

    if (endpoint && !this.loadedTabs.has(tab)) {
      axios
        .get(endpoint)
        .then(({ data }) => {
          // eslint-disable-next-line no-param-reassign
          tabPanel.innerHTML = sanitize(data.html);
          this.loadedTabs.add(tab);
        })
        .catch(() =>
          createAlert({
            message: __('Error loading milestone tab'),
          }),
        );
    }
  }
}
==== app/assets/javascripts/new_branch_form.js ====
/* eslint-disable func-names, no-return-assign, @gitlab/require-i18n-strings */

const NAME_ERROR_CLASS = 'gl-border-red-500';

export default class NewBranchForm {
  constructor(form) {
    this.validate = this.validate.bind(this);
    this.branchNameError = form.querySelector('.js-branch-name-error');
    this.name = form.querySelector('.js-branch-name');
    this.setupRestrictions();
    this.addBinding();
    this.init();
  }

  addBinding() {
    this.name.addEventListener('change', this.validate);
  }

  init() {
    if (this.name != null && this.name.value.length > 0) {
      const event = new CustomEvent('change');
      this.name.dispatchEvent(event);
    }
  }

  setupRestrictions() {
    const startsWith = {
      pattern: /^(\/|\.)/g,
      prefix: 'Branch name cannot start with',
      conjunction: 'or',
    };
    const endsWith = {
      pattern: /(\/|\.|\.lock)$/g,
      prefix: 'Branch name cannot end in',
      conjunction: 'or',
    };
    const invalid = {
      pattern: /(\s|~|\^|:|\?|\*|\[|\\|\.\.|@\{|\/{2,}){1}/g,
      prefix: 'Branch name cannot contain',
      conjunction: ' or ',
    };
    const single = {
      pattern: /^@+$/g,
      prefix: 'Branch name cannot be',
      conjunction: 'or',
    };
    return (this.restrictions = [startsWith, invalid, endsWith, single]);
  }

  validate() {
    const { indexOf } = [];

    this.branchNameError.innerHTML = '';
    const unique = function (values, value) {
      if (indexOf.call(values, value) === -1) {
        values.push(value);
      }
      return values;
    };
    const formatter = function (values, restriction) {
      const formatted = values.map((value) => {
        switch (false) {
          case !/\s/.test(value):
            return 'spaces';
          case !/\/{2,}/g.test(value):
            return 'consecutive slashes';
          default:
            return `'${value}'`;
        }
      });
      return `${restriction.prefix} ${formatted.join(restriction.conjunction)}`;
    };
    const validator = (errors, restriction) => {
      const matched = this.name.value.match(restriction.pattern);
      if (matched) {
        return errors.concat(formatter(matched.reduce(unique, []), restriction));
      }
      return errors;
    };
    const errors = this.restrictions.reduce(validator, []);
    if (errors.length > 0) {
      this.branchNameError.textContent = errors.join('. ');
      this.name.classList.add(NAME_ERROR_CLASS);
      this.name.focus();
    } else {
      this.name.classList.remove(NAME_ERROR_CLASS);
    }
  }
}
==== app/assets/javascripts/notebook/cells/output/latex.vue ====
<script>
import SafeHtml from '~/vue_shared/directives/safe_html';
import 'mathjax/es5/tex-svg';
import Prompt from '../prompt.vue';

export default {
  name: 'LatexOutput',
  components: {
    Prompt,
  },
  directives: {
    SafeHtml,
  },
  props: {
    count: {
      type: Number,
      required: true,
    },
    rawCode: {
      type: String,
      required: true,
    },
    index: {
      type: Number,
      required: true,
    },
  },
  computed: {
    code() {
      // MathJax will not parse out the inline delimeters "$$" correctly
      // so we remove them from the raw code itself
      const parsedCode = this.rawCode.replace(/\$\$/g, '');
      const svg = window.MathJax.tex2svg(parsedCode);

      // NOTE: This is used with `v-html` and not `v-safe-html` due to an
      // issue with dompurify stripping out xlink attributes from use tags
      return svg.outerHTML;
    },
  },
  safeHtmlConfig: {
    // to support SVGs and custom tags for mathjax
    ADD_TAGS: ['use', 'mjx-container', 'mjx-tool', 'mjx-status', 'mjx-tip'],
  },
};
</script>

<template>
  <div class="output">
    <prompt type="Out" :count="count" :show-output="index === 0" />
    <div ref="maths" v-safe-html:[$options.safeHtmlConfig]="code"></div>
  </div>
</template>
==== app/assets/javascripts/pages/admin/application_settings/payload_previewer.js ====
import { createAlert } from '~/alert';
import axios from '~/lib/utils/axios_utils';
import { __ } from '~/locale';

export default class PayloadPreviewer {
  constructor(trigger) {
    this.trigger = trigger;
    this.isVisible = false;
    this.isInserted = false;
  }

  init() {
    this.spinner = this.trigger.querySelector('.js-spinner');
    this.text = this.trigger.querySelector('.js-text');

    this.trigger.addEventListener('click', (event) => {
      event.preventDefault();

      if (this.isVisible) return this.hidePayload();

      return this.requestPayload();
    });
  }

  getContainer() {
    return document.querySelector(this.trigger.dataset.payloadSelector);
  }

  requestPayload() {
    if (this.isInserted) return this.showPayload();

    this.spinner.classList.add('gl-inline');

    const container = this.getContainer();

    return axios
      .get(container.dataset.endpoint, {
        responseType: 'text',
      })
      .then(({ data }) => {
        this.spinner.classList.remove('gl-inline');
        this.insertPayload(data);
      })
      .catch(() => {
        this.spinner.classList.remove('gl-inline');
        createAlert({
          message: __('Error fetching payload data.'),
        });
      });
  }

  hidePayload() {
    this.isVisible = false;
    this.getContainer().classList.add('gl-hidden');
    this.text.textContent = __('Preview payload');
  }

  showPayload() {
    this.isVisible = true;
    this.getContainer().classList.remove('gl-hidden');
    this.text.textContent = __('Hide payload');
  }

  insertPayload(data) {
    this.isInserted = true;

    // eslint-disable-next-line no-unsanitized/property
    this.getContainer().innerHTML = data;
    this.showPayload();
  }
}
==== app/assets/javascripts/pages/projects/shared/permissions/gitlab_duo_settings.js ====
import Vue from 'vue';
import { convertObjectPropsToCamelCase } from '~/lib/utils/common_utils';
import GitlabDuoSettings from './components/gitlab_duo_settings.vue';

export default function initGitlabDuoSettings() {
  const mountPoint = document.querySelector('.js-gitlab-duo-settings-form');
  const componentPropsEl = document.querySelector('.js-gitlab-duo-settings-form-data');

  if (!mountPoint) {
    return null;
  }

  const componentProps = JSON.parse(componentPropsEl.innerHTML);
  const componentPropsParsed = convertObjectPropsToCamelCase(componentProps, {
    deep: true,
  });
  const { targetFormId } = mountPoint.dataset;

  return new Vue({
    el: mountPoint,
    name: 'GitlabDuoSettingsRoot',
    render: (createElement) =>
      createElement(GitlabDuoSettings, {
        props: componentPropsParsed,
        on: {
          confirm: () => {
            if (targetFormId) document.getElementById(targetFormId)?.submit();
          },
        },
      }),
  });
}
==== app/assets/javascripts/pages/projects/shared/permissions/index.js ====
import Vue from 'vue';
import VueApollo from 'vue-apollo';
import createDefaultClient from '~/lib/graphql';
import { parseBoolean, convertObjectPropsToCamelCase } from '~/lib/utils/common_utils';
import settingsPanel from './components/settings_panel.vue';

Vue.use(VueApollo);

export default function initProjectPermissionsSettings() {
  const apolloProvider = new VueApollo({
    defaultClient: createDefaultClient(),
  });

  const mountPoint = document.querySelector('.js-project-permissions-form');
  const componentPropsEl = document.querySelector('.js-project-permissions-form-data');

  if (!mountPoint) return null;

  const componentProps = JSON.parse(componentPropsEl.innerHTML);

  const {
    additionalInformation,
    cascadingSettingsData,
    confirmButtonText,
    confirmDangerMessage,
    htmlConfirmationMessage,
    showVisibilityConfirmModal,
    targetFormId,
    phrase: confirmationPhrase,
  } = mountPoint.dataset;

  let cascadingSettingsDataParsed;

  try {
    cascadingSettingsDataParsed = convertObjectPropsToCamelCase(JSON.parse(cascadingSettingsData), {
      deep: true,
    });
  } catch {
    cascadingSettingsDataParsed = null;
  }

  return new Vue({
    el: mountPoint,
    name: 'ProjectPermissionsRoot',
    apolloProvider,
    provide: {
      additionalInformation,
      cascadingSettingsData: cascadingSettingsDataParsed,
      confirmDangerMessage,
      confirmButtonText,
      htmlConfirmationMessage: parseBoolean(htmlConfirmationMessage),
    },
    render: (createElement) =>
      createElement(settingsPanel, {
        props: {
          ...componentProps,
          confirmationPhrase,
          showVisibilityConfirmModal: parseBoolean(showVisibilityConfirmModal),
        },
        on: {
          confirm: () => {
            if (targetFormId) document.getElementById(targetFormId)?.submit();
          },
        },
      }),
  });
}
==== app/assets/javascripts/pages/users/user_overview_block.js ====
import axios from '~/lib/utils/axios_utils';

const DEFAULT_LIMIT = 20;

export default class UserOverviewBlock {
  constructor(options = {}) {
    this.container = options.container;
    this.url = options.url;
    this.requestParams = {
      limit: DEFAULT_LIMIT,
      ...options.requestParams,
    };
    this.postRenderCallback = options.postRenderCallback;
    this.loadData();
  }

  loadData() {
    const containerEl = document.querySelector(this.container);
    const loadingEl = containerEl.querySelector(`.loading`);

    loadingEl.classList.remove('hide');

    axios
      .get(this.url, {
        params: this.requestParams,
      })
      .then(({ data }) => this.render(data))
      .catch(() => loadingEl.classList.add('hide'));
  }

  render(data) {
    const { html, count } = data;
    const containerEl = document.querySelector(this.container);
    const contentList = containerEl.querySelector('.overview-content-list');

    // eslint-disable-next-line no-unsanitized/property
    contentList.innerHTML += html;

    const loadingEl = containerEl.querySelector('.loading');

    if (count && count > 0) {
      containerEl.querySelector('.js-view-all').classList.remove('hide');
    } else {
      const nothingHereBlock = containerEl.querySelector('.nothing-here-block');

      if (nothingHereBlock) {
        nothingHereBlock.classList.add('p-5');
      }
    }

    loadingEl.classList.add('hide');

    if (this.postRenderCallback) {
      this.postRenderCallback.call(this);
    }
  }
}
==== app/assets/javascripts/projects/new/components/app.vue ====
<script>
import PROJECT_CREATE_FROM_TEMPLATE_SVG_URL from '@gitlab/svgs/dist/illustrations/project-create-from-template-sm.svg?url';
import PROJECT_CREATE_NEW_SVG_URL from '@gitlab/svgs/dist/illustrations/project-create-new-sm.svg?url';
import PROJECT_IMPORT_SVG_URL from '@gitlab/svgs/dist/illustrations/project-import-sm.svg?url';
import PROJECT_RUN_CICD_PIPELINES_SVG_URL from '@gitlab/svgs/dist/illustrations/empty-state/empty-devops-md.svg?url';
import SafeHtml from '~/vue_shared/directives/safe_html';
import { s__ } from '~/locale';
import NewNamespacePage from '~/vue_shared/new_namespace/new_namespace_page.vue';
import NewProjectPushTipPopover from './new_project_push_tip_popover.vue';

const CI_CD_PANEL = 'cicd_for_external_repo';
const IMPORT_PROJECT_PANEL = 'import_project';
const PANELS = [
  {
    key: 'blank',
    name: 'blank_project',
    selector: '#blank-project-pane',
    title: s__('ProjectsNew|Create blank project'),
    description: s__(
      'ProjectsNew|Create a blank project to store your files, plan your work, and collaborate on code, among other things.',
    ),
    imageSrc: PROJECT_CREATE_NEW_SVG_URL,
  },
  {
    key: 'template',
    name: 'create_from_template',
    selector: '#create-from-template-pane',
    title: s__('ProjectsNew|Create from template'),
    description: s__(
      'ProjectsNew|Create a project pre-populated with the necessary files to get you started quickly.',
    ),
    imageSrc: PROJECT_CREATE_FROM_TEMPLATE_SVG_URL,
  },
  {
    key: 'import',
    name: IMPORT_PROJECT_PANEL,
    selector: '#import-project-pane',
    title: s__('ProjectsNew|Import project'),
    description: s__(
      'ProjectsNew|Migrate your data from an external source like GitHub, Bitbucket, or another instance of GitLab.',
    ),
    imageSrc: PROJECT_IMPORT_SVG_URL,
  },
  {
    key: 'ci',
    name: CI_CD_PANEL,
    selector: '#ci-cd-project-pane',
    title: s__('ProjectsNew|Run CI/CD for external repository'),
    description: s__('ProjectsNew|Connect your external repository to GitLab CI/CD.'),
    imageSrc: PROJECT_RUN_CICD_PIPELINES_SVG_URL,
  },
];

export default {
  components: {
    NewNamespacePage,
    NewProjectPushTipPopover,
  },
  directives: {
    SafeHtml,
  },
  props: {
    rootPath: {
      type: String,
      required: true,
    },
    projectsUrl: {
      type: String,
      required: true,
    },
    parentGroupUrl: {
      type: String,
      required: false,
      default: null,
    },
    parentGroupName: {
      type: String,
      required: false,
      default: '',
    },
    hasErrors: {
      type: Boolean,
      required: false,
      default: false,
    },
    isCiCdAvailable: {
      type: Boolean,
      required: false,
      default: false,
    },
    newProjectGuidelines: {
      type: String,
      required: false,
      default: '',
    },
    canImportProjects: {
      type: Boolean,
      required: false,
      default: true,
    },
  },

  computed: {
    initialBreadcrumbs() {
      const breadcrumbs = this.parentGroupUrl
        ? [{ text: this.parentGroupName, href: this.parentGroupUrl }]
        : [
            { text: s__('Navigation|Your work'), href: this.rootPath },
            { text: s__('ProjectsNew|Projects'), href: this.projectsUrl },
          ];
      breadcrumbs.push({ text: s__('ProjectsNew|New project'), href: '#' });
      return breadcrumbs;
    },
    availablePanels() {
      if (this.isCiCdAvailable && this.canImportProjects) {
        return PANELS;
      }

      return PANELS.filter((panel) => {
        if (!this.canImportProjects && panel.name === IMPORT_PROJECT_PANEL) {
==== app/assets/javascripts/projects/project_visibility.js ====
import { escape } from 'lodash';
import { __, sprintf } from '~/locale';
import eventHub from '~/projects/new/event_hub';
import { VISIBILITY_LEVELS_STRING_TO_INTEGER } from '~/visibility_level/constants';

function setVisibilityOptions({ name, visibility, showPath, editPath }) {
  document.querySelectorAll('.visibility-level-setting .gl-form-radio').forEach((option) => {
    // Don't change anything if the option is restricted by admin
    if (option.classList.contains('restricted')) {
      return;
    }

    const optionInput = option.querySelector('input[type=radio]');
    const optionValue = optionInput ? parseInt(optionInput.value, 10) : 0;

    if (VISIBILITY_LEVELS_STRING_TO_INTEGER[visibility] < optionValue) {
      option.classList.add('disabled');
      optionInput.disabled = true;
      const reason = option.querySelector('.option-disabled-reason');
      if (reason) {
        const optionTitle = option.querySelector('.js-visibility-level-radio span');
        const optionName = optionTitle ? optionTitle.innerText.toLowerCase() : '';
        // eslint-disable-next-line no-unsanitized/property
        reason.innerHTML = sprintf(
          __(
            'This project cannot be %{visibilityLevel} because the visibility of %{openShowLink}%{name}%{closeShowLink} is %{visibility}. To make this project %{visibilityLevel}, you must first %{openEditLink}change the visibility%{closeEditLink} of the parent group.',
          ),
          {
            visibilityLevel: optionName,
            name: escape(name),
            visibility,
            openShowLink: `<a href="${showPath}">`,
            closeShowLink: '</a>',
            openEditLink: `<a href="${editPath}">`,
            closeEditLink: '</a>',
          },
          false,
        );
      }
    } else {
      option.classList.remove('disabled');
      optionInput.disabled = false;
    }
  });
}

export default function initProjectVisibilitySelector() {
  eventHub.$on('update-visibility', setVisibilityOptions);
}
==== app/assets/javascripts/rapid_diffs/stores/diffs_list.js ====
import { defineStore } from 'pinia';
import { debounce } from 'lodash';
import { renderHtmlStreams } from '~/streaming/render_html_streams';
import { toPolyfillReadable } from '~/streaming/polyfills';
import { DiffFile } from '~/rapid_diffs/web_components/diff_file';
import { performanceMarkAndMeasure } from '~/performance/utils';

export const statuses = {
  idle: 'idle',
  fetching: 'fetching',
  error: 'error',
  streaming: 'streaming',
};

export const useDiffsList = defineStore('diffsList', {
  state() {
    return {
      status: statuses.idle,
      loadingController: undefined,
      loadedFiles: {},
    };
  },
  actions: {
    withDebouncedAbortController: debounce(
      async function run(action) {
        this.loadingController?.abort?.();
        this.loadingController = new AbortController();
        try {
          await action(this.loadingController);
        } catch (error) {
          if (error.name !== 'AbortError') {
            this.status = statuses.error;
            throw error;
          }
        } finally {
          this.loadingController = undefined;
        }
      },
      500,
      { leading: true },
    ),
    addLoadedFile({ target }) {
      if (this.status === statuses.fetching) return;
      this.loadedFiles = { ...this.loadedFiles, [target.id]: true };
    },
    fillInLoadedFiles() {
      this.loadedFiles = Object.fromEntries(DiffFile.getAll().map((file) => [file.id, true]));
    },
    async renderDiffsStream(stream, container, signal) {
      this.status = statuses.streaming;
      await renderHtmlStreams([stream], container, { signal });
      this.status = statuses.idle;
    },
    streamRemainingDiffs(url, target, preload) {
      return this.withDebouncedAbortController(async ({ signal }) => {
        this.status = statuses.fetching;
        let request;
        let streamSignal = signal;
        if (preload) {
          const { controller, streamRequest } = preload;
          this.loadingController = controller;
          request = streamRequest;
          streamSignal = controller.signal;
        } else {
          request = fetch(url, { signal });
        }
        const { body } = await request;
        await this.renderDiffsStream(toPolyfillReadable(body), target, streamSignal);
        performanceMarkAndMeasure({
          mark: 'rapid-diffs-list-loaded',
          measures: [
            {
              name: 'rapid-diffs-list-loading',
              start: 'rapid-diffs-first-diff-file-shown',
              end: 'rapid-diffs-list-loaded',
            },
          ],
        });
      });
    },
    reloadDiffs(url, initial = false) {
      return this.withDebouncedAbortController(async ({ signal }) => {
        const container = document.querySelector('[data-diffs-list]');
        const overlay = document.querySelector('[data-diffs-overlay]');
        if (!initial) overlay.dataset.loading = 'true';
        this.loadedFiles = {};
        this.status = statuses.fetching;
        const { body } = await fetch(url, { signal });
        container.innerHTML = '';
        delete overlay.dataset.loading;
        await this.renderDiffsStream(toPolyfillReadable(body), container, signal);
      });
    },
  },
  getters: {
    isEmpty() {
      return this.status === statuses.idle && Object.keys(this.loadedFiles).length === 0;
    },
    isLoading() {
      return this.status !== statuses.idle && this.status !== statuses.error;
    },
  },
});
==== app/assets/javascripts/search/results/utils.js ====
import {
  LEGACY_FALLBACKS,
  ROUGE_TO_HLJS_LANGUAGE_MAP,
} from '~/vue_shared/components/source_viewer/constants';
import languageLoader from '~/content_editor/services/highlight_js_language_loader';
import { highlight } from '~/vue_shared/components/source_viewer/workers/highlight_utils';
import {
  HIGHLIGHT_MARK,
  HIGHLIGHT_MARK_REGEX,
  HIGHLIGHT_HTML_START,
  HIGHLIGHT_HTML_END,
  MAXIMUM_LINE_LENGTH,
  ELLIPSIS,
  MAX_GAP,
  HIGHLIGHT_CLASSES,
} from './constants';

/**
 * Checks if a language is unsupported for syntax highlighting
 * @param {string} language - The language to check
 * @returns {boolean} - True if the language is unsupported
 */
export const isUnsupportedLanguage = (language) => {
  const mappedLanguage = ROUGE_TO_HLJS_LANGUAGE_MAP[language];
  const supportedLanguages = Object.keys(languageLoader);
  const isUnsupported = !supportedLanguages.includes(mappedLanguage);

  return LEGACY_FALLBACKS.includes(language) || isUnsupported;
};

/**
 * Marks the search terms in a string
 * @param {string} str - The string to mark
 * @param {Array} highlights - Array of start/end positions for search matches
 * @returns {string} - String with search terms marked
 */
export const markSearchTerm = (str = '', highlights = []) => {
  if (!str || !highlights?.length) return str;

  const chars = str.split('');
  [...highlights].reverse().forEach((currentHighlight) => {
    const [start, end] = currentHighlight;
    chars.splice(end + 1, 0, HIGHLIGHT_MARK);
    chars.splice(start, 0, HIGHLIGHT_MARK);
  });

  return chars.join('');
};

/**
 * Cleans a line of text and marks search terms
 * @param {Object} params - Input parameters
 * @param {string} params.text - Text to clean
 * @param {Array} params.highlights - Highlight positions
 * @returns {string} - Cleaned text with search terms marked
 */
export const cleanLineAndMark = ({ text, highlights } = {}) => {
  const parsedText = highlights?.length > 0 ? markSearchTerm(text, highlights) : text;
  return parsedText?.replace(/(\r\n|\r|\n)+/g, '');
};

/**
 * Converts invisible markers to HTML highlights
 * @param {string} highlightedString - String with invisible markers
 * @returns {string} - String with HTML highlights
 */
export const highlightSearchTerm = (highlightedString) => {
  if (!highlightedString || highlightedString.length === 0) {
    return '';
  }
  const pattern = new RegExp(`${HIGHLIGHT_MARK_REGEX}(.+?)${HIGHLIGHT_MARK_REGEX}`, 'g');
  return highlightedString.replace(pattern, `${HIGHLIGHT_HTML_START}$1${HIGHLIGHT_HTML_END}`);
};

/**
 * Sorts highlights by starting position
 * @param {Array} highlights - Highlight positions
 * @returns {Array} - Sorted highlights
 */
const sortHighlights = (highlights) => {
  return [...highlights].sort((a, b) => a[0] - b[0]);
};

/**
 * Determines start and end positions for truncation based on context before
 * @param {Number} remainingSpace - calculated number of characters remaining
 * @param {string} text - Original text
 * @param {Number} start - start position character index
 * @returns {Object} - start, end posotions and booleans for adding ellipsis
 */
const getTextRegionsByContextBefore = (remainingSpace, text, start) => {
  const contextBefore = Math.min(remainingSpace / 2, start);

  return {
    startPos: Math.max(0, start - contextBefore),
    endPos: Math.min(text.length, start - contextBefore + MAXIMUM_LINE_LENGTH),
    addLeadingEllipsis: start - contextBefore > 0,
    addTrailingEllipsis: start - contextBefore + MAXIMUM_LINE_LENGTH < text.length,
  };
};

/**
 * Determines the optimal text region to keep based on highlights, strictly enforcing max length
 * @param {string} text - Original text
 * @param {Array} highlights - Array of highlight positions
 * @returns {Object} - Boundaries and flags for truncation
 */
const determineOptimalTextRegion = (text, highlights) => {
  if (!text || text.length <= MAXIMUM_LINE_LENGTH) {
    return {
      startPos: 0,
      endPos: text.length,
      addLeadingEllipsis: false,
      addTrailingEllipsis: false,
    };
  }

  if (!highlights || highlights.length === 0) {
    return {
      startPos: 0,
==== app/assets/javascripts/sidebar/mount_sidebar.js ====
import Vue from 'vue';
import VueApollo from 'vue-apollo';
import { TYPENAME_ISSUE, TYPENAME_MERGE_REQUEST } from '~/graphql_shared/constants';
import { convertToGraphQLId, getIdFromGraphQLId } from '~/graphql_shared/utils';
import { TYPE_ISSUE, TYPE_MERGE_REQUEST, WORKSPACE_PROJECT } from '~/issues/constants';
import { gqlClient } from '~/issues/list/graphql';
import {
  isInDesignPage,
  isInIncidentPage,
  isInIssuePage,
  parseBoolean,
} from '~/lib/utils/common_utils';
import { __ } from '~/locale';
import { apolloProvider } from '~/graphql_shared/issuable_client';
import Translate from '~/vue_shared/translate';
import UserSelect from '~/vue_shared/components/user_select/user_select.vue';
import SubmitReviewButton from '~/batch_comments/components/submit_review_button.vue';
import { pinia } from '~/pinia/instance';
import CollapsedAssigneeList from './components/assignees/collapsed_assignee_list.vue';
import SidebarAssigneesWidget from './components/assignees/sidebar_assignees_widget.vue';
import CopyEmailToClipboard from './components/copy/copy_email_to_clipboard.vue';
import SidebarDueDateWidget from './components/date/sidebar_date_widget.vue';
import SidebarEscalationStatus from './components/incidents/sidebar_escalation_status.vue';
import LabelsSelectWidget from './components/labels/labels_select_widget/labels_select_root.vue';
import IssuableLockForm from './components/lock/issuable_lock_form.vue';
import MilestoneDropdown from './components/milestone/milestone_dropdown.vue';
import MoveIssuesButton from './components/move/move_issues_button.vue';
import SidebarParticipantsWidget from './components/participants/sidebar_participants_widget.vue';
import SidebarReferenceWidget from './components/copy/sidebar_reference_widget.vue';
import SidebarReviewers from './components/reviewers/sidebar_reviewers.vue';
import SidebarReviewersInputs from './components/reviewers/sidebar_reviewers_inputs.vue';
import SidebarSeverityWidget from './components/severity/sidebar_severity_widget.vue';
import SidebarDropdownWidget from './components/sidebar_dropdown_widget.vue';
import StatusDropdown from './components/status/status_dropdown.vue';
import SidebarSubscriptionsWidget from './components/subscriptions/sidebar_subscriptions_widget.vue';
import SubscriptionsDropdown from './components/subscriptions/subscriptions_dropdown.vue';
import SidebarTimeTracking from './components/time_tracking/sidebar_time_tracking.vue';
import SidebarTodoWidget from './components/todo_toggle/sidebar_todo_widget.vue';
import { IssuableAttributeType } from './constants';
import CrmContacts from './components/crm_contacts/crm_contacts.vue';
import trackShowInviteMemberLink from './track_invite_members';
import MoveIssueButton from './components/move/move_issue_button.vue';
import ConfidentialityDropdown from './components/confidential/confidentiality_dropdown.vue';

Vue.use(Translate);
Vue.use(VueApollo);

function getSidebarOptions(sidebarOptEl = document.querySelector('.js-sidebar-options')) {
  return JSON.parse(sidebarOptEl.innerHTML);
}

function mountSubmitReviewButton() {
  const el = document.querySelector('#js-submit-review-button');

  // eslint-disable-next-line no-new
  new Vue({
    el,
    pinia,
    render(h) {
      return h(SubmitReviewButton);
    },
  });
}

function mountSidebarTodoWidget() {
  const el = document.querySelector('.js-sidebar-todo-widget-root');

  if (!el) {
    return null;
  }

  const { projectPath, iid, id } = el.dataset;

  return new Vue({
    el,
    name: 'SidebarTodoWidgetRoot',
    apolloProvider,
    provide: {
      isClassicSidebar: true,
    },
    render: (createElement) =>
      createElement(SidebarTodoWidget, {
        props: {
          fullPath: projectPath,
          issuableId:
            isInIssuePage() || isInIncidentPage() || isInDesignPage()
              ? convertToGraphQLId(TYPENAME_ISSUE, id)
              : convertToGraphQLId(TYPENAME_MERGE_REQUEST, id),
          issuableIid: iid,
          issuableType:
            isInIssuePage() || isInIncidentPage() || isInDesignPage()
              ? TYPE_ISSUE
              : TYPE_MERGE_REQUEST,
        },
      }),
  });
}

function mountSidebarAssigneesWidget() {
  const el = document.querySelector('.js-sidebar-assignees-root');

  if (!el) {
    return;
  }

  const { id, iid, fullPath, editable } = getSidebarOptions();
  const isIssuablePage = isInIssuePage() || isInIncidentPage() || isInDesignPage();
  const issuableType = isIssuablePage ? TYPE_ISSUE : TYPE_MERGE_REQUEST;
  // eslint-disable-next-line no-new
  new Vue({
    el,
    name: 'SidebarAssigneesRoot',
    apolloProvider,
    provide: {
      canUpdate: parseBoolean(editable),
      directlyInviteMembers: Object.prototype.hasOwnProperty.call(
        el.dataset,
        'directlyInviteMembers',
      ),
    },
==== app/assets/javascripts/validators/input_validator.js ====
const invalidInputClass = 'gl-field-error-outline';

export default class InputValidator {
  constructor() {
    this.inputDomElement = {};
    this.inputErrorMessage = {};
    this.errorMessage = null;
    this.invalidInput = null;
  }

  setValidationStateAndMessage() {
    this.setValidationMessage();

    const isInvalidInput = !this.inputDomElement.checkValidity();
    this.inputDomElement.classList.toggle(invalidInputClass, isInvalidInput);
    this.inputErrorMessage.classList.toggle('hide', !isInvalidInput);
  }

  setValidationMessage() {
    if (this.invalidInput) {
      this.inputDomElement.setCustomValidity(this.errorMessage);
      // eslint-disable-next-line no-unsanitized/property
      this.inputErrorMessage.innerHTML = this.errorMessage;
    } else {
      this.resetValidationMessage();
    }
  }

  resetValidationMessage() {
    if (this.inputDomElement.validationMessage === this.errorMessage) {
      this.inputDomElement.setCustomValidity('');
      // eslint-disable-next-line no-unsanitized/property
      this.inputErrorMessage.innerHTML = this.inputDomElement.title;
    }
  }
}
==== app/assets/javascripts/vue_alerts.js ====
import Vue from 'vue';
import { parseBoolean } from '~/lib/utils/common_utils';
import DismissibleAlert from '~/vue_shared/components/dismissible_alert.vue';

const mountVueAlert = (el) => {
  const props = {
    html: el.innerHTML,
  };
  const attrs = {
    ...el.dataset,
    dismissible: parseBoolean(el.dataset.dismissible),
  };

  return new Vue({
    el,
    render(createElement) {
      return createElement(DismissibleAlert, {
        props,
        attrs,
      });
    },
  });
};

export default () => [...document.querySelectorAll('.js-vue-alert')].map(mountVueAlert);
==== app/assets/javascripts/vue_merge_request_widget/components/widget/utils.js ====
const TEXT_STYLES = {
  success: {
    start: '%{success_start}',
    end: '%{success_end}',
  },
  danger: {
    start: '%{danger_start}',
    end: '%{danger_end}',
  },
  critical: {
    start: '%{critical_start}',
    end: '%{critical_end}',
  },
  same: {
    start: '%{same_start}',
    end: '%{same_end}',
  },
  strong: {
    start: '%{strong_start}',
    end: '%{strong_end}',
  },
  small: {
    start: '%{small_start}',
    end: '%{small_end}',
  },
};

const getStartTag = (tag) => TEXT_STYLES[tag].start;
const textStyleTags = {
  [getStartTag('success')]: '<span class="gl-font-bold gl-text-success">',
  [getStartTag('danger')]: '<span class="gl-font-bold gl-text-danger">',
  [getStartTag('critical')]: '<span class="gl-font-bold gl-text-red-800">',
  [getStartTag('same')]: '<span class="gl-font-bold gl-text-subtle">',
  [getStartTag('strong')]: '<span class="gl-font-bold">',
  [getStartTag('small')]: '<span class="gl-text-sm gl-text-subtle">',
};

const escapeText = (text) =>
  document.createElement('div').appendChild(document.createTextNode(text)).parentNode.innerHTML;

const createText = (text) => {
  return text
    .replace(
      new RegExp(
        `(${Object.values(TEXT_STYLES)
          .reduce((acc, i) => [...acc, ...Object.values(i)], [])
          .join('|')})`,
        'gi',
      ),
      (replace) => {
        const replacement = textStyleTags[replace];

        // If the replacement tag ends with a `_end` then we can just return `</span>`
        // unless we have a replacement, for cases were we want to change the HTML tag
        if (!replacement && replace.endsWith('_end}')) {
          return '</span>';
        }

        return replacement;
      },
    )
    .replace(/%{([a-z]|_)+}/g, ''); // Filter out any tags we don't know about
};

export const generateText = (text) => {
  if (typeof text === 'string') {
    return createText(escapeText(text));
  }
  if (typeof text === 'object' && typeof text.text === 'string' && typeof text.href === 'string') {
    return createText(
      `${text.prependText ? `${escapeText(text.prependText)} ` : ''}<a class="gl-underline" href="${
        text.href
      }">${escapeText(text.text)}</a>`,
    );
  }

  return null;
};
==== app/assets/javascripts/vue_merge_request_widget/mr_widget_options.vue ====
<script>
import { isEmpty, clamp } from 'lodash';
import SafeHtml from '~/vue_shared/directives/safe_html';
import MrWidgetApprovals from 'ee_else_ce/vue_merge_request_widget/components/approvals/approvals.vue';
import MRWidgetService from 'ee_else_ce/vue_merge_request_widget/services/mr_widget_service';
import MRWidgetStore from 'ee_else_ce/vue_merge_request_widget/stores/mr_widget_store';
import { stateToComponentMap as classState } from 'ee_else_ce/vue_merge_request_widget/stores/state_maps';
import { createAlert } from '~/alert';
import { STATUS_CLOSED, STATUS_MERGED } from '~/issues/constants';
import notify from '~/lib/utils/notify';
import { sprintf, s__, __ } from '~/locale';
import SmartInterval from '~/smart_interval';
import { TYPENAME_MERGE_REQUEST } from '~/graphql_shared/constants';
import { convertToGraphQLId } from '~/graphql_shared/utils';
import { setFaviconOverlay } from '~/lib/utils/favicon';
import Loading from './components/loading.vue';
import MrWidgetAlertMessage from './components/mr_widget_alert_message.vue';
import MrWidgetPipelineContainer from './components/mr_widget_pipeline_container.vue';
import WidgetSuggestPipeline from './components/mr_widget_suggest_pipeline.vue';
import MrWidgetMigrateJenkins from './components/mr_widget_migrate_jenkins.vue';
import SourceBranchRemovalStatus from './components/source_branch_removal_status.vue';
import ArchivedState from './components/states/mr_widget_archived.vue';
import MrWidgetAutoMergeEnabled from './components/states/mr_widget_auto_merge_enabled.vue';
import AutoMergeFailed from './components/states/mr_widget_auto_merge_failed.vue';
import CheckingState from './components/states/mr_widget_checking.vue';
import PreparingState from './components/states/mr_widget_preparing.vue';
import ClosedState from './components/states/mr_widget_closed.vue';
import FailedToMerge from './components/states/mr_widget_failed_to_merge.vue';
import MergedState from './components/states/mr_widget_merged.vue';
import MergingState from './components/states/mr_widget_merging.vue';
import MissingBranchState from './components/states/mr_widget_missing_branch.vue';
import NothingToMergeState from './components/states/nothing_to_merge.vue';
import ReadyToMergeState from './components/states/ready_to_merge.vue';
import ShaMismatch from './components/states/sha_mismatch.vue';
import WidgetContainer from './components/widget/app.vue';
import {
  STATE_MACHINE,
  stateToComponentMap,
  STATE_QUERY_POLLING_INTERVAL_DEFAULT,
  STATE_QUERY_POLLING_INTERVAL_BACKOFF,
  FOUR_MINUTES_IN_MS,
} from './constants';
import eventHub from './event_hub';
import mergeRequestQueryVariablesMixin from './mixins/merge_request_query_variables';
import getStateQuery from './queries/get_state.query.graphql';
import getStateSubscription from './queries/get_state.subscription.graphql';
import MrWidgetReadyToMerge from './components/states/new_ready_to_merge.vue';
import MergeChecks from './components/merge_checks.vue';

export default {
  // False positive i18n lint: https://gitlab.com/gitlab-org/frontend/eslint-plugin-i18n/issues/25
  // eslint-disable-next-line @gitlab/require-i18n-strings
  name: 'MRWidget',
  directives: {
    SafeHtml,
  },
  components: {
    Loading,
    WidgetContainer,
    MrWidgetSuggestPipeline: WidgetSuggestPipeline,
    MrWidgetMigrateJenkins,
    MrWidgetPipelineContainer,
    MrWidgetAlertMessage,
    MrWidgetMerged: MergedState,
    MrWidgetClosed: ClosedState,
    MrWidgetMerging: MergingState,
    MrWidgetFailedToMerge: FailedToMerge,
    MrWidgetArchived: ArchivedState,
    MrWidgetNothingToMerge: NothingToMergeState,
    MrWidgetMissingBranch: MissingBranchState,
    MrWidgetReadyToMerge,
    ShaMismatch,
    MrWidgetChecking: CheckingState,
    MrWidgetPreparing: PreparingState,
    MrWidgetAutoMergeEnabled,
    MrWidgetAutoMergeFailed: AutoMergeFailed,
    SourceBranchRemovalStatus,
    MrWidgetApprovals,
    ReadyToMerge: ReadyToMergeState,
    MergeChecks,
  },
  apollo: {
    state: {
      query: getStateQuery,
      notifyOnNetworkStatusChange: true,
      manual: true,
      skip() {
        return !this.mr;
      },
      variables() {
        return this.mergeRequestQueryVariables;
      },
      pollInterval() {
        return this.pollInterval;
      },
      result(response) {
        // 7 is the value for when the network status is ready
        if (response.networkStatus !== 7) return;

        this.pollInterval = this.apolloStateQueryPollingInterval;

        if (response.data?.project) {
          this.mr.setGraphqlData(response.data.project);
          this.loading = false;
        }

        this.checkStatus(undefined, undefined, false);
      },
      error() {
        this.pollInterval = null;
      },
      subscribeToMore: {
        document() {
          return getStateSubscription;
        },
        skip() {
          return !this.mr?.id || this.loading;
        },
        variables() {
          return {
==== app/assets/javascripts/vue_shared/components/blob_viewers/rich_viewer.vue ====
<script>
import SafeHtml from '~/vue_shared/directives/safe_html';
import { handleBlobRichViewer } from '~/blob/viewer';
import MarkdownFieldView from '~/vue_shared/components/markdown/field_view.vue';
import { handleLocationHash } from '~/lib/utils/common_utils';
import { sanitize, defaultConfig } from '~/lib/dompurify';
import ViewerMixin from './mixins';
import {
  MARKUP_FILE_TYPE,
  MARKUP_CONTENT_SELECTOR,
  ELEMENTS_PER_CHUNK,
  CONTENT_LOADED_EVENT,
} from './constants';

export default {
  components: {
    MarkdownFieldView,
  },
  directives: {
    SafeHtml,
  },
  mixins: [ViewerMixin],
  props: {
    isSnippet: {
      type: Boolean,
      default: false,
      required: false,
    },
  },
  data() {
    return {
      isLoading: true,
      initialContent: null,
      remainingContent: [],
    };
  },
  computed: {
    rawContent() {
      return this.initialContent || this.richViewer || this.content;
    },
    isMarkup() {
      return this.type === MARKUP_FILE_TYPE;
    },
    forbiddenAttrs() {
      const attrs = [...defaultConfig.FORBID_ATTR, 'data-lines-path'];
      if (this.isSnippet) {
        attrs.push('style');
      }
      return attrs;
    },
  },
  created() {
    this.optimizeMarkupRendering();
  },
  mounted() {
    this.renderRemainingMarkup();
    handleBlobRichViewer(this.$refs.content, this.type);
  },
  methods: {
    optimizeMarkupRendering() {
      /**
       * If content is markup we optimize rendering by splitting it into two parts:
       * - initialContent (top section of the file - is rendered right away)
       * - remainingContent (remaining content - is rendered over a longer time period)
       *
       * This is done so that the browser doesn't render the whole file at once (improves TBT)
       */

      if (!this.isMarkup) return;

      const tmpWrapper = document.createElement('div');
      tmpWrapper.innerHTML = sanitize(this.rawContent, {
        ...defaultConfig,
        FORBID_ATTR: this.forbiddenAttrs,
      });

      const fileContent = tmpWrapper.querySelector(MARKUP_CONTENT_SELECTOR);
      if (!fileContent) return;

      const initialContent = [...fileContent.childNodes].slice(0, ELEMENTS_PER_CHUNK);
      this.remainingContent = [...fileContent.childNodes].slice(ELEMENTS_PER_CHUNK);

      fileContent.innerHTML = '';
      fileContent.append(...initialContent);
      this.initialContent = tmpWrapper.outerHTML;
    },
    renderRemainingMarkup() {
      /**
       * Rendering large Markdown files can block the main thread due to the amount of HTML being parsed.
       * The optimization below ensures that content is rendered over a longer time period instead of all at once.
       * More details here: https://gitlab.com/gitlab-org/gitlab/-/issues/331448
       * */

      if (!this.isMarkup || !this.remainingContent.length) {
        this.onContentLoaded();
        return;
      }

      const fileContent = this.$refs.content.$el.querySelector(MARKUP_CONTENT_SELECTOR);

      for (let i = 0; i < this.remainingContent.length; i += ELEMENTS_PER_CHUNK) {
        const nextChunkEnd = i + ELEMENTS_PER_CHUNK;
        const content = this.remainingContent.slice(i, nextChunkEnd);
        setTimeout(() => {
          fileContent.append(...content);
          if (nextChunkEnd < this.remainingContent.length) return;
          this.onContentLoaded();
        }, i);
      }
    },
    onContentLoaded() {
      this.$emit(CONTENT_LOADED_EVENT);
      handleLocationHash();
      this.isLoading = false;
    },
  },
  safeHtmlConfig: {
    ...defaultConfig,
    FORBID_ATTR: [...defaultConfig.FORBID_ATTR, 'data-lines-path'],
  },
==== app/assets/javascripts/vue_shared/components/markdown_drawer/utils/fetch.js ====
import * as Sentry from '~/sentry/sentry_browser_wrapper';
import { helpPagePath } from '~/helpers/help_page_helper';
import axios from '~/lib/utils/axios_utils';

export const splitDocument = (htmlString) => {
  const htmlDocument = new DOMParser().parseFromString(htmlString, 'text/html');
  const title = htmlDocument.querySelector('h1')?.innerText;
  htmlDocument.querySelector('h1')?.remove();
  return {
    title,
    body: htmlDocument.querySelector('body').innerHTML.toString(),
  };
};

export const getRenderedMarkdown = (documentPath) => {
  return (
    axios
      // It is okay to disable `require-valid-help-page-path` here because drawer help docs are served
      // through their own `HelpController#drawers` resource, which we can't reliably lint against.
      // eslint-disable-next-line local-rules/require-valid-help-page-path
      .get(helpPagePath(documentPath))
      .then(({ data }) => {
        const { body, title } = splitDocument(data);
        return {
          body,
          title,
          hasFetchError: false,
        };
      })
      .catch((e) => {
        Sentry.captureException(e);
        return {
          hasFetchError: true,
        };
      })
  );
};
==== app/assets/javascripts/vue_shared/components/markdown/header.vue ====
<!-- eslint-disable vue/multi-word-component-names -->
<script>
import { GlPopover, GlButton, GlTooltipDirective, GlFormInput } from '@gitlab/ui';
import { GL_COLOR_ORANGE_50, GL_COLOR_ORANGE_200 } from '@gitlab/ui/dist/tokens/build/js/tokens';
import $ from 'jquery';
import { escapeRegExp } from 'lodash';
import {
  keysFor,
  BOLD_TEXT,
  ITALIC_TEXT,
  STRIKETHROUGH_TEXT,
  LINK_TEXT,
  INDENT_LINE,
  OUTDENT_LINE,
  FIND_AND_REPLACE,
} from '~/behaviors/shortcuts/keybindings';
import glFeatureFlagsMixin from '~/vue_shared/mixins/gl_feature_flags_mixin';
import { getModifierKey } from '~/constants';
import { getSelectedFragment } from '~/lib/utils/common_utils';
import { truncateSha } from '~/lib/utils/text_utility';
import { s__, __, sprintf } from '~/locale';
import { CopyAsGFM } from '~/behaviors/markdown/copy_as_gfm';
import { updateText, repeatCodeBackticks } from '~/lib/utils/text_markdown';
import ToolbarTableButton from '~/content_editor/components/toolbar_table_button.vue';
import ToolbarButton from './toolbar_button.vue';
import DrawioToolbarButton from './drawio_toolbar_button.vue';
import CommentTemplatesModal from './comment_templates_modal.vue';
import HeaderDivider from './header_divider.vue';

export default {
  findAndReplace: {
    highlightColor: GL_COLOR_ORANGE_50,
    highlightColorActive: GL_COLOR_ORANGE_200,
    highlightClass: 'js-highlight',
    highlightClassActive: 'js-highlight-active',
  },

  components: {
    ToolbarButton,
    ToolbarTableButton,
    GlPopover,
    GlButton,
    GlFormInput,
    DrawioToolbarButton,
    CommentTemplatesModal,
    AiActionsDropdown: () => import('ee_component/ai/components/ai_actions_dropdown.vue'),
    HeaderDivider,
    SummarizeCodeChanges: () =>
      import('ee_component/merge_requests/components/summarize_code_changes.vue'),
  },
  directives: {
    GlTooltip: GlTooltipDirective,
  },
  mixins: [glFeatureFlagsMixin()],
  inject: {
    newCommentTemplatePaths: {
      default: () => [],
    },
    mrGeneratedContent: { default: null },
    canSummarizeChanges: { default: false },
    canUseComposer: { default: false },
    legacyEditorAiActions: { default: () => [] },
  },
  props: {
    editorAiActions: {
      type: Array,
      required: false,
      default: () => [],
    },
    previewMarkdown: {
      type: Boolean,
      required: true,
    },
    lineContent: {
      type: String,
      required: false,
      default: '',
    },
    canSuggest: {
      type: Boolean,
      required: false,
      default: true,
    },
    showSuggestPopover: {
      type: Boolean,
      required: false,
      default: false,
    },
    suggestionStartIndex: {
      type: Number,
      required: false,
      default: 0,
    },
    enablePreview: {
      type: Boolean,
      required: false,
      default: true,
    },
    restrictedToolBarItems: {
      type: Array,
      required: false,
      default: () => [],
    },
    uploadsPath: {
      type: String,
      required: false,
      default: '',
    },
    markdownPreviewPath: {
      type: String,
      required: false,
      default: '',
    },
    newCommentTemplatePathsProp: {
      type: Array,
      required: false,
      default: () => [],
    },
    drawioEnabled: {
      type: Boolean,
==== app/assets/javascripts/vue_shared/components/markdown/suggestions.vue ====
<!-- eslint-disable vue/multi-word-component-names -->
<script>
import Vue from 'vue';
import SafeHtml from '~/vue_shared/directives/safe_html';
import { createAlert } from '~/alert';
import { __ } from '~/locale';
import SuggestionDiff from './suggestion_diff.vue';

export default {
  directives: {
    SafeHtml,
  },
  props: {
    lineType: {
      type: String,
      required: false,
      default: '',
    },
    suggestions: {
      type: Array,
      required: false,
      default: () => [],
    },
    batchSuggestionsInfo: {
      type: Array,
      required: false,
      default: () => [],
    },
    noteHtml: {
      type: String,
      required: true,
    },
    disabled: {
      type: Boolean,
      required: false,
      default: false,
    },
    helpPagePath: {
      type: String,
      required: true,
    },
    defaultCommitMessage: {
      type: String,
      required: false,
      default: null,
    },
    suggestionsCount: {
      type: Number,
      required: false,
      default: 0,
    },
    failedToLoadMetadata: {
      type: Boolean,
      required: false,
      default: false,
    },
  },
  data() {
    return {
      isRendered: false,
    };
  },
  watch: {
    suggestions() {
      this.reset();
    },
    noteHtml() {
      this.reset();
    },
    failedToLoadMetadata() {
      this.reset();
    },
  },
  mounted() {
    this.renderSuggestions();
  },
  beforeDestroy() {
    if (this.suggestionsWatch) {
      this.suggestionsWatch();
    }

    if (this.defaultCommitMessageWatch) {
      this.defaultCommitMessageWatch();
    }
  },
  methods: {
    renderSuggestions() {
      // swaps out suggestion(s) markdown with rich diff components
      // (while still keeping non-suggestion markdown in place)

      if (!this.noteHtml) return;
      const { container } = this.$refs;
      const suggestionElements = container.querySelectorAll('.js-render-suggestion');

      if (this.lineType === 'old') {
        createAlert({
          message: __('Unable to apply suggestions to a deleted line.'),
          parent: this.$el,
        });
      }

      suggestionElements.forEach((suggestionEl, i) => {
        const suggestionParentEl = suggestionEl.parentElement;
        const diffComponent = this.generateDiff(i);
        diffComponent.$mount(suggestionParentEl);
      });

      this.isRendered = true;
    },
    generateDiff(suggestionIndex) {
      const {
        suggestions,
        disabled,
        batchSuggestionsInfo,
        helpPagePath,
        defaultCommitMessage,
        suggestionsCount,
        failedToLoadMetadata,
      } = this;
      const suggestion =
==== app/assets/javascripts/vue_shared/components/notes/system_note.vue ====
<script>
/**
 * Common component to render a system note, icon and user information.
 *
 * This component needs to be used with a vuex store.
 * That vuex store needs to have a `targetNoteHash` getter
 *
 * @example
 * <system-note
 *   :note="{
 *     id: String,
 *     author: Object,
 *     createdAt: String,
 *     note_html: String,
 *     system_note_icon_name: String
 *    }"
 *   />
 */
import { GlButton, GlSkeletonLoader, GlTooltipDirective, GlIcon } from '@gitlab/ui';
import $ from 'jquery';
import { mapActions, mapState } from 'pinia';
import SafeHtml from '~/vue_shared/directives/safe_html';
import descriptionVersionHistoryMixin from 'ee_else_ce/notes/mixins/description_version_history';
import axios from '~/lib/utils/axios_utils';
import { __ } from '~/locale';
import NoteHeader from '~/notes/components/note_header.vue';
import { renderGFM } from '~/behaviors/markdown/render_gfm';
import { useNotes } from '~/notes/store/legacy_notes';
import TimelineEntryItem from './timeline_entry_item.vue';

const MAX_VISIBLE_COMMIT_LIST_COUNT = 3;
const ICON_COLORS = {
  check: 'system-note-icon-success',
  'merge-request-close': 'system-note-icon-danger',
  merge: 'system-note-icon-info',
  'issue-close': 'system-note-icon-info',
  issues: 'system-note-icon-success',
  error: 'system-note-icon-danger',
  'review-warning': 'system-note-icon-warning',
  'comment-lines': 'system-note-icon-info',
};

export default {
  i18n: {
    deleteButtonLabel: __('Remove description history'),
  },
  name: 'SystemNote',
  components: {
    GlIcon,
    NoteHeader,
    TimelineEntryItem,
    GlButton,
    GlSkeletonLoader,
  },
  directives: {
    GlTooltip: GlTooltipDirective,
    SafeHtml,
  },
  mixins: [descriptionVersionHistoryMixin],
  props: {
    note: {
      type: Object,
      required: true,
    },
  },
  data() {
    return {
      expanded: false,
      lines: [],
      showLines: false,
      loadingDiff: false,
    };
  },
  computed: {
    ...mapState(useNotes, ['targetNoteHash', 'descriptionVersions', 'isLoadingDescriptionVersion']),
    noteAnchorId() {
      return `note_${this.note.id}`;
    },
    isAllowedIcon() {
      return Object.keys(ICON_COLORS).includes(this.note.system_note_icon_name);
    },
    isTargetNote() {
      return this.targetNoteHash === this.noteAnchorId;
    },
    toggleIcon() {
      return this.expanded ? 'chevron-up' : 'chevron-down';
    },
    // following 2 methods taken from code in `collapseLongCommitList` of notes.js:
    actionTextHtml() {
      return $(this.note.note_html).unwrap().html();
    },
    hasMoreCommits() {
      return $(this.note.note_html).filter('ul').children().length > MAX_VISIBLE_COMMIT_LIST_COUNT;
    },
    descriptionVersion() {
      return this.descriptionVersions[this.note.description_version_id];
    },
    singleLineDescription() {
      return !this.descriptionVersion?.match(/\n/g);
    },
    deleteButtonClasses() {
      return this.singleLineDescription ? 'gl-top-5 gl-right-2 gl-mt-2' : 'gl-top-6 gl-right-3';
    },
    iconBgClass() {
      return ICON_COLORS[this.note.system_note_icon_name] || 'gl-text-subtle';
    },
    systemNoteIconName() {
      let icon = this.note.system_note_icon_name;
      if (this.note.system_note_icon_name === 'issues') {
        // eslint-disable-next-line @gitlab/require-i18n-strings
        if (this.note.noteable_type === 'Issue') {
          icon = 'issue-open-m';
        } else if (this.note.noteable_type === 'MergeRequest') {
          icon = 'merge-request';
        }
      }
      return icon;
    },
  },
  mounted() {
==== app/assets/javascripts/vue_shared/new_namespace/components/legacy_container.vue ====
<script>
import projectNew from '~/projects/project_new';

export default {
  inheritAttrs: false,
  props: {
    selector: {
      type: String,
      required: true,
    },
  },
  mounted() {
    const legacyEntry = document.querySelector(this.selector);
    if (legacyEntry.tagName === 'TEMPLATE') {
      // eslint-disable-next-line no-unsanitized/property
      this.$el.innerHTML = legacyEntry.innerHTML;
    } else {
      this.source = legacyEntry.parentNode;
      this.$el.appendChild(legacyEntry);
      legacyEntry.classList.add('active');
      projectNew.bindEvents();
    }
  },

  beforeDestroy() {
    if (this.source) {
      this.$el.firstChild.classList.remove('active');
      this.source.appendChild(this.$el.firstChild);
    }
  },
};
</script>
<template>
  <div></div>
</template>
==== app/assets/javascripts/webpack_non_compiled_placeholder.js ====
/* globals LIVE_RELOAD */
const div = document.createElement('div');

Object.assign(div.style, {
  width: '100vw',
  height: '100vh',
  position: 'fixed',
  top: 0,
  left: 0,
  'z-index': 100000,
  background: 'rgba(0,0,0,0.9)',
  'font-size': '20px',
  'font-family': 'monospace',
  color: 'white',
  padding: '2.5em',
  'text-align': 'center',
});

const reloadMessage = LIVE_RELOAD
  ? 'You have live_reload enabled, the page will reload automatically when complete.'
  : 'You have live_reload disabled, the page will reload automatically in a few seconds.';

// eslint-disable-next-line no-unsanitized/property
div.innerHTML = `
<!-- https://github.com/webpack/media/blob/master/logo/icon-square-big.svg -->
<svg height="50" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1200 1200">
  <path fill="#FFF" d="M600 0l530.3 300v600L600 1200 69.7 900V300z"/>
  <path fill="#8ED6FB" class="st1" d="M1035.6 879.3l-418.1 236.5V931.6L878 788.3l157.6 91zm28.6-25.9V358.8l-153 88.3V765l153 88.4zm-901.5 25.9l418.1 236.5V931.6L320.3 788.3l-157.6 91zm-28.6-25.9V358.8l153 88.3V765l-153 88.4zM152 326.8L580.8 84.2v178.1L306.1 413.4l-2.1 1.2-152-87.8zm894.3 0L617.5 84.2v178.1l274.7 151.1 2.1 1.2 152-87.8z"/>
  <path fill="#1C78C0" d="M580.8 889.7l-257-141.3v-280l257 148.4v272.9zm36.7 0l257-141.3v-280l-257 148.4v272.9zm-18.3-283.6zM341.2 436l258-141.9 258 141.9-258 149-258-149z"/>
</svg>

<h1 style="color:white"> webpack is compiling frontend assets </h1>
<p>
  To reduce GDK memory consumption, incremental on-demand compiling is on by default.<br />
  You can disable this within gdk.yml.
  Learn more <a href="https://gitlab.com/gitlab-org/gitlab-development-kit/-/blob/main/doc/configuration.md#webpack-settings">here</a>.
</p>
<p>
  ${reloadMessage}<br />
  If it doesn't, please <a href="">reload the page manually</a>.
</p>
<div class="gl-card gl-max-w-limited gl-m-auto">
  <div class="gl-card-body">
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 410 404" width="100">
      <path fill="url(#a)" d="m399.641 59.525-183.998 329.02c-3.799 6.793-13.559 6.833-17.415.073L10.582 59.556C6.38 52.19 12.68 43.266 21.028 44.76l184.195 32.923c1.175.21 2.378.208 3.553-.006l180.343-32.87c8.32-1.517 14.649 7.337 10.522 14.719Z"/>
      <path fill="url(#b)" d="M292.965 1.574 156.801 28.255a5 5 0 0 0-4.03 4.611l-8.376 141.464c-.197 3.332 2.863 5.918 6.115 5.168l37.91-8.749c3.547-.818 6.752 2.306 6.023 5.873l-11.263 55.153c-.758 3.712 2.727 6.886 6.352 5.785l23.415-7.114c3.63-1.102 7.118 2.081 6.35 5.796l-17.899 86.633c-1.12 5.419 6.088 8.374 9.094 3.728l2.008-3.103 110.954-221.428c1.858-3.707-1.346-7.935-5.418-7.15l-39.022 7.532c-3.667.707-6.787-2.708-5.752-6.296l25.469-88.291c1.036-3.594-2.095-7.012-5.766-6.293Z"/>
      <defs>
        <linearGradient id="a" x1="6" x2="235" y1="33" y2="344" gradientUnits="userSpaceOnUse"><stop stop-color="#41D1FF"/><stop offset="1" stop-color="#BD34FE"/></linearGradient>
        <linearGradient id="b" x1="194.651" x2="236.076" y1="8.818" y2="292.989" gradientUnits="userSpaceOnUse"><stop stop-color="#FFEA83"/><stop offset=".083" stop-color="#FFDD35"/><stop offset="1" stop-color="#FFA800"/></linearGradient>
      </defs>
    </svg>
    <h2>Don't want to see this message anymore?</h2>
    <p class="gl-text-default">
      Follow the documentation to switch to using Vite.<br />
      Vite compiles frontend assets faster and eliminates the need for this message.
    </p>
    <a href="https://gitlab.com/gitlab-org/gitlab-development-kit/-/blob/main/doc/configuration.md?ref_type=heads#vite-settings" rel="noopener noreferrer" target="_blank" class="btn btn-confirm btn-md gl-button">
      <span class="gl-button-text">Switch to Vite</span>
    </a>
  </div>
</div>
`;

document.body.append(div);

if (!LIVE_RELOAD) {
  setTimeout(() => {
    window.location.reload();
  }, 5000);
}
==== app/assets/javascripts/wikis/components/wiki_content.vue ====
<script>
import Vue from 'vue';
import { GlSkeletonLoader, GlAlert } from '@gitlab/ui';
import { createAlert } from '~/alert';
import axios from '~/lib/utils/axios_utils';
import { handleLocationHash } from '~/lib/utils/common_utils';
import { renderGFM } from '~/behaviors/markdown/render_gfm';
import SafeHtml from '~/vue_shared/directives/safe_html';
import { __ } from '~/locale';
import { getHeadingsFromDOM } from '~/content_editor/services/table_of_contents_utils';
import TableOfContents from './table_of_contents.vue';

const TableOfContentsComponent = Vue.extend(TableOfContents);

export default {
  components: {
    GlSkeletonLoader,
    GlAlert,
  },
  directives: {
    SafeHtml,
  },

  inject: ['contentApi'],
  data() {
    return {
      content: '',
      isLoadingContent: false,
      loadingContentFailed: false,
      headings: [],
    };
  },
  mounted() {
    this.loadWikiContent();
  },
  methods: {
    async renderHeadingsInSidebar() {
      const headings = getHeadingsFromDOM(this.$refs.content);
      if (!headings.length) return;

      const tocComponent = new TableOfContentsComponent({ propsData: { headings } }).$mount();
      const tocContainer = document.querySelector('.js-wiki-toc');

      tocContainer.innerHTML = '';
      tocContainer.appendChild(tocComponent.$el);
    },

    async loadWikiContent() {
      this.loadingContentFailed = false;
      this.isLoadingContent = true;

      try {
        const {
          data: { content },
        } = await axios.get(this.contentApi, { params: { render_html: true } });
        this.content = content;

        this.$nextTick()
          .then(() => {
            renderGFM(this.$refs.content);
            handleLocationHash();

            this.renderHeadingsInSidebar();
          })
          .catch(() => {
            createAlert({
              message: this.$options.i18n.renderingContentFailed,
            });
          });
      } catch (e) {
        this.loadingContentFailed = true;
      } finally {
        this.isLoadingContent = false;
      }
    },
  },
  i18n: {
    loadingContentFailed: __(
      'The content for this wiki page failed to load. To fix this error, reload the page.',
    ),
    retryLoadingContent: __('Retry'),
    renderingContentFailed: __('The content for this wiki page failed to render.'),
  },
};
</script>
<template>
  <gl-skeleton-loader v-if="isLoadingContent" :width="830" :height="113">
    <rect width="540" height="16" rx="4" />
    <rect y="49" width="701" height="16" rx="4" />
    <rect y="24" width="830" height="16" rx="4" />
    <rect y="73" width="540" height="16" rx="4" />
  </gl-skeleton-loader>
  <gl-alert
    v-else-if="loadingContentFailed"
    :dismissible="false"
    variant="danger"
    :primary-button-text="$options.i18n.retryLoadingContent"
    @primaryAction="loadWikiContent"
  >
    {{ $options.i18n.loadingContentFailed }}
  </gl-alert>
  <div
    v-else-if="!loadingContentFailed && !isLoadingContent"
    ref="content"
    v-safe-html="content"
    data-testid="wiki-page-content"
    class="js-wiki-page-content md"
  ></div>
</template>
==== app/assets/javascripts/work_items/components/work_item_description_rendered.vue ====
<script>
import { GlButton, GlTooltipDirective } from '@gitlab/ui';
import Vue from 'vue';
import Sortable from 'sortablejs';
import { renderGFM } from '~/behaviors/markdown/render_gfm';
import { toggleCheckbox } from '~/behaviors/markdown/utils';
import TaskListItemActions from '~/issues/show/components/task_list_item_actions.vue';
import eventHub from '~/issues/show/event_hub';
import { InternalEvents } from '~/tracking';
import {
  convertDescriptionWithNewSort,
  deleteTaskListItem,
  extractTaskTitleAndDescription,
  insertNextToTaskListItemText,
} from '~/issues/show/utils';
import { getSortableDefaultOptions, isDragging } from '~/sortable/utils';
import { handleLocationHash } from '~/lib/utils/common_utils';
import { getLocationHash } from '~/lib/utils/url_utility';
import SafeHtml from '~/vue_shared/directives/safe_html';
import {
  CREATION_CONTEXT_DESCRIPTION_CHECKLIST,
  WORK_ITEM_TYPE_NAME_EPIC,
  WORK_ITEM_TYPE_NAME_ISSUE,
  WORK_ITEM_TYPE_NAME_TASK,
} from '../constants';

const trackingMixin = InternalEvents.mixin();

const FULL_OPACITY = 'gl-opacity-10';
const CURSOR_GRAB = 'gl-cursor-grab';
const isCheckbox = (target) => target?.classList.contains('task-list-item-checkbox');

export default {
  CREATION_CONTEXT_DESCRIPTION_CHECKLIST,
  directives: {
    SafeHtml,
    GlTooltip: GlTooltipDirective,
  },
  components: {
    CreateWorkItemModal: () => import('~/work_items/components/create_work_item_modal.vue'),
    GlButton,
  },
  mixins: [trackingMixin],
  props: {
    enableTruncation: {
      type: Boolean,
      required: true,
    },
    fullPath: {
      type: String,
      required: true,
    },
    isGroup: {
      type: Boolean,
      required: false,
      default: false,
    },
    isUpdating: {
      type: Boolean,
      required: false,
      default: false,
    },
    workItemDescription: {
      type: Object,
      required: true,
    },
    workItemId: {
      type: String,
      required: false,
      default: '',
    },
    workItemType: {
      type: String,
      required: false,
      default: '',
    },
    canEdit: {
      type: Boolean,
      required: true,
    },
    withoutHeadingAnchors: {
      type: Boolean,
      required: false,
      default: false,
    },
  },
  data() {
    return {
      childDescription: '',
      childTitle: '',
      hasTaskListItemActions: false,
      truncated: false,
      visible: false,
      checkboxes: [],
    };
  },
  computed: {
    childItemType() {
      return this.workItemType === WORK_ITEM_TYPE_NAME_EPIC
        ? WORK_ITEM_TYPE_NAME_ISSUE
        : WORK_ITEM_TYPE_NAME_TASK;
    },
    descriptionText() {
      return this.workItemDescription?.description;
    },
    descriptionHtml() {
      if (this.withoutHeadingAnchors) {
        return this.stripHeadingAnchors(this.workItemDescription?.descriptionHtml);
      }
      return this.workItemDescription?.descriptionHtml;
    },
    isDescriptionEmpty() {
      return this.descriptionHtml?.trim() === '';
    },
    isTruncated() {
      return this.truncated && this.enableTruncation;
    },
  },
  watch: {
    descriptionHtml: {
==== app/assets/javascripts/work_items/utils.js ====
import { escapeRegExp, kebabCase } from 'lodash';
import { getIdFromGraphQLId } from '~/graphql_shared/utils';
import { joinPaths, queryToObject } from '~/lib/utils/url_utility';
import AccessorUtilities from '~/lib/utils/accessor';
import { parseBoolean } from '~/lib/utils/common_utils';
import { getDraft, updateDraft } from '~/lib/utils/autosave';
import { TYPE_EPIC, TYPE_ISSUE } from '~/issues/constants';
import {
  DEFAULT_PAGE_SIZE_CHILD_ITEMS,
  NAME_TO_ENUM_MAP,
  NAME_TO_ICON_MAP,
  NAME_TO_ROUTE_MAP,
  NEW_WORK_ITEM_GID,
  NEW_WORK_ITEM_IID,
  STATE_CLOSED,
  WIDGET_TYPE_ASSIGNEES,
  WIDGET_TYPE_AWARD_EMOJI,
  WIDGET_TYPE_COLOR,
  WIDGET_TYPE_CRM_CONTACTS,
  WIDGET_TYPE_CURRENT_USER_TODOS,
  WIDGET_TYPE_CUSTOM_FIELDS,
  WIDGET_TYPE_DESCRIPTION,
  WIDGET_TYPE_DESIGNS,
  WIDGET_TYPE_DEVELOPMENT,
  WIDGET_TYPE_EMAIL_PARTICIPANTS,
  WIDGET_TYPE_ERROR_TRACKING,
  WIDGET_TYPE_HEALTH_STATUS,
  WIDGET_TYPE_HIERARCHY,
  WIDGET_TYPE_ITERATION,
  WIDGET_TYPE_LABELS,
  WIDGET_TYPE_LINKED_ITEMS,
  WIDGET_TYPE_LINKED_RESOURCES,
  WIDGET_TYPE_MILESTONE,
  WIDGET_TYPE_NOTES,
  WIDGET_TYPE_START_AND_DUE_DATE,
  WIDGET_TYPE_STATUS,
  WIDGET_TYPE_TIME_TRACKING,
  WIDGET_TYPE_VULNERABILITIES,
  WIDGET_TYPE_WEIGHT,
  WORK_ITEM_TYPE_NAME_ISSUE,
  WORK_ITEM_TYPE_ROUTE_WORK_ITEM,
} from './constants';

export const isAssigneesWidget = (widget) => widget.type === WIDGET_TYPE_ASSIGNEES;

export const isMilestoneWidget = (widget) => widget.type === WIDGET_TYPE_MILESTONE;

export const isNotesWidget = (widget) => widget.type === WIDGET_TYPE_NOTES;

export const findAssigneesWidget = (workItem) =>
  workItem?.widgets?.find((widget) => widget.type === WIDGET_TYPE_ASSIGNEES);

export const findAwardEmojiWidget = (workItem) =>
  workItem?.widgets?.find((widget) => widget.type === WIDGET_TYPE_AWARD_EMOJI);

export const findColorWidget = (workItem) =>
  workItem?.widgets?.find((widget) => widget.type === WIDGET_TYPE_COLOR);

export const findCrmContactsWidget = (workItem) =>
  workItem?.widgets?.find((widget) => widget.type === WIDGET_TYPE_CRM_CONTACTS);

export const findCurrentUserTodosWidget = (workItem) =>
  workItem?.widgets?.find((widget) => widget.type === WIDGET_TYPE_CURRENT_USER_TODOS);

export const findCustomFieldsWidget = (workItem) =>
  workItem?.widgets?.find((widget) => widget.type === WIDGET_TYPE_CUSTOM_FIELDS);

export const findDescriptionWidget = (workItem) =>
  workItem?.widgets?.find((widget) => widget.type === WIDGET_TYPE_DESCRIPTION);

export const findDesignsWidget = (workItem) =>
  workItem?.widgets?.find((widget) => widget.type === WIDGET_TYPE_DESIGNS);

export const findDevelopmentWidget = (workItem) =>
  workItem?.widgets?.find((widget) => widget.type === WIDGET_TYPE_DEVELOPMENT);

export const findEmailParticipantsWidget = (workItem) =>
  workItem?.widgets?.find((widget) => widget.type === WIDGET_TYPE_EMAIL_PARTICIPANTS);

export const findErrorTrackingWidget = (workItem) =>
  workItem?.widgets?.find((widget) => widget.type === WIDGET_TYPE_ERROR_TRACKING);

export const findHealthStatusWidget = (workItem) =>
  workItem?.widgets?.find((widget) => widget.type === WIDGET_TYPE_HEALTH_STATUS);

export const findHierarchyWidget = (workItem) =>
  workItem?.widgets?.find((widget) => widget.type === WIDGET_TYPE_HIERARCHY);

export const findIterationWidget = (workItem) =>
  workItem?.widgets?.find((widget) => widget.type === WIDGET_TYPE_ITERATION);

export const findLabelsWidget = (workItem) =>
  workItem?.widgets?.find((widget) => widget.type === WIDGET_TYPE_LABELS);

export const findLinkedItemsWidget = (workItem) =>
  workItem?.widgets?.find((widget) => widget.type === WIDGET_TYPE_LINKED_ITEMS);

export const findLinkedResourcesWidget = (workItem) =>
  workItem?.widgets?.find((widget) => widget.type === WIDGET_TYPE_LINKED_RESOURCES);

export const findMilestoneWidget = (workItem) =>
  workItem?.widgets?.find((widget) => widget.type === WIDGET_TYPE_MILESTONE);

export const findNotesWidget = (workItem) =>
  workItem?.widgets?.find((widget) => widget.type === WIDGET_TYPE_NOTES);

export const findStartAndDueDateWidget = (workItem) =>
  workItem?.widgets?.find((widget) => widget.type === WIDGET_TYPE_START_AND_DUE_DATE);

export const findStatusWidget = (workItem) =>
  workItem?.widgets?.find((widget) => widget.type === WIDGET_TYPE_STATUS);

export const findTimeTrackingWidget = (workItem) =>
  workItem?.widgets?.find((widget) => widget.type === WIDGET_TYPE_TIME_TRACKING);

export const findVulnerabilitiesWidget = (workItem) =>
  workItem?.widgets?.find((widget) => widget.type === WIDGET_TYPE_VULNERABILITIES);

export const findWeightWidget = (workItem) =>
  workItem?.widgets?.find((widget) => widget.type === WIDGET_TYPE_WEIGHT);
==== app/components/rapid_diffs/diff_file_header_component.html.haml ====
-# TODO: add file size
-# TODO: add comment button
-# TODO: add viewed toggle
-# TODO: add raw\rendered toggle
-# TODO: add file actions:
-#  * view file
-#  * view replaced file (for image diffs)
-#  * view on environment
-#  * edit
-#  * open in WebIDE
-#  * toggle file comments
-#  * submodule compare

.rd-diff-file-header-sticky
  %header.rd-diff-file-header{ data: { testid: 'rd-diff-file-header' }, aria: { label: root_label } }
    .rd-diff-file-toggle<
      = render Pajamas::ButtonComponent.new(category: :tertiary, size: :small, icon: 'chevron-down', button_options: { class: 'rd-diff-file-toggle-button', data: { opened: '', click: 'toggleFile' }, aria: { label: _('Hide file contents'), expanded: 'true' } })
      = render Pajamas::ButtonComponent.new(category: :tertiary, size: :small, icon: 'chevron-right', button_options: { class: 'rd-diff-file-toggle-button', data: { closed: '', click: 'toggleFile' }, aria: { label: _('Show file contents'), expanded: 'false' } })
    .rd-diff-file-header-main><
      - if @diff_file.submodule?
        .rd-diff-file-header-submodule{ data: { testid: 'rd-diff-file-header-submodule' } }><
          = helpers.sprite_icon('folder-git', file_icon: true, css_class: 'rd-submodule-icon', aria_label: s_('RapidDiffs|Submodule'))
          %h2.rd-diff-file-title{ id: heading_id }><
            = helpers.submodule_link(@diff_file.blob, @diff_file.content_sha, @diff_file.repository)
        = copy_path_button
      - else
        -# TODO: add icons for file types
        - if @diff_file.renamed_file?
          - old_path, new_path = helpers.mark_inline_diffs(@diff_file.old_path, @diff_file.new_path)
          %h2.rd-diff-file-title{ id: heading_id, aria: { label: moved_title_label } }><
            = link_to file_link, { class: 'rd-diff-file-link', target: '_blank' } do
              = old_path
              %span.rd-diff-file-moved>< 
              = new_path
        - else
          %h2.rd-diff-file-title{ id: heading_id }><
            = link_to file_link, { class: 'rd-diff-file-link', target: '_blank' } do
              - chunks = file_title_chunks
              - chunks[:path_parts].each do |part|
                = part
                = '/'
                -# allow paths to wrap around '/' symbols for better visuals
                %wbr><
              = chunks[:filename]
          - if @diff_file.deleted_file?
            %span.rd-diff-file-deleted><= _("deleted")
          = copy_path_button
        - if @diff_file.mode_changed?
          %small.rd-file-mode-change>< #{@diff_file.a_mode}&nbsp;&nbsp;#{@diff_file.b_mode}
        - if @diff_file.stored_externally? && @diff_file.external_storage == :lfs
          = helpers.gl_badge_tag(_('LFS'), variant: :neutral)
    .rd-diff-file-info
      .rd-diff-file-stats{ aria: { label: stats_label } }
        - if @diff_file.binary?
          - if @diff_file.new_file?
            %span.rd-stats-added +#{pretty_print_bytes(@diff_file.new_blob.size)}
          - elsif @diff_file.deleted_file?
            %span.rd-stats-removed #{pretty_print_bytes(@diff_file.old_blob.size)}
          - else
            - byte_diff = @diff_file.new_blob.size - @diff_file.old_blob.size
            - if byte_diff > 0
              %span.rd-stats-added +#{pretty_print_bytes(byte_diff)}
            - elsif byte_diff < 0
              %span.rd-stats-removed #{pretty_print_bytes(byte_diff.abs)}
            %span (#{pretty_print_bytes(@diff_file.new_blob.size)})
        - else
          %span.rd-stats-added +#{@diff_file.added_lines}
          %span.rd-stats-removed #{@diff_file.removed_lines}
      - unless menu_items.empty?
        .rd-diff-file-options-menu
          %div{ data: { options_menu: true } }
            -# <script> here is likely the most effective way to minimize bytes:
            -# https://gitlab.com/gitlab-org/gitlab/-/merge_requests/182850#note_2387011092
            -# haml-lint:disable InlineJavaScript
            %script{ type: "application/json" }
              = menu_items.map { |item| item.except(:position) }.to_json.html_safe
            - button_params = { icon: 'ellipsis_v', button_options: { data: { click: 'toggleOptionsMenu' }, aria: { label: s_('RapidDiffs|Show options') } } }
            = render Pajamas::ButtonComponent.new(category: :tertiary, size: :small, **button_params)
==== app/controllers/admin/application_settings_controller.rb ====
# frozen_string_literal: true

module Admin
  class ApplicationSettingsController < Admin::ApplicationController
    include InternalRedirect
    include IntegrationsHelper
    include DefaultBranchProtection

    # NOTE: Use @application_setting in this controller when you need to access
    # application_settings after it has been modified. This is because the
    # ApplicationSetting model uses Gitlab::ProcessMemoryCache for caching and the
    # cache might be stale immediately after an update.
    # https://gitlab.com/gitlab-org/gitlab-foss/-/merge_requests/30233
    before_action :set_application_setting, except: :integrations

    before_action :disable_query_limiting, only: [:usage_data]
    before_action :prerecorded_service_ping_data, only: [:metrics_and_profiling] # rubocop:disable Rails/LexicallyScopedActionFilter

    before_action do
      push_frontend_feature_flag(:ci_variables_pages, current_user)
    end

    feature_category :not_owned, [ # rubocop:todo Gitlab/AvoidFeatureCategoryNotOwned
      :general, :reporting, :metrics_and_profiling, :network,
      :preferences, :update, :reset_health_check_token
    ]

    urgency :low, [
      :reset_error_tracking_access_token
    ]

    feature_category :source_code_management, [:repository, :clear_repository_check_states]
    feature_category :continuous_integration, [:ci_cd, :reset_registration_token]
    urgency :low, [:ci_cd, :reset_registration_token]
    feature_category :service_ping, [:usage_data]
    feature_category :integrations, [:integrations, :slack_app_manifest_share, :slack_app_manifest_download]
    feature_category :pages, [:lets_encrypt_terms_of_service]
    feature_category :observability, [:reset_error_tracking_access_token]
    feature_category :global_search, [:search]
    feature_category :environment_management, [:usage_quotas]

    VALID_SETTING_PANELS = %w[general repository
      ci_cd reporting metrics_and_profiling
      network preferences].freeze

    # The current size of a sidekiq job's jid is 24 characters. The size of the
    # jid is an internal detail of Sidekiq, and they do not guarantee that it'll
    # stay the same. We chose 50 to give us room in case the size of the jid
    # increases. The jid is alphanumeric, so 50 is very generous. There is a spec
    # that ensures that the constant value is more than the size of an actual jid.
    PARAM_JOB_ID_MAX_SIZE = 50

    VALID_SETTING_PANELS.each do |action|
      define_method(action) { perform_update if submitted? }
    end

    def integrations
      return not_found unless instance_level_integrations?

      @integrations = Integration.find_or_initialize_all_non_project_specific(
        Integration.for_instance, include_instance_specific: true
      ).sort_by { |int| int.title.downcase }
    end

    def update
      perform_update
    end

    def usage_data
      return not_found unless prerecorded_service_ping_data.present?

      respond_to do |format|
        format.html do
          usage_data_json = Gitlab::Json.pretty_generate(prerecorded_service_ping_data)

          render html: Gitlab::Highlight.highlight('payload.json', usage_data_json, language: 'json')
        end

        format.json do
          Gitlab::InternalEvents.track_event('usage_data_download_payload_clicked', user: current_user)

          render json: Gitlab::Json.dump(prerecorded_service_ping_data)
        end
      end
    end

    def reset_registration_token
      ::Ci::Runners::ResetRegistrationTokenService.new(@application_setting, current_user).execute

      flash[:notice] = _('New runners registration token has been generated!')
      redirect_to admin_runners_path
    end

    def reset_health_check_token
      @application_setting.reset_health_check_access_token!
      flash[:notice] = _('New health check access token has been generated!')
      redirect_back_or_default
    end

    def reset_error_tracking_access_token
      @application_setting.reset_error_tracking_access_token!

      redirect_to general_admin_application_settings_path,
        notice: _('New error tracking access token has been generated!')
    end

    def clear_repository_check_states
      RepositoryCheck::ClearWorker.perform_async # rubocop:disable CodeReuse/Worker

      redirect_to(
        general_admin_application_settings_path,
        notice: _('Started asynchronous removal of all repository check states.')
      )
    end

    # Getting ToS url requires `directory` api call to Let's Encrypt
    # which could result in 500 error/slow rendering on settings page
    # Because of that we use separate controller action
    def lets_encrypt_terms_of_service
      redirect_to ::Gitlab::LetsEncrypt.terms_of_service_url
==== app/controllers/concerns/confirm_email_warning.rb ====
# frozen_string_literal: true

module ConfirmEmailWarning
  include Gitlab::Utils::StrongMemoize
  extend ActiveSupport::Concern

  included do
    before_action :set_confirm_warning, if: :show_confirm_warning?
  end

  protected

  def show_confirm_warning?
    html_request? && request.get? && Gitlab::CurrentSettings.email_confirmation_setting_soft?
  end

  def set_confirm_warning
    return unless current_user
    return if current_user.confirmed?

    flash.now[:warning] = format(
      confirm_warning_message,
      email: email_to_display,
      resend_link: view_context.link_to(_('Resend it'), user_confirmation_path(user: { email: email }), method: :post),
      update_link: view_context.link_to(_('Update it'), user_settings_profile_path)
    ).html_safe
  end

  private

  def email
    current_user.unconfirmed_email || current_user.email
  end
  strong_memoize_attr :email

  def confirm_warning_message
    _("Please check your email (%{email}) to verify that you own this address and unlock the power of CI/CD. " \
      "Didn't receive it? %{resend_link}. Wrong email address? %{update_link}.")
  end

  def email_to_display
    ERB::Util.html_escape(email)
  end
end
==== app/controllers/concerns/wiki_actions.rb ====
# frozen_string_literal: true

module WikiActions
  include DiffHelper
  include PreviewMarkdown
  include SendsBlob
  include Gitlab::Utils::StrongMemoize
  include ProductAnalyticsTracking
  include SafeFormatHelper
  extend ActiveSupport::Concern
  include StrongPaginationParams

  RESCUE_GIT_TIMEOUTS_IN = %w[show raw edit history diff pages templates].freeze

  included do
    content_security_policy do |p|
      next if p.directives.blank?
      next unless Gitlab::CurrentSettings.diagramsnet_enabled?

      default_frame_src = p.directives['frame-src'] || p.directives['default-src']
      frame_src_values = Array.wrap(default_frame_src) | [Gitlab::CurrentSettings.diagramsnet_url].compact

      p.frame_src(*frame_src_values)
    end

    before_action { respond_to :html }

    before_action :authorize_read_wiki!
    before_action :authorize_create_wiki!, only: [:edit, :create, :destroy]

    before_action :wiki
    before_action :page, only: [:show, :edit, :update, :history, :destroy, :diff]
    before_action :load_sidebar, except: [:pages]

    before_action do
      push_frontend_feature_flag(:preserve_markdown, container)

      if Feature.enabled?(:glql_work_items, container) || Feature.enabled?(:glql_work_items, current_user)
        push_force_frontend_feature_flag(:glql_work_items, true)
      end

      push_force_frontend_feature_flag(:glql_load_on_click, !!container&.glql_load_on_click_feature_flag_enabled?)
    end

    before_action only: [:show, :edit, :update] do
      @valid_encoding = valid_encoding?
    end

    before_action only: [:edit, :update], unless: :valid_encoding? do
      if params[:id].present?
        redirect_to wiki_page_path(wiki, page || params[:id])
      else
        redirect_to wiki_path(wiki)
      end
    end

    track_internal_event :show, name: 'view_wiki_page'

    helper_method :view_file_button, :diff_file_html_data

    rescue_from ::Gitlab::Git::CommandTimedOut do |exc|
      raise exc unless RESCUE_GIT_TIMEOUTS_IN.include?(action_name)

      render 'shared/wikis/git_error'
    end

    rescue_from Gitlab::Git::Repository::NoRepository do
      @error = s_('Wiki|Could not access the Wiki Repository at this time.')

      render 'shared/wikis/empty'
    end
  end

  def new
    redirect_to wiki_page_path(wiki, SecureRandom.uuid, random_title: true, view: 'create')
  end

  # rubocop:disable Gitlab/ModuleWithInstanceVariables
  def pages
    @wiki_entries = WikiDirectory.group_pages(pages_list)

    render 'shared/wikis/pages'
  end

  def pages_list
    strong_memoize(:pages_list) do
      Kaminari.paginate_array(
        # only include pages not starting with 'templates/'
        wiki
          .list_pages(direction: params[:direction])
          .reject { |page| page.slug.start_with?('templates/') }
      ).page(pagination_params[:page])
    end
  end

  def templates_list
    strong_memoize(:templates_list) do
      Kaminari.paginate_array(
        # only include pages starting with 'templates/'
        wiki
          .list_pages(direction: params[:direction])
          .select { |page| page.slug.start_with?('templates/') }
      ).page(pagination_params[:page])
    end
  end

  def templates
    @wiki_entries_count = templates_list.total_count
    @wiki_entries = WikiDirectory.group_pages(templates_list, templates: true)

    render 'shared/wikis/templates'
  end
  # rubocop:enable Gitlab/ModuleWithInstanceVariables

  # `#show` handles a number of scenarios:
  #
  # - If `id` matches a WikiPage, then show the wiki page.
  # - If `id` is a file in the wiki repository, then send the file.
  # - If we know the user wants to create a new page with the given `id`,
  #   then display a create form.
==== app/controllers/groups_controller.rb ====
# frozen_string_literal: true

class GroupsController < Groups::ApplicationController
  include API::Helpers::RelatedResourcesHelpers
  include Groups::Params
  include IssuableCollectionsAction
  include ParamsBackwardCompatibility
  include PreviewMarkdown
  include RecordUserLastActivity
  include SendFileUpload
  include FiltersEvents
  extend ::Gitlab::Utils::Override

  respond_to :html

  prepend_before_action(only: [:show, :issues]) { authenticate_sessionless_user!(:rss) }
  prepend_before_action(only: [:issues_calendar]) { authenticate_sessionless_user!(:ics) }

  before_action :authenticate_user!, only: [:new, :create]
  before_action :group, except: [:index, :new, :create]

  # Authorize
  before_action :authorize_admin_group!, only: [:update, :transfer, :export, :download_export]
  before_action :authorize_view_edit_page!, only: :edit
  before_action :authorize_remove_group!, only: [:destroy, :restore]
  before_action :authorize_create_group!, only: [:new]

  before_action :group_projects, only: [:activity, :issues, :merge_requests]
  before_action :event_filter, only: [:activity]

  before_action :user_actions, only: [:show]

  before_action :check_export_rate_limit!, only: [:export, :download_export]

  before_action only: :issues do
    push_force_frontend_feature_flag(:work_items, group.work_items_feature_flag_enabled?)
    push_force_frontend_feature_flag(:work_items_beta, group.work_items_beta_feature_flag_enabled?)
    push_force_frontend_feature_flag(:work_items_alpha, group.work_items_alpha_feature_flag_enabled?)
    push_frontend_feature_flag(:issues_list_create_modal, group)
    push_frontend_feature_flag(:issues_list_drawer, group)
    push_frontend_feature_flag(:work_item_status_feature_flag, group&.root_ancestor)
  end

  skip_cross_project_access_check :index, :new, :create, :edit, :update, :destroy
  # When loading show as an atom feed, we render events that could leak cross
  # project information
  skip_cross_project_access_check :show, if: -> { request.format.html? }

  layout :determine_layout

  feature_category :groups_and_projects, [
    :index, :new, :create, :show, :edit, :update,
    :destroy, :details, :transfer, :activity, :restore
  ]
  feature_category :team_planning, [:issues, :issues_calendar, :preview_markdown]
  feature_category :code_review_workflow, [:merge_requests]
  feature_category :importers, [:export, :download_export]
  feature_category :continuous_delivery, [:unfoldered_environment_names]
  urgency :low, [:export, :download_export]

  urgency :high, [:unfoldered_environment_names]

  urgency :low, [:issues, :issues_calendar, :preview_markdown]
  # TODO: Set #show to higher urgency after resolving https://gitlab.com/gitlab-org/gitlab/-/issues/334795
  urgency :low, [:merge_requests, :show, :create, :new, :update, :destroy, :edit, :activity]

  def index
    redirect_to(current_user ? dashboard_groups_path : explore_groups_path)
  end

  def new
    @parent_group = Group.find_by_id(params[:parent_id])
    @group = Group.new(params.permit(:parent_id))
    @group.build_namespace_settings
  end

  def create
    response = Groups::CreateService.new(
      current_user,
      group_params.merge(organization_id: Current.organization.id)
    ).execute
    @group = response[:group]

    if response.success?
      successful_creation_hooks

      notice = if @group.chat_team.present?
                 format(
                   _("Group %{group_name} and its Mattermost team were successfully created."),
                   group_name: @group.name
                 )
               else
                 format(
                   _("Group %{group_name} was successfully created."),
                   group_name: @group.name
                 )
               end

      redirect_to @group, notice: notice
    else
      render action: "new"
    end
  end

  def show
    respond_to do |format|
      format.html do
        if @group.import_state&.in_progress?
          redirect_to group_import_path(@group)
        else
          render_show_html
        end
      end

      format.atom do
        render_details_view_atom
      end
    end
  end

==== app/controllers/import/source_users_controller.rb ====
# frozen_string_literal: true

module Import
  class SourceUsersController < ApplicationController
    before_action :check_source_user_valid!

    respond_to :html
    feature_category :importers

    def accept
      result = ::Import::SourceUsers::AcceptReassignmentService.new(
        source_user, current_user: current_user, reassignment_token: params[:reassignment_token]
      ).execute

      if result.success?
        flash[:raw] = banner('accept_invite')
        redirect_to(root_path)
      else
        redirect_to(root_path, alert: s_('UserMapping|The invitation could not be accepted.'))
      end
    end

    def decline
      result = ::Import::SourceUsers::RejectReassignmentService.new(
        source_user, current_user: current_user, reassignment_token: params[:reassignment_token]
      ).execute

      if result.success?
        flash[:raw] = banner('reject_invite')
        redirect_to(root_path)
      else
        redirect_to(root_path, alert: s_('UserMapping|The invitation could not be declined.'))
      end
    end

    def show; end

    private

    def check_source_user_valid!
      return if source_user&.awaiting_approval? && current_user_matches_invite?

      flash[:raw] = banner('invalid_invite')
      redirect_to(root_path)
    end

    def current_user_matches_invite?
      current_user.id == source_user.reassign_to_user_id
    end

    def source_user
      Import::SourceUser.find_by_reassignment_token(params[:reassignment_token])
    end
    strong_memoize_attr :source_user

    def banner(partial)
      render_to_string(
        partial: partial,
        layout: false,
        formats: :html,
        locals: {
          source_user: source_user
        }
      ).html_safe # rubocop: disable Rails/OutputSafety -- render_to_string already makes the string safe
    end
  end
end
==== app/controllers/profiles/two_factor_auths_controller.rb ====
# frozen_string_literal: true

class Profiles::TwoFactorAuthsController < Profiles::ApplicationController
  skip_before_action :check_two_factor_requirement
  before_action :ensure_verified_primary_email, only: [:show, :create]
  before_action :validate_current_password,
    only: [:create, :codes, :destroy, :destroy_otp, :destroy_webauthn, :create_webauthn],
    if: :current_password_required?
  before_action :update_current_user_otp!, only: [:show]

  helper_method :current_password_required?

  feature_category :system_access

  include SafeFormatHelper

  def show
    setup_show_page
  end

  def create
    otp_validation_result =
      ::Users::ValidateManualOtpService.new(current_user).execute(params[:pin_code])
    validated = (otp_validation_result[:status] == :success)

    if validated && current_user.otp_backup_codes?
      ActiveSession.destroy_all_but_current(current_user, session)
      Users::UpdateService.new(current_user, user: current_user, otp_required_for_login: true).execute!
      redirect_to profile_two_factor_auth_path, notice: _("Your Time-based OTP device was registered!")
    elsif validated
      ActiveSession.destroy_all_but_current(current_user, session)

      Users::UpdateService.new(current_user, user: current_user, otp_required_for_login: true).execute! do |user|
        @codes = user.generate_otp_backup_codes!
      end

      helpers.dismiss_two_factor_auth_recovery_settings_check

      render 'create'
    else
      @otp_error = { message: _('Invalid pin code.') }
      @account_string = account_string

      setup_show_page

      render 'show'
    end
  end

  def create_webauthn
    @webauthn_registration = Webauthn::RegisterService.new(
      current_user,
      device_registration_params,
      session[:challenge]
    ).execute

    notice = _("Your WebAuthn device was registered!")
    if @webauthn_registration.persisted?
      session.delete(:challenge)

      if current_user.otp_backup_codes?
        redirect_to profile_two_factor_auth_path, notice: notice
      else

        Users::UpdateService.new(current_user, user: current_user).execute! do |user|
          @codes = current_user.generate_otp_backup_codes!
        end
        helpers.dismiss_two_factor_auth_recovery_settings_check
        flash[:notice] = notice
        render 'create'
      end
    else
      @qr_code = build_qr_code

      setup_webauthn_registration

      render :show
    end
  end

  def codes
    Users::UpdateService.new(current_user, user: current_user).execute! do |user|
      @codes = user.generate_otp_backup_codes!

      helpers.dismiss_two_factor_auth_recovery_settings_check
    end
  end

  def destroy
    result = TwoFactor::DestroyService.new(current_user, user: current_user).execute

    if result[:status] == :success
      redirect_to profile_account_path,
        status: :found,
        notice: _('Two-factor authentication has been disabled successfully!')
    else
      redirect_to profile_account_path, status: :found, alert: result[:message]
    end
  end

  def destroy_otp
    result = TwoFactor::DestroyOtpService.new(current_user, user: current_user).execute

    if result[:status] == :success
      redirect_to profile_two_factor_auth_path,
        status: :found,
        notice: _('One-time password authenticator has been deleted!')
    else
      redirect_to profile_two_factor_auth_path, status: :found, alert: result[:message]
    end
  end

  def destroy_webauthn
    Webauthn::DestroyService.new(current_user, current_user, params[:id]).execute

    redirect_to profile_two_factor_auth_path, status: :found, notice: _("Successfully deleted WebAuthn device.")
  end

  def skip
    if two_factor_grace_period_expired?
==== app/controllers/projects/environments_controller.rb ====
# frozen_string_literal: true

class Projects::EnvironmentsController < Projects::ApplicationController
  include ProductAnalyticsTracking
  include KasCookie

  MIN_SEARCH_LENGTH = 3
  ACTIVE_STATES = %i[available stopping].freeze
  SCOPES_TO_STATES = { "active" => ACTIVE_STATES, "stopped" => %i[stopped] }.freeze

  layout 'project'

  before_action only: [:show] do
    push_frontend_feature_flag(:k8s_tree_view, project)
  end

  before_action :authorize_read_environment!
  before_action :authorize_create_environment!, only: [:new, :create]
  before_action :authorize_stop_environment!, only: [:stop]
  before_action :authorize_update_environment!, only: [:edit, :update, :cancel_auto_stop]
  before_action :authorize_admin_environment!, only: [:terminal, :terminal_websocket_authorize]
  before_action :environment,
    only: [:show, :edit, :update, :stop, :terminal, :terminal_websocket_authorize, :cancel_auto_stop, :k8s]
  before_action :verify_api_request!, only: :terminal_websocket_authorize
  before_action :expire_etag_cache, only: [:index], unless: -> { request.format.json? }
  before_action :set_kas_cookie, only: [:edit, :new, :show, :k8s], if: -> { current_user && request.format.html? }
  after_action :expire_etag_cache, only: [:cancel_auto_stop]

  track_event :index, :folder, :show, :new, :edit, :create, :update, :stop, :cancel_auto_stop, :terminal, :k8s,
    name: 'users_visiting_environments_pages'

  feature_category :continuous_delivery
  urgency :low

  def index
    @project = ProjectPresenter.new(project, current_user: current_user)

    respond_to do |format|
      format.html
      format.json do
        states = SCOPES_TO_STATES.fetch(params[:scope], ACTIVE_STATES)
        @environments = search_environments.with_state(states)

        environments_count_by_state = search_environments.count_by_state

        Gitlab::PollingInterval.set_header(response, interval: 3_000)
        render json: {
          environments: serialize_environments(request, response, params[:nested]),
          review_app: serialize_review_app,
          can_stop_stale_environments: can?(current_user, :stop_environment, @project),
          available_count: environments_count_by_state[:available],
          active_count: environments_count_by_state[:available] + environments_count_by_state[:stopping],
          stopped_count: environments_count_by_state[:stopped]
        }
      end
    end
  end

  # Returns all environments for a given folder
  # rubocop: disable CodeReuse/ActiveRecord
  def folder
    @folder = params[:id]

    respond_to do |format|
      format.html
      format.json do
        states = SCOPES_TO_STATES.fetch(params[:scope], ACTIVE_STATES)
        folder_environments = search_environments(type: params[:id])

        @environments = folder_environments.with_state(states)
          .order(:name)

        render json: {
          environments: serialize_environments(request, response),
          available_count: folder_environments.available.count,
          active_count: folder_environments.active.count,
          stopped_count: folder_environments.stopped.count
        }
      end
    end
  end
  # rubocop: enable CodeReuse/ActiveRecord

  def show; end

  def new
    @environment = project.environments.new
  end

  def edit; end

  def k8s
    render action: :show
  end

  def create
    @environment = project.environments.create(environment_params)

    if @environment.persisted?
      render json: { environment: @environment, path: project_environment_path(project, @environment) }
    else
      render json: { message: @environment.errors.full_messages }, status: :bad_request
    end
  end

  def update
    if @environment.update(environment_params)
      render json: { environment: @environment, path: project_environment_path(project, @environment) }
    else
      render json: { message: @environment.errors.full_messages }, status: :bad_request
    end
  end

  def stop
    return render_404 unless @environment.available?

    service_response = Environments::StopService.new(project, current_user).execute(@environment)
    return render_403 unless service_response.success?

    job = service_response[:actions].first if service_response[:actions]&.count == 1
==== app/controllers/projects/labels_controller.rb ====
# frozen_string_literal: true

class Projects::LabelsController < Projects::ApplicationController
  include ToggleSubscriptionAction

  before_action :check_issuables_available!
  before_action :label, only: [:edit, :update, :destroy, :promote]
  before_action :find_labels, only: [:index, :set_priorities, :remove_priority, :toggle_subscription]
  before_action :authorize_read_label!
  before_action :authorize_admin_labels!, only: [:new, :create, :edit, :update,
    :generate, :destroy, :remove_priority,
    :set_priorities]
  before_action :authorize_admin_group_labels!, only: [:promote]

  respond_to :js, :html

  feature_category :team_planning
  urgency :low

  def index
    respond_to do |format|
      format.html do
        @prioritized_labels = @available_labels.prioritized(@project)
        @labels = @available_labels.unprioritized(@project).page(params[:page])
        # preload group, project, and subscription data
        Preloaders::LabelsPreloader.new(@prioritized_labels, current_user, @project).preload_all
        Preloaders::LabelsPreloader.new(@labels, current_user, @project).preload_all
      end
      format.json do
        render json: LabelSerializer.new.represent_appearance(@available_labels)
      end
    end
  end

  def new
    @label = @project.labels.new
  end

  def create
    @label = Labels::CreateService.new(label_params).execute(project: @project)

    if @label.valid?
      respond_to do |format|
        format.html { redirect_to project_labels_path(@project) }
        format.json { render json: @label }
      end
    else
      respond_to do |format|
        format.html { render :new }
        format.json { render json: { message: @label.errors.messages }, status: :bad_request }
      end
    end
  end

  def edit; end

  def update
    @label = Labels::UpdateService.new(label_params).execute(@label)

    if @label.valid?
      redirect_to project_labels_path(@project)
    else
      render :edit
    end
  end

  def generate
    Gitlab::IssuesLabels.generate(@project)

    case params[:redirect]
    when 'issues'
      redirect_to project_issues_path(@project)
    when 'merge_requests'
      redirect_to project_merge_requests_path(@project)
    else
      redirect_to project_labels_path(@project)
    end
  end

  def destroy
    if @label.destroy
      redirect_to project_labels_path(@project), status: :found,
        notice: format(_('%{label_name} was removed'), label_name: @label.name)
    else
      redirect_to project_labels_path(@project), status: :found,
        alert: @label.errors.full_messages.to_sentence
    end
  end

  def remove_priority
    respond_to do |format|
      label = @available_labels.find(params[:id])

      if label.unprioritize!(project)
        format.json { render json: label }
      else
        format.json { head :unprocessable_entity }
      end
    end
  end

  # rubocop: disable CodeReuse/ActiveRecord
  def set_priorities
    Label.transaction do
      available_labels_ids = @available_labels.where(id: params[:label_ids]).pluck(:id)
      label_ids = params[:label_ids].select { |id| available_labels_ids.include?(id.to_i) }

      label_ids.each_with_index do |label_id, index|
        label = @available_labels.find(label_id)
        label.prioritize!(project, index)
      end
    end

    respond_to do |format|
      format.json { render json: { message: 'success' } }
    end
  end
  # rubocop: enable CodeReuse/ActiveRecord

  def promote
==== app/controllers/projects/milestones_controller.rb ====
# frozen_string_literal: true

class Projects::MilestonesController < Projects::ApplicationController
  include Gitlab::Utils::StrongMemoize
  include MilestoneActions

  REDIRECT_TARGETS = [:new_release].freeze

  before_action :check_issuables_available!
  before_action :milestone, only: [:edit, :update, :destroy, :show, :issues, :merge_requests, :participants, :labels, :promote]
  before_action :redirect_path, only: [:new, :create]

  # Allow read any milestone
  before_action :authorize_read_milestone!

  # Allow admin milestone
  before_action :authorize_admin_milestone!, except: [:index, :show, :issues, :merge_requests, :participants, :labels]

  # Allow to promote milestone
  before_action :authorize_promote_milestone!, only: :promote

  respond_to :html

  feature_category :team_planning
  urgency :low

  def index
    @sort = params[:sort] || 'due_date_asc'
    @milestones = milestones.sort_by_attribute(@sort)

    respond_to do |format|
      format.html do
        @milestone_states = Milestone.states_count(@project)
        # We need to show group milestones in the JSON response
        # so that people can filter by and assign group milestones,
        # but we don't need to show them on the project milestones page itself.
        @milestones = @milestones.for_projects
        @milestones = @milestones.page(params[:page])
      end
      format.json do
        render json: @milestones.to_json(only: [:id, :title, :due_date], methods: :name)
      end
    end
  end

  def new
    @noteable = @milestone = @project.milestones.new
    respond_with(@milestone)
  end

  def edit
    respond_with(@milestone)
  end

  def show
    respond_to do |format|
      format.html
    end
  end

  def create
    @milestone = Milestones::CreateService.new(project, current_user, milestone_params).execute

    if @milestone.valid?
      if @redirect_path == :new_release
        redirect_to new_project_release_path(@project)
      else
        redirect_to project_milestone_path(@project, @milestone)
      end
    else
      render "new"
    end
  end

  def update
    @milestone = Milestones::UpdateService.new(project, current_user, milestone_params).execute(milestone)

    respond_to do |format|
      format.html do
        if @milestone.valid?
          redirect_to project_milestone_path(@project, @milestone)
        else
          render :edit
        end
      end

      format.js

      format.json do
        if @milestone.valid?
          head :no_content
        else
          render json: { errors: @milestone.errors.full_messages }, status: :unprocessable_entity
        end
      end
    end
  rescue ActiveRecord::StaleObjectError
    respond_to do |format|
      format.html do
        @conflict = true
        render :edit
      end

      format.json do
        render json: {
          errors: [
            format(
              _("Someone edited this %{model_name} at the same time you did. Please refresh your browser and make sure your changes will not unintentionally remove theirs."),
              model_name: _('milestone')
            )
          ]
        }, status: :conflict
      end
    end
  end

  def promote
    promoted_milestone = Milestones::PromoteService.new(project, current_user).execute(milestone)
    flash[:notice] = flash_notice_for(promoted_milestone, project_group)

==== app/controllers/projects/protected_refs_controller.rb ====
# frozen_string_literal: true

class Projects::ProtectedRefsController < Projects::ApplicationController
  include RepositorySettingsRedirect

  # Authorize
  before_action :authorize_admin_protected_refs!
  before_action :load_protected_ref, only: [:show, :update, :destroy]

  layout "project_settings"

  feature_category :source_code_management

  def index
    redirect_to_repository_settings(@project)
  end

  def create
    protected_ref = create_service_class.new(@project, current_user, protected_ref_params).execute

    flash[:alert] = protected_ref.errors.full_messages.join(', ').html_safe unless protected_ref.persisted?

    respond_to do |format|
      format.html { redirect_to_repository_settings(@project, anchor: params[:update_section]) }
      format.json { head :ok }
    end
  end

  def show
    @matching_refs = @protected_ref.matching(project_refs)
  end

  def update
    @protected_ref = update_service_class.new(@project, current_user, protected_ref_params).execute(@protected_ref)

    if @protected_ref.valid?
      render json: @protected_ref, status: :ok, include: access_levels
    else
      render json: @protected_ref.errors, status: :unprocessable_entity
    end
  end

  def destroy
    destroy_service_class.new(@project, current_user).execute(@protected_ref)

    respond_to do |format|
      format.html { redirect_to_repository_settings(@project, anchor: params[:update_section]) }
      format.js { head :ok }
    end
  end

  protected

  def create_service_class
    service_namespace::CreateService
  end

  def update_service_class
    service_namespace::UpdateService
  end

  def destroy_service_class
    service_namespace::DestroyService
  end

  def access_level_attributes
    %i[access_level id _destroy deploy_key_id]
  end

  def authorize_admin_protected_refs!
    authorize_admin_project!
  end
end

Projects::ProtectedRefsController.prepend_mod_with('Projects::ProtectedRefsController')
==== app/helpers/admin/broadcast_messages_helper.rb ====
# frozen_string_literal: true

module Admin
  module BroadcastMessagesHelper
    include Gitlab::Utils::StrongMemoize

    def current_broadcast_banner_messages
      System::BroadcastMessage.current_banner_messages(
        current_path: request.path,
        user_access_level: current_user_access_level_for_project_or_group
      ).select do |message|
        cookies["hide_broadcast_message_#{message.id}"].blank?
      end
    end

    def current_broadcast_notification_message
      not_hidden_messages = System::BroadcastMessage.current_notification_messages(
        current_path: request.path,
        user_access_level: current_user_access_level_for_project_or_group
      ).select do |message|
        cookies["hide_broadcast_message_#{message.id}"].blank?
      end
      not_hidden_messages.last
    end

    def broadcast_message(message, opts = {})
      return unless message.present?

      render "shared/broadcast_message", { message: message, **opts }
    end

    def broadcast_message_status(broadcast_message)
      if broadcast_message.active?
        'Active'
      elsif broadcast_message.ended?
        'Expired'
      else
        'Pending'
      end
    end

    def render_broadcast_message(broadcast_message)
      if broadcast_message.notification?
        Banzai.render_field_and_post_process(broadcast_message, :message, {
          current_user: current_user,
          skip_project_check: true,
          broadcast_message_placeholders: true
        }).html_safe
      else
        Banzai.render_field(broadcast_message, :message).html_safe
      end
    end

    def target_access_level_options
      System::BroadcastMessage::ALLOWED_TARGET_ACCESS_LEVELS.map do |access_level|
        [Gitlab::Access.human_access(access_level), access_level]
      end
    end

    def target_access_levels_display(access_levels)
      access_levels.map do |access_level|
        Gitlab::Access.human_access(access_level)
      end.join(', ')
    end

    def admin_broadcast_messages_data(broadcast_messages)
      broadcast_messages.map do |message|
        {
          id: message.id,
          status: broadcast_message_status(message),
          message: message.message,
          theme: message.theme,
          broadcast_type: message.broadcast_type,
          dismissable: message.dismissable,
          starts_at: message.starts_at.iso8601,
          ends_at: message.ends_at.iso8601,
          target_roles: target_access_levels_display(message.target_access_levels),
          target_path: message.target_path,
          type: message.broadcast_type.capitalize,
          edit_path: edit_admin_broadcast_message_path(message),
          delete_path: "#{admin_broadcast_message_path(message)}.js"
        }
      end.to_json
    end

    def broadcast_message_data(broadcast_message)
      {
        id: broadcast_message.id,
        message: broadcast_message.message,
        broadcast_type: broadcast_message.broadcast_type,
        theme: broadcast_message.theme,
        dismissable: broadcast_message.dismissable.to_s,
        target_access_levels: broadcast_message.target_access_levels,
        messages_path: admin_broadcast_messages_path,
        preview_path: preview_admin_broadcast_messages_path,
        target_path: broadcast_message.target_path,
        starts_at: broadcast_message.starts_at.iso8601,
        ends_at: broadcast_message.ends_at.iso8601,
        target_access_level_options: target_access_level_options.to_json,
        show_in_cli: broadcast_message.show_in_cli.to_s
      }
    end

    private

    def current_user_access_level_for_project_or_group
      return unless current_user.present?

      strong_memoize(:current_user_access_level_for_project_or_group) do
        case controller
        when Projects::ApplicationController
          next unless @project

          @project.team.max_member_access(current_user.id)
        when Groups::ApplicationController
          next unless @group

          @group.max_member_access_for_user(current_user)
        end
      end
==== app/helpers/application_helper.rb ====
# frozen_string_literal: true

require 'uri'

module ApplicationHelper
  include ViteHelper

  # See https://docs.gitlab.com/ee/development/ee_features.html#code-in-appviews
  # rubocop: disable CodeReuse/ActiveRecord
  # We allow partial to be nil so that collection views can be passed in
  # `render partial: 'some/view', collection: @some_collection`
  def render_if_exists(partial = nil, **options)
    return unless partial_exists?(partial || options[:partial])

    if partial.nil?
      render(**options)
    else
      render(partial, options)
    end
  end

  def dispensable_render(...)
    render(...)
  rescue StandardError => e
    Gitlab::ErrorTracking.track_and_raise_for_dev_exception(e)
    nil
  end

  def dispensable_render_if_exists(...)
    render_if_exists(...)
  rescue StandardError => e
    Gitlab::ErrorTracking.track_and_raise_for_dev_exception(e)
    nil
  end

  def partial_exists?(partial)
    lookup_context.exists?(partial, [], true)
  end

  def template_exists?(template)
    lookup_context.exists?(template, [], false)
  end
  # rubocop: enable CodeReuse/ActiveRecord

  def error_css
    Rails.application
      .assets_manifest
      .find_sources('errors.css')
      .first
      .to_s
      .force_encoding('UTF-8') # See https://gitlab.com/gitlab-org/gitlab/-/merge_requests/145363
      .html_safe # rubocop:disable Rails/OutputSafety -- No escaping needed
  end

  # Check if a particular controller is the current one
  #
  # args - One or more controller names to check (using path notation when inside namespaces)
  #
  # Examples
  #
  #   # On TreeController
  #   current_controller?(:tree)           # => true
  #   current_controller?(:commits)        # => false
  #   current_controller?(:commits, :tree) # => true
  #
  #   # On Admin::ApplicationController
  #   current_controller?(:application)         # => true
  #   current_controller?('admin/application')  # => true
  #   current_controller?('gitlab/application') # => false
  def current_controller?(*args)
    args.any? do |v|
      Gitlab::Utils.safe_downcase!(v.to_s) == controller.controller_name || Gitlab::Utils.safe_downcase!(v.to_s) == controller.controller_path
    end
  end

  # Check if a particular action is the current one
  #
  # args - One or more action names to check
  #
  # Examples
  #
  #   # On Projects#new
  #   current_action?(:new)           # => true
  #   current_action?(:create)        # => false
  #   current_action?(:new, :create)  # => true
  def current_action?(*args)
    args.any? { |v| Gitlab::Utils.safe_downcase!(v.to_s) == action_name }
  end

  def admin_section?
    controller.class.ancestors.include?(Admin::ApplicationController)
  end

  def last_commit(project)
    if project.repo_exists?
      time_ago_with_tooltip(project.repository.commit.committed_date)
    else
      'Never'
    end
  rescue StandardError
    'Never'
  end

  # Define whenever show last push event
  # with suggestion to create MR
  # rubocop: disable CodeReuse/ActiveRecord
  def show_last_push_widget?(event)
    # Skip if event is not about added or modified non-master branch
    return false unless event && event.last_push_to_non_root? && !event.rm_ref?

    project = event.project

    # Skip if project repo is empty or MR disabled
    return false unless project && !project.empty_repo? && project.feature_available?(:merge_requests, current_user)

    # Skip if user already created appropriate MR
    return false if project.merge_requests.where(source_branch: event.branch_name).opened.any?

    # Skip if user removed branch right after that
    return false unless project.repository.branch_exists?(event.branch_name)
==== app/helpers/avatars_helper.rb ====
# frozen_string_literal: true

module AvatarsHelper
  DEFAULT_AVATAR_PATH = 'no_avatar.png'

  # Takes both user and email and returns the avatar_icon by
  # user (preferred) or email.
  def avatar_icon_for(user = nil, email = nil, size = nil, scale = 2, only_path: true)
    if user
      avatar_icon_for_user(user, size, scale, only_path: only_path)
    elsif email
      avatar_icon_for_email(email, size, scale, only_path: only_path)
    else
      default_avatar
    end
  end

  def avatar_icon_for_email(email = nil, size = nil, scale = 2, only_path: true, by_commit_email: false)
    return default_avatar if email.blank?

    Gitlab::AvatarCache.by_email(email, size, scale, only_path) do
      avatar_icon_by_user_email_or_gravatar(
        email,
        size,
        scale,
        only_path: only_path,
        by_commit_email: by_commit_email
      )
    end
  end

  def avatar_icon_for_user(user = nil, size = nil, scale = 2, only_path: true, current_user: nil)
    return gravatar_icon(nil, size, scale) unless user
    return default_avatar if blocked_or_unconfirmed?(user) && !can_admin?(current_user)

    image_size = !size.nil? ? size * 2 : size

    user_avatar = user.avatar_url(size: image_size, only_path: only_path)
    user_avatar || default_avatar
  end

  def gravatar_icon(user_email = '', size = nil, scale = 2)
    GravatarService.new.execute(user_email, size, scale) ||
      default_avatar
  end

  def default_avatar
    ActionController::Base.helpers.image_path(DEFAULT_AVATAR_PATH)
  end

  def author_avatar(commit_or_event, options = {})
    options[:css_class] ||= "gl-hidden sm:gl-inline-block"

    if Feature.enabled?(:cached_author_avatar_helper, options.delete(:project))
      Gitlab::AvatarCache.by_email(commit_or_event.author_email, commit_or_event.author_name, options) do
        user_avatar(options.merge({
          user: commit_or_event.author,
          user_name: commit_or_event.author_name,
          user_email: commit_or_event.author_email
        }))
      end.html_safe # rubocop: disable Rails/OutputSafety -- this is only needed as the AvatarCache is a direct Redis cache
    else
      user_avatar(options.merge({
        user: commit_or_event.author,
        user_name: commit_or_event.author_name,
        user_email: commit_or_event.author_email
      }))
    end
  end

  def user_avatar(options = {})
    avatar = user_avatar_without_link(options)

    if options[:user]
      link_to(avatar, user_path(options[:user]))
    elsif options[:user_email]
      mail_to(options[:user_email], avatar)
    end
  end

  def user_avatar_without_link(options = {})
    avatar_size = options[:size] || 16
    user_name = options[:user].try(:name) || options[:user_name]

    avatar_url = user_avatar_url_for(**options.merge(size: avatar_size))

    has_tooltip = options[:has_tooltip].nil? ? true : options[:has_tooltip]
    data_attributes = options[:data] || {}
    css_class = %W[avatar s#{avatar_size}].push(*options[:css_class])
    alt_text = user_name ? "#{user_name}'s avatar" : "default avatar"

    if has_tooltip
      css_class.push('has-tooltip')
      data_attributes[:container] = 'body'
    end

    if options[:lazy]
      css_class << 'lazy'
      data_attributes[:src] = avatar_url
      avatar_url = LazyImageTagHelper.placeholder_image
    end

    image_options = {
      alt: alt_text,
      src: avatar_url,
      data: data_attributes,
      class: css_class,
      title: user_name
    }

    tag.img(**image_options)
  end

  def avatar_without_link(resource, options = {})
    case resource
    when Namespaces::UserNamespace
      user_avatar_without_link(options.merge(user: resource.first_owner))
    when Group
      render Pajamas::AvatarComponent.new(resource, class: 'gl-avatar-circle gl-mr-3', size: 32)
    end
==== app/helpers/commits_helper.rb ====
# frozen_string_literal: true

module CommitsHelper
  include Gitlab::Utils::StrongMemoize

  # Returns a link to the commit author. If the author has a matching user and
  # is a member of the current @project it will link to the team member page.
  # Otherwise it will link to the author email as specified in the commit.
  #
  # options:
  #  avatar: true will prepend the avatar image
  #  size:   size of the avatar image in px
  def commit_author_link(commit, options = {})
    commit_person_link(commit, options.merge(source: :author))
  end

  # Just like #author_link but for the committer.
  def commit_committer_link(commit, options = {})
    commit_person_link(commit, options.merge(source: :committer))
  end

  def commit_committer_avatar(committer, options = {})
    user_avatar(options.merge({
      user: committer,
      user_name: committer.name,
      user_email: committer.email,
      css_class: 'gl-hidden sm:gl-inline-block float-none !gl-mr-0 gl-align-text-bottom'
    }))
  end

  def commit_to_html(commit, ref, project)
    render partial: 'projects/commits/commit', formats: :html, locals: {
      commit: commit,
      ref: ref,
      project: project
    }
  end

  def commit_list_app_data(project, ref, ref_type)
    {
      'project_full_path' => project.full_path,
      'project_root_path' => project_path(project),
      'project_id' => project.id.to_s,
      'escaped_ref' => ActionDispatch::Journey::Router::Utils.escape_path(ref),
      'ref_type' => ref_type.to_s,
      'root_ref' => project.default_branch
    }
  end

  # Breadcrumb links for a Project and, if applicable, a tree path
  def commits_breadcrumbs
    return unless @project && @ref

    # Add the root project link and the arrow icon
    crumbs = content_tag(:li, class: 'breadcrumb-item') do
      link_to(
        @project.path,
        project_commits_path(@project, @ref, ref_type: @ref_type)
      )
    end

    if @path
      parts = @path.split('/')

      parts.each_with_index do |part, i|
        crumbs << content_tag(:li, class: 'breadcrumb-item') do
          # The text is just the individual part, but the link needs all the parts before it
          link_to(
            part,
            project_commits_path(
              @project,
              tree_join(@ref, parts[0..i].join('/')),
              ref_type: @ref_type
            )
          )
        end
      end
    end

    crumbs.html_safe
  end

  # Returns a link formatted as a commit branch link
  def commit_branch_link(url, text)
    gl_badge_tag(text, { variant: :info, icon: 'branch' }, { href: url, class: 'gl-font-monospace gl-mb-1' })
  end

  # Returns the sorted alphabetically links to branches, separated by a comma
  def commit_branches_links(project, branches)
    branches.sort.map do |branch|
      commit_branch_link(project_ref_path(project, branch), branch)
    end.join(' ').html_safe
  end

  # Returns a link formatted as a commit tag link
  def commit_tag_link(url, text)
    gl_badge_tag(text, { variant: :info, icon: 'tag' }, { href: url, class: 'gl-font-monospace' })
  end

  # Returns the sorted links to tags, separated by a comma
  def commit_tags_links(project, tags)
    sorted = VersionSorter.rsort(tags)
    sorted.map do |tag|
      commit_tag_link(project_ref_path(project, tag), tag)
    end.join(' ').html_safe
  end

  def commit_blob
    @repo.blob_at(@ref, @path)
  end
  strong_memoize_attr :commit_blob

  def link_to_browse_code(project, commit)
    return unless current_controller?(:commits)

    if @path.blank?
      url = project_tree_path(project, commit)
      tooltip = _("Browse Files")
    elsif commit_blob.present?
      url = project_blob_path(project, tree_join(commit.id, @path))
==== app/helpers/diff_helper.rb ====
# frozen_string_literal: true

module DiffHelper
  def mark_inline_diffs(old_line, new_line)
    old_diffs, new_diffs = Gitlab::Diff::InlineDiff.new(old_line, new_line).inline_diffs

    marked_old_line = Gitlab::Diff::InlineDiffMarker.new(old_line).mark(old_diffs)
    marked_new_line = Gitlab::Diff::InlineDiffMarker.new(new_line).mark(new_diffs)

    [marked_old_line, marked_new_line]
  end

  def diffs_expanded?
    params[:expanded].present?
  end

  def diff_view
    @diff_view ||= begin
      diff_views = %w[inline parallel]
      diff_view = params[:view] || cookies[:diff_view]
      diff_view = diff_views.first unless diff_views.include?(diff_view)
      diff_view.to_sym
    end
  end

  def show_only_context_commits?
    !!params[:only_context_commits] || @merge_request.has_no_commits?
  end

  def diff_options
    options = { ignore_whitespace_change: hide_whitespace?, expanded: diffs_expanded?, use_extra_viewer_as_main: true }

    if action_name == 'diff_for_path' || action_name == 'diff_by_file_hash'
      options[:expanded] = true
      options[:paths] = params.values_at(:old_path, :new_path)
      options[:use_extra_viewer_as_main] = false

      if params[:file_identifier]&.include?('.ipynb')
        options[:max_patch_bytes_for_file_extension] = {
          '.ipynb' => 1.megabyte
        }
      end
    end

    options
  end

  def with_custom_diff_options
    yield diff_options.dup
  end

  def diff_match_line(old_pos, new_pos, text: '', view: :inline, bottom: false)
    content_line_class = %w[line_content match]
    content_line_class << 'parallel' if view == :parallel

    line_num_class = %w[diff-line-num unfold js-unfold]
    line_num_class << 'js-unfold-bottom' if bottom

    html = []

    expand_data = {}
    if bottom
      expand_data[:expand_next_line] = true
    else
      expand_data[:expand_prev_line] = true
    end

    if old_pos
      html << content_tag(:td, '...', class: [*line_num_class, 'old_line'], data: { linenumber: old_pos })
      html << content_tag(:td, text, class: [*content_line_class, 'left-side']) if view == :parallel
    end

    if new_pos
      html << content_tag(:td, '...', class: [*line_num_class, 'new_line'], data: { linenumber: new_pos })
      html << content_tag(:td, text, class: [*content_line_class, ('right-side' if view == :parallel)])
    end

    html.join.html_safe
  end

  def diff_nomappinginraw_line(line, first_line_num_class, second_line_num_class, content_line_class)
    css_class = ''
    css_class = 'old' if line.type == 'old-nomappinginraw'
    css_class = 'new' if line.type == 'new-nomappinginraw'

    html = [content_tag(:td, '', class: [*first_line_num_class, css_class])]
    html << content_tag(:td, '', class: [*second_line_num_class, css_class]) if second_line_num_class
    html << content_tag(:td, diff_line_content(line.rich_text), class: [*content_line_class, 'nomappinginraw', css_class])

    html.join.html_safe
  end

  def diff_line_content(line)
    if line.blank?
      "&nbsp;".html_safe
    elsif line.start_with?('+', '-', ' ')
      # `sub` and substring-ing would destroy HTML-safeness of `line`
      line[1, line.length]
    else
      line
    end
  end

  def diff_link_number(line_type, match, text)
    line_type == match ? " " : text
  end

  def parallel_diff_discussions(left, right, diff_file)
    return unless @grouped_diff_discussions

    discussions_left = discussions_right = nil

    if left && left.discussable? && (left.unchanged? || left.removed?)
      line_code = diff_file.line_code(left)
      discussions_left = @grouped_diff_discussions[line_code]
    end

    if right && right.discussable? && right.added?
      line_code = diff_file.line_code(right)
      discussions_right = @grouped_diff_discussions[line_code]
==== app/helpers/dropdowns_helper.rb ====
# frozen_string_literal: true

module DropdownsHelper
  def dropdown_data_attr(options: {})
    output = content_tag(:div, "", id: "js-template-selectors-menu", data: options[:data])
    output.html_safe
  end

  # rubocop:disable Metrics/CyclomaticComplexity
  def dropdown_tag(toggle_text, options: {}, &block)
    content_tag :div, class: "dropdown #{options[:wrapper_class] if options.key?(:wrapper_class)}" do
      data_attr = { toggle: "dropdown" }

      if options.key?(:data)
        data_attr = options[:data].merge(data_attr)
      end

      dropdown_output = dropdown_toggle(toggle_text, data_attr, options)

      if options.key?(:toggle_link)
        dropdown_output = dropdown_toggle_link(toggle_text, data_attr, options)
      end

      content_tag_options = { class: "dropdown-menu dropdown-select #{options[:dropdown_class] if options.key?(:dropdown_class)}" }
      content_tag_options[:data] ||= {}
      content_tag_options[:data][:testid] = (options[:dropdown_testid]).to_s if options[:dropdown_testid]

      dropdown_output << content_tag(:div, content_tag_options) do
        output = []

        if options.key?(:title)
          output << dropdown_title(options[:title])
        end

        if options.key?(:filter)
          output << dropdown_filter(options[:placeholder])
        end

        output << content_tag(:div, data: { testid: "dropdown-list-content" }, class: "dropdown-content #{options[:content_class] if options.key?(:content_class)}") do
          capture(&block) if block && !options.key?(:footer_content)
        end

        if block && options[:footer_content]
          output << content_tag(:div, class: "dropdown-footer") do
            capture(&block)
          end
        end

        output << dropdown_loading
        output.join.html_safe
      end

      dropdown_output.html_safe
    end
  end
  # rubocop:enable Metrics/CyclomaticComplexity

  def dropdown_toggle(toggle_text, data_attr, options = {})
    default_label = data_attr[:default_label]
    content_tag(:button, disabled: options[:disabled], class: "dropdown-menu-toggle #{options[:toggle_class] if options.key?(:toggle_class)}", id: (options[:id] if options.key?(:id)), type: "button", data: data_attr) do
      output = content_tag(:span, toggle_text, class: "dropdown-toggle-text #{'is-default' if toggle_text == default_label}")
      output << sprite_icon('chevron-down', css_class: "dropdown-menu-toggle-icon")
      output.html_safe
    end
  end

  def dropdown_toggle_link(toggle_text, data_attr, options = {})
    output = content_tag(:a, toggle_text, class: "dropdown-toggle-text #{options[:toggle_class] if options.key?(:toggle_class)}", id: (options[:id] if options.key?(:id)), data: data_attr)
    output.html_safe
  end

  def dropdown_title(title, options: {})
    has_back = options.fetch(:back, false)
    has_close = options.fetch(:close, true)

    container_class = %w[dropdown-title gl-flex]
    margin_class = []

    if has_back && has_close
      container_class << 'gl-justify-between'
    elsif has_back
      margin_class << 'gl-mr-auto'
    elsif has_close
      margin_class << 'gl-ml-auto'
    end

    container_class = container_class.join(' ')
    margin_class = margin_class.join(' ')

    content_tag :div, class: container_class do
      title_output = []

      if has_back
        title_output << content_tag(:button, class: "dropdown-title-button dropdown-menu-back #{margin_class}", aria: { label: "Go back" }, type: "button") do
          sprite_icon('arrow-left')
        end
      end

      title_output << content_tag(:span, title, class: margin_class)

      if has_close
        title_output << content_tag(:button, class: "dropdown-title-button dropdown-menu-close #{margin_class}", aria: { label: "Close" }, type: "button") do
          sprite_icon('close', size: 16, css_class: 'dropdown-menu-close-icon')
        end
      end

      title_output.join.html_safe
    end
  end

  def dropdown_filter(placeholder, search_id: nil)
    content_tag :div, class: "dropdown-input" do
      filter_output = search_field_tag search_id, nil, data: { testid: "dropdown-input-field" }, id: nil, class: "dropdown-input-field", placeholder: placeholder, autocomplete: 'off'
      filter_output << sprite_icon('search', css_class: 'dropdown-input-search')
      filter_output << sprite_icon('close', size: 16, css_class: 'dropdown-input-clear js-dropdown-input-clear')

      filter_output.html_safe
    end
  end

==== app/helpers/emails_helper.rb ====
# frozen_string_literal: true

module EmailsHelper
  include AppearancesHelper
  include SafeFormatHelper

  def subject_with_prefix_and_suffix(subject_line)
    prefix = Gitlab.config.gitlab.email_subject_prefix
    subject_line.unshift(prefix) if prefix.present?

    suffix = Gitlab.config.gitlab.email_subject_suffix
    subject_line << suffix if suffix.present?

    subject_line.join(' | ')
  end

  module_function :subject_with_prefix_and_suffix

  # Google Actions
  # https://developers.google.com/gmail/markup/reference/go-to-action
  def email_action(url)
    name = action_title(url)
    return unless name

    gmail_goto_action(name, url)
  end

  def action_title(url)
    return unless url

    %w[merge_requests issues work_items commit wikis].each do |action|
      return "View #{action.humanize.singularize}" if url.split("/").include?(action)
    end

    nil
  end

  def gmail_goto_action(name, url)
    data = {
      "@context" => "http://schema.org",
      "@type" => "EmailMessage",
      "action" => {
        "@type" => "ViewAction",
        "name" => name,
        "url" => url
      }
    }

    content_tag :script, type: 'application/ld+json' do
      data.to_json.html_safe
    end
  end

  def sanitize_name(name)
    if URI::DEFAULT_PARSER.regexp[:URI_REF].match?(name)
      name.tr('.', '_')
    else
      name
    end
  end

  def password_reset_token_valid_time
    valid_hours = Devise.reset_password_within / 60 / 60
    if valid_hours >= 24
      unit = 'day'
      valid_length = (valid_hours / 24).floor
    else
      unit = 'hour'
      valid_length = valid_hours.floor
    end

    pluralize(valid_length, unit)
  end

  def header_logo
    if current_appearance&.header_logo? && !current_appearance.header_logo.filename.ends_with?('.svg')
      image_tag(
        current_appearance.header_logo_path,
        style: 'height: 50px'
      )
    else
      image_tag(
        image_url('mailers/gitlab_logo.png'),
        size: '55x55',
        alt: 'GitLab'
      )
    end
  end

  def email_default_heading(text)
    content_tag :h1, text, style: [
      "font-family:'Helvetica Neue',Helvetica,Arial,sans-serif",
      'color:#333333',
      'font-size:18px',
      'font-weight:400',
      'line-height:1.4',
      'padding:0',
      'margin:0',
      'text-align:center'
    ].join(';')
  end

  def closure_reason_text(closed_via, format:, name:)
    name = sanitize_name(name)

    case closed_via
    when MergeRequest
      merge_request = MergeRequest.find(closed_via[:id]).present

      return "" unless Ability.allowed?(@recipient, :read_merge_request, merge_request)

      case format
      when :html
        merge_request_link = link_to(merge_request.to_reference, merge_request.web_url)
        safe_format(_("Issue was closed by %{name} with merge request %{link}"), name: name, link: merge_request_link)
      else
        # If it's not HTML nor text then assume it's text to be safe
        _("Issue was closed by %{name} with merge request %{link}") % {
          name: name,
          link: "#{merge_request.to_reference} (#{merge_request.web_url})"
==== app/helpers/events_helper.rb ====
# frozen_string_literal: true

module EventsHelper
  ICON_NAMES_BY_EVENT_TYPE = {
    'pushed to' => 'commit',
    'pushed new' => 'commit',
    'updated' => 'commit',
    'created' => 'status_open',
    'opened' => 'status_open',
    'closed' => 'status_closed',
    'accepted' => 'fork',
    'commented on' => 'comment',
    'deleted' => 'remove',
    'destroyed' => 'remove',
    'imported' => 'import',
    'joined' => 'users',
    'approved' => 'check',
    'added' => 'upload',
    'removed' => 'remove'
  }.freeze

  def localized_action_name_map
    {
      accepted: s_('Event|accepted'),
      approved: s_('Event|approved'),
      closed: s_('Event|closed'),
      'commented on': s_('Event|commented on'),
      created: s_('Event|created'),
      destroyed: s_('Event|destroyed'),
      joined: s_('Event|joined'),
      left: s_('Event|left'),
      opened: s_('Event|opened'),
      updated: s_('Event|updated'),
      'removed due to membership expiration from': s_('Event|removed due to membership expiration from')
    }.merge(
      localized_push_action_name_map,
      localized_created_project_action_name_map,
      localized_design_action_names
    ).freeze
  end

  def localized_push_action_name_map
    {
      'pushed new': s_('Event|pushed new'),
      deleted: s_('Event|deleted'),
      'pushed to': s_('Event|pushed to')
    }.freeze
  end

  def localized_created_project_action_name_map
    {
      created: s_('Event|created'),
      imported: s_('Event|imported')
    }.freeze
  end

  def localized_design_action_names
    {
      added: s_('Event|added'),
      updated: s_('Event|updated'),
      removed: s_('Event|removed')
    }.freeze
  end

  def localized_action_name(event)
    action_name = event.action_name
    # The action fallback is used to cover the types were not included in the maps.
    localized_action_name_map[action_name.to_sym] || action_name
  end

  def link_to_author(event, self_added: false)
    author = event.author

    if author
      name = self_added ? _('You') : author.name
      link_to name, user_path(author.username), title: name, data: { user_id: author.id, username: author.username }, class: 'js-user-link'
    else
      escape_once(event.author_name)
    end
  end

  def event_action_name(event)
    target = event.note_target_type_name || event.target_type_name

    [event.action_name, target].join(" ")
  end

  def event_filter_link(key, text, tooltip)
    key = key.to_s
    active = 'active' if @event_filter.active?(key)
    link_opts = {
      class: "event-filter-link",
      id: "#{key}_event_filter",
      title: tooltip
    }

    content_tag :li, class: active do
      link_to request.path, link_opts do
        content_tag(:span, " #{text}")
      end
    end
  end

  def event_filter_visible(feature_key)
    return designs_visible? if feature_key == :designs
    return true unless @project

    @project.feature_available?(feature_key, current_user)
  end

  def designs_visible?
    if @project
      design_activity_enabled?(@project)
    elsif @group
      design_activity_enabled?(@group)
    elsif @projects
      @projects.with_namespace.include_project_feature.any? { |p| design_activity_enabled?(p) }
    else
      true
    end
==== app/helpers/external_link_helper.rb ====
# frozen_string_literal: true

module ExternalLinkHelper
  include ActionView::Helpers::TextHelper

  def external_link(body, url, options = {})
    link = link_to url, { target: '_blank', rel: 'noopener noreferrer' }.merge(options) do
      "#{body}#{sprite_icon('external-link', css_class: 'gl-ml-2')}".html_safe
    end
    sanitize(link, tags: %w[a svg use], attributes: %w[target rel data-testid class href].concat(options.stringify_keys.keys))
  end
end
==== app/helpers/form_helper.rb ====
# frozen_string_literal: true

module FormHelper
  def form_errors(model, type: 'form', truncate: [], custom_message: [], custom_headline: nil)
    errors = model.errors

    return unless errors.any?

    headline = custom_headline || safe_format(n_(
      'The %{type} contains the following error:',
      'The %{type} contains the following errors:',
      errors.count
    ), type: type)

    truncate = Array.wrap(truncate)

    messages = errors.map do |error|
      attribute = error.attribute

      message = errors.full_message(attribute, error.message)

      # When error message is custom and does not follow the default pattern
      # "<attribute name> <error message>" (e.g. "You have already reported this
      # user"), use the message as-is
      message = error.message if custom_message.include?(attribute)

      message = ERB::Util.html_escape_once(message).html_safe
      message = tag.span(message, class: 'str-truncated-100') if truncate.include?(attribute)
      message = append_help_page_link(message, error.options) if error.options[:help_page_url].present?

      tag.li(message)
    end.join.html_safe

    render Pajamas::AlertComponent.new(
      variant: :danger,
      title: headline,
      dismissible: false,
      alert_options: { id: 'error_explanation', class: 'gl-mb-5' }
    ) do |c|
      c.with_body do
        tag.ul(class: 'gl-pl-5 gl-mb-0') do
          messages
        end
      end
    end
  end

  def dropdown_max_select(data)
    if data[:'max-select'] && data[:'max-select'] < ::Issuable::MAX_NUMBER_OF_ASSIGNEES_OR_REVIEWERS
      data[:'max-select']
    else
      ::Issuable::MAX_NUMBER_OF_ASSIGNEES_OR_REVIEWERS
    end
  end

  def assignees_dropdown_options(issuable_type)
    dropdown_data = {
      toggle_class: 'js-user-search js-assignee-search js-multiselect js-save-user-data',
      title: _('Select assignee'),
      filter: true,
      dropdown_class: 'dropdown-menu-user dropdown-menu-selectable dropdown-menu-assignee',
      placeholder: _('Search users'),
      data: {
        first_user: current_user&.username,
        null_user: true,
        current_user: true,
        project_id: (@target_project || @project)&.id,
        field_name: "#{issuable_type}[assignee_ids][]",
        default_label: _('Unassigned'),
        'max-select': 1,
        'dropdown-header': s_('SearchToken|Assignee'),
        multi_select: true,
        'input-meta': 'name',
        'always-show-selectbox': true,
        current_user_info: UserSerializer.new.represent(current_user),
        testid: 'assignee-ids-dropdown-toggle'
      }
    }

    type = issuable_type.to_s

    if (type == 'issue' && issue_supports_multiple_assignees?) ||
        (type == 'merge_request' && merge_request_supports_multiple_assignees?)
      dropdown_data = multiple_assignees_dropdown_options(dropdown_data)
    end

    dropdown_data
  end

  def reviewers_dropdown_options(issuable_type, iid = nil, target_branch = nil)
    dropdown_data = {
      toggle_class: 'js-reviewer-search js-multiselect js-save-user-data',
      title: 'Request review from',
      filter: true,
      dropdown_class: 'dropdown-menu-user dropdown-menu-selectable dropdown-menu-reviewer',
      placeholder: _('Search users'),
      data: {
        first_user: current_user&.username,
        null_user: true,
        current_user: true,
        project_id: (@target_project || @project)&.id,
        field_name: "#{issuable_type}[reviewer_ids][]",
        default_label: 'Unassigned',
        'max-select': 1,
        'dropdown-header': 'Reviewer',
        multi_select: true,
        'input-meta': 'name',
        'always-show-selectbox': true,
        current_user_info: UserSerializer.new.represent(current_user)
      }
    }

    dropdown_data[:data][:iid] = iid if iid

    dropdown_data[:data][:target_branch] = target_branch if target_branch

    dropdown_data = multiple_reviewers_dropdown_options(dropdown_data) if merge_request_supports_multiple_reviewers?

    dropdown_data[:data].merge!(reviewers_dropdown_options_for_suggested_reviewers)
    dropdown_data
==== app/helpers/groups/group_members_helper.rb ====
# frozen_string_literal: true

module Groups::GroupMembersHelper
  include AvatarsHelper
  include Gitlab::Utils::StrongMemoize

  AVATAR_SIZE = 40

  # rubocop:disable Metrics/ParameterLists -- all arguments needed
  def group_members_app_data(
    group,
    members:,
    invited:,
    access_requests:,
    banned:,
    include_relations:,
    search:,
    pending_members_count:,
    placeholder_users:
  )
    {
      user: group_members_list_data(group, members, { param_name: :page, params: { invited_members_page: nil, search_invited: nil } }),
      group: group_group_links_list_data(group, include_relations, search),
      invite: group_members_list_data(group, invited.nil? ? [] : invited, { param_name: :invited_members_page, params: { page: nil } }),
      access_request: group_members_list_data(group, access_requests.nil? ? [] : access_requests),
      source_id: group.id,
      can_manage_members: can?(current_user, :admin_group_member, group),
      can_manage_access_requests: can?(current_user, :admin_member_access_request, group),
      group_name: group.name,
      group_path: group.full_path,
      can_approve_access_requests: true, # true for CE, overridden in EE
      placeholder: placeholder_users,
      available_roles: available_group_roles(group),
      reassignment_csv_path: group_bulk_reassignment_file_path(group),
      allow_inactive_placeholder_reassignment: allow_admin_bypass?.to_s,
      allow_bypass_placeholder_confirmation: allow_bypass_placeholder_confirmation(group)
    }
  end
  # rubocop:enable Metrics/ParameterLists

  def group_member_header_subtext(group)
    ERB::Util.html_escape(_("You're viewing members of %{strong_start}%{group_name}%{strong_end}.").html_safe) % {
      group_name: group.name,
      strong_start: '<strong>'.html_safe,
      strong_end: '</strong>'.html_safe
    }
  end

  # Overriden in ee/app/helpers/ee/groups/group_members_helper.rb
  def allow_group_owner_enterprise_bypass?(group)
    false
  end

  private

  def group_members_serialized(group, members)
    MemberSerializer.new.represent(members, { current_user: current_user, group: group, source: group })
  end

  def group_group_links_serialized(group, group_links)
    GroupLink::GroupGroupLinkSerializer.new.represent(group_links, { current_user: current_user, source: group })
  end

  # Overridden in `ee/app/helpers/ee/groups/group_members_helper.rb`
  def group_members_list_data(group, members, pagination = {})
    {
      members: group_members_serialized(group, members),
      pagination: members_pagination_data(members, pagination),
      member_path: group_group_member_path(group, ':id')
    }
  end

  def group_group_links(group, include_relations)
    group_links = case include_relations
                  when [:direct]
                    group.shared_with_group_links
                  when [:inherited]
                    group.shared_with_group_links_of_ancestors
                  else
                    group.shared_with_group_links_of_ancestors_and_self
                  end

    group_links.distinct_on_shared_with_group_id_with_group_access
  end

  def group_group_links_list_data(group, include_relations, search)
    group_links = group_group_links(group, include_relations)
    group_links = group_links.search(search, include_parents: true) if search

    {
      members: group_group_links_serialized(group, group_links),
      pagination: members_pagination_data(group_links),
      member_path: group_group_link_path(group, ':id')
    }
  end

  # Overridden in `ee/app/helpers/ee/groups/group_members_helper.rb`
  def available_group_roles(group)
    group.access_level_roles.sort_by { |_, access_level| access_level }.map do |name, access_level|
      { title: name, value: "static-#{access_level}" }
    end
  end

  def allow_admin_bypass?
    Import::UserMapping::AdminBypassAuthorizer.new(current_user).allowed?
  end
  strong_memoize_attr :allow_admin_bypass?

  def allow_bypass_placeholder_confirmation(group)
    if allow_admin_bypass?
      'admin'
    elsif allow_group_owner_enterprise_bypass?(group)
      'group_owner'
    end
  end
end

Groups::GroupMembersHelper.prepend_mod_with('Groups::GroupMembersHelper')
==== app/helpers/groups_helper.rb ====
# frozen_string_literal: true

module GroupsHelper
  def can_change_group_visibility_level?(group)
    can?(current_user, :change_visibility_level, group)
  end

  def can_update_default_branch_protection?(group)
    can?(current_user, :update_default_branch_protection, group)
  end

  def can_change_share_with_group_lock?(group)
    can?(current_user, :change_share_with_group_lock, group)
  end

  def can_change_prevent_sharing_groups_outside_hierarchy?(group)
    can?(current_user, :change_prevent_sharing_groups_outside_hierarchy, group)
  end

  def can_disable_group_emails?(group)
    can?(current_user, :set_emails_disabled, group) && !group.parent&.emails_disabled?
  end

  def can_set_group_diff_preview_in_email?(group)
    return false if group.parent&.show_diff_preview_in_email?.equal?(false)

    can?(current_user, :set_show_diff_preview_in_email, group)
  end

  def can_admin_group_member?(group)
    Ability.allowed?(current_user, :admin_group_member, group)
  end

  def can_invite_group_member?(group)
    Ability.allowed?(current_user, :invite_group_members, group)
  end

  def show_prevent_inviting_groups_outside_hierarchy_setting?(group)
    group.root?
  end

  def group_icon_url(group, options = {})
    group = Group.find_by_full_path(group) if group.is_a?(String)

    group.try(:avatar_url) || ActionController::Base.helpers.image_path('no_group_avatar.png')
  end

  def push_group_breadcrumbs(group)
    sorted_ancestors(group).with_route.reverse_each do |parent|
      push_to_schema_breadcrumb(simple_sanitize(parent.name), group_path(parent), parent.try(:avatar_url))
    end

    push_to_schema_breadcrumb(simple_sanitize(group.name), group_path(group), group.try(:avatar_url))
  end

  def projects_lfs_status(group)
    lfs_status =
      if group.lfs_enabled?
        group.projects.count(&:lfs_enabled?)
      else
        group.projects.count { |project| !project.lfs_enabled? }
      end

    size = group.projects.size

    if lfs_status == size
      'for all projects'
    else
      "for #{lfs_status} out of #{pluralize(size, 'project')}"
    end
  end

  def group_lfs_status(group)
    status = group.lfs_enabled? ? 'enabled' : 'disabled'

    content_tag(:span, class: "lfs-#{status}") do
      "#{status.humanize} #{projects_lfs_status(group)}"
    end
  end

  def share_with_group_lock_help_text(group)
    return default_help unless group.parent&.share_with_group_lock?

    if group.share_with_group_lock?
      if can?(current_user, :change_share_with_group_lock, group.parent)
        ancestor_locked_but_you_can_override(group)
      else
        ancestor_locked_so_ask_the_owner(group)
      end
    else
      ancestor_locked_and_has_been_overridden(group)
    end
  end

  def link_to_group(group)
    link_to(group.name, group_path(group))
  end

  def prevent_sharing_groups_outside_hierarchy_help_text(group)
    safe_format(s_("GroupSettings|Available only on the top-level group. Applies to all subgroups. Groups already shared with a group outside %{group} are still shared unless removed manually."), group: link_to_group(group))
  end

  def render_setting_to_allow_project_access_token_creation?(group)
    group.root? && current_user.can?(:admin_setting_to_allow_resource_access_token_creation, group)
  end

  def show_thanks_for_purchase_alert?(quantity)
    quantity.to_i > 0
  end

  def project_list_sort_by
    @group_projects_sort || @sort || params[:sort] || sort_value_recently_created
  end

  def subgroup_creation_data(group)
    {
      parent_group_url: group.parent && group_url(group.parent),
      parent_group_name: group.parent&.name,
      import_existing_group_path: new_group_path(parent_id: group.parent_id, anchor: 'import-group-pane'),
      is_saas: Gitlab.com?.to_s
==== app/helpers/issuables_helper.rb ====
# frozen_string_literal: true

module IssuablesHelper
  include GitlabRoutingHelper
  include IssuablesDescriptionTemplatesHelper
  include ::Sidebars::Concerns::HasPill

  def sidebar_gutter_toggle_icon
    content_tag(:span, class: 'js-sidebar-toggle-container gl-button-text', data: { is_expanded: !sidebar_gutter_collapsed? }) do
      sprite_icon('chevron-double-lg-left', css_class: "js-sidebar-expand #{'hidden' unless sidebar_gutter_collapsed?}") +
        sprite_icon('chevron-double-lg-right', css_class: "js-sidebar-collapse #{'hidden' if sidebar_gutter_collapsed?}")
    end
  end

  def sidebar_gutter_collapsed_class(is_merge_request_with_flag)
    return "right-sidebar-expanded" if is_merge_request_with_flag

    "right-sidebar-#{sidebar_gutter_collapsed? ? 'collapsed' : 'expanded'}"
  end

  def sidebar_gutter_tooltip_text
    sidebar_gutter_collapsed? ? _('Expand sidebar') : _('Collapse sidebar')
  end

  def assignees_label(issuable, include_value: true)
    assignees = issuable.assignees

    if include_value
      sanitized_list = sanitize_name(issuable.assignee_list)
      ns_('NotificationEmail|Assignee: %{users}', 'NotificationEmail|Assignees: %{users}', assignees.count) % { users: sanitized_list }
    else
      ns_('NotificationEmail|Assignee', 'NotificationEmail|Assignees', assignees.count)
    end
  end

  def multi_label_name(current_labels, default_label)
    return default_label if current_labels.blank?

    title = current_labels.first.try(:title) || current_labels.first[:title]

    if current_labels.size > 1
      "#{title} +#{current_labels.size - 1} more"
    else
      title
    end
  end

  def serialize_issuable(issuable, opts = {})
    serializer_klass = case issuable
                       when Issue
                         IssueSerializer
                       when MergeRequest
                         MergeRequestSerializer
                       end

    serializer_klass
      .new(current_user: current_user, project: issuable.project)
      .represent(issuable, opts)
      .to_json
  end

  def users_dropdown_label(selected_users)
    case selected_users.length
    when 0
      _('Unassigned')
    when 1
      selected_users[0].name
    else
      "#{selected_users[0].name} + #{selected_users.length - 1} more"
    end
  end

  # rubocop: disable CodeReuse/ActiveRecord
  def user_dropdown_label(user_id, default_label)
    return default_label if user_id.nil?
    return "Unassigned" if user_id == "0"

    user = User.find_by(id: user_id)

    if user
      user.name
    else
      default_label
    end
  end
  # rubocop: enable CodeReuse/ActiveRecord

  # rubocop: disable CodeReuse/ActiveRecord
  def project_dropdown_label(project_id, default_label)
    return default_label if project_id.nil?
    return "Any project" if project_id == "0"

    project = Project.find_by(id: project_id)

    if project
      project.full_name
    else
      default_label
    end
  end
  # rubocop: enable CodeReuse/ActiveRecord

  # rubocop: disable CodeReuse/ActiveRecord
  def group_dropdown_label(group_id, default_label)
    return default_label if group_id.nil?
    return "Any group" if group_id == "0"

    group = ::Group.find_by(id: group_id)

    if group
      group.full_name
    else
      default_label
    end
  end
  # rubocop: enable CodeReuse/ActiveRecord

  def issuables_state_counter_text(issuable_type, state, display_count)
    titles = {
      opened: _("Open"),
==== app/helpers/labels_helper.rb ====
# frozen_string_literal: true

module LabelsHelper
  extend self

  def show_label_issuables_link?(label, issuables_type, current_user: nil)
    return true unless label.project_label?

    label.project.feature_available?(issuables_type, current_user)
  end

  # Link to a Label
  #
  # label   - LabelPresenter object to link to
  # type    - The type of item the link will point to (:issue or
  #           :merge_request). If omitted, defaults to :issue.
  # block   - An optional block that will be passed to `link_to`, forming the
  #           body of the link element. If omitted, defaults to
  #           `render_colored_label`.
  #
  # Examples:
  #
  #   # Allow the generated link to use the label's own subject
  #   link_to_label(label)
  #
  #   # Force the generated link to use a provided group
  #   link_to_label(label, subject: Group.last)
  #
  #   # Force the generated link to use a provided project
  #   link_to_label(label, subject: Project.last)
  #
  #   # Force the generated link to point to merge requests instead of issues
  #   link_to_label(label, type: :merge_request)
  #
  #   # Customize link body with a block
  #   link_to_label(label) { "My Custom Label Text" }
  #
  # Returns a String
  def link_to_label(label, type: :issue, tooltip: true, css_class: nil, &block)
    link = label.filter_path(type: type)

    if block
      link_to link, class: css_class, &block
    else
      render_label(label, link: link, tooltip: tooltip)
    end
  end

  def render_label(label, link: nil, tooltip: true, dataset: nil, tooltip_shows_title: false)
    html = render_colored_label(label)

    if link
      title = label_tooltip_title(label, tooltip_shows_title: tooltip_shows_title) if tooltip
      html = render_label_link(html, link: link, title: title, dataset: dataset)
    end

    wrap_label_html(html, label: label)
  end

  def render_colored_label(label, suffix: '')
    render_label_text(
      label.name,
      suffix: suffix,
      css_class: "gl-label-text #{label.text_color_class}",
      bg_color: label.color
    )
  end

  # We need the `label` argument here for EE
  def wrap_label_html(label_html, label:)
    wrapper_classes = %w[gl-label]

    %(<span class="#{wrapper_classes.join(' ')}">#{label_html}</span>).html_safe
  end

  def label_tooltip_title(label, tooltip_shows_title: false)
    Sanitize.clean(tooltip_shows_title ? label.title : label.description)
  end

  def suggested_colors
    {
      '#cc338b' => s_('SuggestedColors|Magenta-pink'),
      '#dc143c' => s_('SuggestedColors|Crimson'),
      '#c21e56' => s_('SuggestedColors|Rose red'),
      '#cd5b45' => s_('SuggestedColors|Dark coral'),
      '#ed9121' => s_('SuggestedColors|Carrot orange'),
      '#eee600' => s_('SuggestedColors|Titanium yellow'),
      '#009966' => s_('SuggestedColors|Green-cyan'),
      '#8fbc8f' => s_('SuggestedColors|Dark sea green'),
      '#6699cc' => s_('SuggestedColors|Blue-gray'),
      '#e6e6fa' => s_('SuggestedColors|Lavender'),
      '#9400d3' => s_('SuggestedColors|Dark violet'),
      '#330066' => s_('SuggestedColors|Deep violet'),
      '#36454f' => s_('SuggestedColors|Charcoal grey'),
      '#808080' => s_('SuggestedColors|Gray')
    }
  end

  def render_suggested_colors
    colors_html = suggested_colors.map do |color_hex_value, color_name|
      link_to('', '#', class: "has-tooltip", style: "background-color: #{color_hex_value}", data: { color: color_hex_value }, title: color_name)
    end

    content_tag(:div, class: 'suggest-colors') do
      colors_html.join.html_safe
    end
  end

  def text_color_for_bg(bg_color)
    ::Gitlab::Color.of(bg_color).contrast
  end

  def labels_filter_path_with_defaults(only_group_labels: false, include_ancestor_groups: true, include_descendant_groups: false)
    options = {}
    options[:include_ancestor_groups] = include_ancestor_groups if include_ancestor_groups
    options[:include_descendant_groups] = include_descendant_groups if include_descendant_groups
    options[:only_group_labels] = only_group_labels if only_group_labels && @group
    options[:format] = :json

    labels_filter_path(options)
==== app/helpers/markup_helper.rb ====
# frozen_string_literal: true

require 'nokogiri'

module MarkupHelper
  include ActionView::Helpers::TextHelper
  include ActionView::Context

  # Use this in places where you would normally use link_to(gfm(...), ...).
  def link_to_markdown(body, url, html_options = {})
    return '' if body.blank?

    link_to_html(markdown(body, pipeline: :single_line), url, html_options)
  end

  def link_to_markdown_field(object, field, url, html_options = {})
    rendered_field = markdown_field(object, field)

    link_to_html(rendered_field, url, html_options)
  end

  # It solves a problem occurring with nested links (i.e.
  # "<a>outer text <a>gfm ref</a> more outer text</a>"). This will not be
  # interpreted as intended. Browsers will parse something like
  # "<a>outer text </a><a>gfm ref</a> more outer text" (notice the last part is
  # not linked any more). link_to_html corrects that. It wraps all parts to
  # explicitly produce the correct linking behavior (i.e.
  # "<a>outer text </a><a>gfm ref</a><a> more outer text</a>").
  def link_to_html(redacted, url, html_options = {})
    fragment = Nokogiri::HTML::DocumentFragment.parse(redacted)

    if fragment.children.size == 1 && fragment.children[0].name == 'a'
      # Fragment has only one node, and it's a link generated by `gfm`.
      # Replace it with our requested link.
      text = fragment.children[0].text
      fragment.children[0].replace(link_to(text, url, html_options))
    else
      # Traverse the fragment's first generation of children looking for
      # either pure text or emojis, wrapping anything found in the
      # requested link
      fragment.children.each do |node|
        if node.text?
          node.replace(link_to(node.text, url, html_options))
        elsif node.name == 'gl-emoji'
          node.replace(link_to(node.to_html.html_safe, url, html_options))
        end
      end
    end

    # Add any custom CSS classes to the GFM-generated reference links
    if html_options[:class]
      fragment.css('a.gfm').add_class(html_options[:class])
    end

    fragment.to_html.html_safe
  end

  # Return the first line of +text+, up to +max_chars+, after parsing the line
  # as Markdown.  HTML tags in the parsed output are not counted toward the
  # +max_chars+ limit.  If the length limit falls within a tag's contents, then
  # the tag contents are truncated without removing the closing tag.
  def first_line_in_markdown(object, attribute, max_chars = nil, **options)
    md = markdown_field(object, attribute, options.merge(post_process: false))
    return unless md.present?

    tags = %w[a gl-emoji b strong i em pre code p span]

    context = markdown_field_render_context(object, attribute, options)
    context.reverse_merge!(truncate_visible_max_chars: max_chars || md.length)

    text = prepare_for_rendering(md, context)
    text = sanitize(
      text,
      tags: tags,
      attributes: Rails::Html::WhiteListSanitizer.allowed_attributes +
        %w[
          style data-src data-name data-unicode-version data-html data-fallback-src
          data-reference-type data-project-path data-iid data-mr-title
          data-user
        ]
    )

    render_links(text)
  end

  def markdown(text, context = {}, postprocess = {})
    return '' unless text.present?

    context[:project] ||= @project
    context[:group] ||= @group

    html = Markup::RenderingService.new(text, context: context,
      postprocess_context: postprocess_context.merge!(postprocess)).execute

    Hamlit::RailsHelpers.preserve(html)
  end

  def markdown_field(object, field, context = {})
    object = object.for_display if object.respond_to?(:for_display)
    return '' unless object.present?

    redacted_field_html = object.try(:"redacted_#{field}_html")
    return redacted_field_html if redacted_field_html

    render_markdown_field(object, field, context)
  end

  def markup(file_name, text, context = {})
    context[:project] ||= @project
    context[:text_source] ||= :blob
    context[:requested_path] ||= @path if context[:text_source] == :blob
    prepare_asciidoc_context(file_name, context)

    html = Markup::RenderingService
             .new(text, file_name: file_name, context: context, postprocess_context: postprocess_context)
             .execute

    Hamlit::RailsHelpers.preserve(html)
  end

==== app/helpers/merge_requests_helper.rb ====
# frozen_string_literal: true

module MergeRequestsHelper
  include Gitlab::Utils::StrongMemoize
  include CompareHelper
  DIFF_BATCH_ENDPOINT_PER_PAGE = 5

  def create_mr_button_from_event?(event)
    create_mr_button?(from: event.branch_name, source_project: event.project)
  end

  def create_mr_path_from_push_event(event)
    create_mr_path(from: event.branch_name, source_project: event.project)
  end

  def mr_css_classes(mr)
    classes = ["merge-request"]
    classes << "closed" if mr.closed?
    classes << "merged" if mr.merged?
    classes.join(' ')
  end

  def merge_path_description(merge_request, with_arrow: false)
    if merge_request.for_fork?
      msg = if with_arrow
              _("Project:Branches: %{source_project_path}:%{source_branch}  %{target_project_path}:%{target_branch}")
            else
              _("Project:Branches: %{source_project_path}:%{source_branch} to %{target_project_path}:%{target_branch}")
            end

      msg % {
        source_project_path: merge_request.source_project_path,
        source_branch: merge_request.source_branch,
        target_project_path: merge_request.target_project.full_path,
        target_branch: merge_request.target_branch
      }
    else
      msg = if with_arrow
              _("Branches: %{source_branch}  %{target_branch}")
            else
              _("Branches: %{source_branch} to %{target_branch}")
            end

      msg % {
        source_branch: merge_request.source_branch,
        target_branch: merge_request.target_branch
      }
    end
  end

  def mr_change_branches_path(merge_request)
    project_new_merge_request_path(
      @project,
      merge_request: {
        source_project_id: merge_request.source_project_id,
        target_project_id: merge_request.target_project_id,
        source_branch: merge_request.source_branch,
        target_branch: merge_request.target_branch
      },
      change_branches: true
    )
  end

  def format_mr_branch_names(merge_request)
    source_path = merge_request.source_project_path
    target_path = merge_request.target_project_path
    source_branch = merge_request.source_branch
    target_branch = merge_request.target_branch

    if source_path == target_path
      [source_branch, target_branch]
    else
      ["#{source_path}:#{source_branch}", "#{target_path}:#{target_branch}"]
    end
  end

  def target_projects(project)
    MergeRequestTargetProjectFinder.new(current_user: current_user, source_project: project)
      .execute(include_routes: true)
  end

  def merge_request_button_hidden?(merge_request, closed)
    merge_request.closed? == closed ||
      (merge_request.merged? == closed && !merge_request.closed?) ||
      merge_request.closed_or_merged_without_fork?
  end

  def merge_request_version_path(project, merge_request, merge_request_diff, start_sha = nil)
    diffs_project_merge_request_path(project, merge_request, diff_id: merge_request_diff.id, start_sha: start_sha)
  end

  def merge_params(merge_request)
    {
      auto_merge_strategy: merge_request.default_auto_merge_strategy,
      should_remove_source_branch: true,
      sha: merge_request.diff_head_sha,
      squash: merge_request.squash_on_merge?
    }
  end

  def tab_link_for(merge_request, tab, options = {}, &block)
    data_attrs = {
      action: tab.to_s,
      target: "##{tab}",
      toggle: options.fetch(:force_link, false) ? '' : 'tabvue'
    }

    url = case tab
          when :show
            data_attrs[:target] = '#notes'
            method(:project_merge_request_path)
          when :commits
            method(:commits_project_merge_request_path)
          when :pipelines
            method(:pipelines_project_merge_request_path)
          when :diffs
            method(:diffs_project_merge_request_path)
          when :reports
            method(:reports_project_merge_request_path)
          else
==== app/helpers/namespaces/deletable_helper.rb ====
# frozen_string_literal: true

module Namespaces
  module DeletableHelper
    def permanent_deletion_date_formatted(container_or_date = Date.current, format: '%F')
      date =
        if container_or_date.respond_to?(:self_deletion_scheduled_deletion_created_on)
          container_or_date.self_deletion_scheduled_deletion_created_on
        else
          container_or_date
        end

      return unless date.is_a?(Date) || date.is_a?(Time)

      ::Gitlab::CurrentSettings.deletion_adjourned_period.days.since(date).strftime(format)
    end

    def deletion_in_progress_or_scheduled_in_hierarchy_chain?(namespace)
      return false unless namespace.respond_to?(:deletion_in_progress_or_scheduled_in_hierarchy_chain?)

      namespace.deletion_in_progress_or_scheduled_in_hierarchy_chain?
    end

    def self_or_ancestors_deletion_in_progress_or_scheduled_message(namespace)
      _self_deletion_in_progress_message(namespace) || _deletion_scheduled_in_hierarchy_chain_message(namespace)
    end

    def _self_deletion_in_progress_message(namespace)
      return unless namespace.self_deletion_in_progress?

      messages = {
        group: _('This group and its subgroups are being deleted.'),
        project: _('This project is being deleted. Repository and other project resources are read-only.')
      }

      _message_for_namespace(namespace, messages)
    end

    def _deletion_scheduled_in_hierarchy_chain_message(namespace)
      if namespace.self_deletion_scheduled?
        _self_deletion_scheduled_message(namespace)
      else
        _parent_deletion_scheduled_message(namespace)
      end
    end

    def _self_deletion_scheduled_message(namespace)
      date = permanent_deletion_date_formatted(namespace)

      messages = {
        group: _('This group and its subgroups and projects are pending deletion, and will be deleted on %{date}.'),
        project: _('This project is pending deletion, and will be deleted on %{date}. Repository and other project ' \
          'resources are read-only.')
      }

      safe_format(
        _message_for_namespace(namespace, messages),
        date: tag.strong(date)
      )
    end

    def _parent_deletion_scheduled_message(namespace)
      namespace_pending_deletion = namespace.first_scheduled_for_deletion_in_hierarchy_chain
      date = permanent_deletion_date_formatted(namespace_pending_deletion)

      messages = {
        group: _('This group will be deleted on %{date} because its parent group is ' \
          'scheduled for deletion.'),
        project: _('This project will be deleted on %{date} because its parent group is ' \
          'scheduled for deletion.')
      }

      safe_format(
        _message_for_namespace(namespace, messages),
        date: tag.strong(date)
      )
    end

    def delete_delayed_namespace_message(namespace)
      messages = {
        group: _('This action will place this group, including its subgroups and projects, ' \
          'in a pending deletion state for %{deletion_adjourned_period} days, ' \
          'and delete it permanently on %{date}.'),
        project: _('This action will place this project, including all its resources, ' \
          'in a pending deletion state for %{deletion_adjourned_period} days, ' \
          'and delete it permanently on %{date}.')
      }

      safe_format(
        _message_for_namespace(namespace, messages),
        deletion_adjourned_period: namespace.deletion_adjourned_period,
        date: tag.strong(permanent_deletion_date_formatted)
      )
    end

    def delete_immediately_namespace_scheduled_for_deletion_message(namespace)
      messages = {
        group: _('This group is scheduled for deletion on %{date}. ' \
          'This action will permanently delete this group, ' \
          'including its subgroups and projects, %{strongOpen}immediately%{strongClose}. ' \
          'This action cannot be undone.'),
        project: _('This project is scheduled for deletion on %{date}. ' \
          'This action will permanently delete this project, ' \
          'including all its resources, %{strongOpen}immediately%{strongClose}. ' \
          'This action cannot be undone.')
      }

      safe_format(
        _message_for_namespace(namespace, messages),
        date: tag.strong(permanent_deletion_date_formatted(namespace)),
        strongOpen: '<strong>'.html_safe,
        strongClose: '</strong>'.html_safe
      )
    end

    def group_confirm_modal_data(
      group:,
      remove_form_id: nil,
      permanently_remove: false,
      button_text: nil,
==== app/helpers/notify_helper.rb ====
# frozen_string_literal: true

module NotifyHelper
  def merge_request_reference_link(entity, *args)
    link_to(entity.to_reference, merge_request_url(entity, *args))
  end

  def issue_reference_link(entity, *args, full: false)
    link_to(entity.to_reference(full: full), issue_url(entity, *args))
  end

  def work_item_type_for(work_item)
    type = work_item.work_item_type

    # For now we are limiting the scope of the change only for epic work items,
    # we can remove this check to support all work item types.
    type.epic? ? type.base_type : 'issue'
  end

  def merge_request_hash_param(merge_request, reviewer)
    {
      mr_highlight: '<span style="font-weight: 600;color:#333333;">'.html_safe,
      highlight_end: '</span>'.html_safe,
      mr_link: link_to(
        merge_request.to_reference, merge_request_url(merge_request),
        style: "font-weight: 600;color:#3777b0;text-decoration:none"
      ).html_safe,
      reviewer_highlight: '<span>'.html_safe,
      reviewer_avatar: content_tag(
        :img,
        nil,
        height: "24",
        src: avatar_icon_for_user(reviewer, 24, only_path: false),
        style: "border-radius:12px;margin-left:3px;vertical-align:bottom;",
        width: "24",
        alt: "Avatar",
        class: "avatar"
      ).html_safe,
      reviewer_link: link_to(
        reviewer.name,
        user_url(reviewer),
        style: "color:#333333;text-decoration:none;",
        class: "muted"
      ).html_safe
    }
  end
end
==== app/helpers/page_layout_helper.rb ====
# frozen_string_literal: true

module PageLayoutHelper
  include Gitlab::Utils::StrongMemoize

  def page_title(*titles)
    @page_title ||= []

    @page_title.push(*titles.compact) if titles.any?

    if titles.any? && !defined?(@breadcrumb_title)
      @breadcrumb_title = @page_title.last
    end

    # Segments are separated by middot
    @page_title.join("  ")
  end

  # Define or get a description for the current page
  #
  # description - String (default: nil)
  #
  # If this helper is called multiple times with an argument, only the last
  # description will be returned when called without an argument. Descriptions
  # have newlines replaced with spaces and all HTML tags are sanitized.
  #
  # Examples:
  #
  #   page_description # => "GitLab Community Edition"
  #   page_description("Foo")
  #   page_description # => "Foo"
  #
  #   page_description("<b>Bar</b>\nBaz")
  #   page_description # => "Bar Baz"
  #
  # Returns an HTML-safe String.
  def page_description(description = nil)
    if description.present?
      @page_description = description.squish
    elsif @page_description.present?
      sanitize(@page_description.truncate_words(30), tags: [])
    end
  end

  def page_canonical_link(link = nil)
    if link
      @page_canonical_link = link
    else
      @page_canonical_link ||= generic_canonical_url
    end
  end

  def favicon
    Gitlab::Favicon.main
  end

  def page_image
    default = image_url('twitter_card.jpg')

    subject = @project || @user || @group

    image = subject.avatar_url(only_path: false) if subject.present?
    image || default
  end

  # Define or get attributes to be used as Twitter card metadata
  #
  # map - Hash of label => data pairs. Keys become labels, values become data
  #
  # Raises ArgumentError if given more than two attributes
  def page_card_attributes(map = {})
    raise ArgumentError, 'cannot provide more than two attributes' if map.length > 2

    @page_card_attributes ||= {}
    @page_card_attributes = map.reject { |_, v| v.blank? } if map.present?
    @page_card_attributes
  end

  def page_card_meta_tags
    tags = []

    page_card_attributes.each_with_index do |pair, i|
      tags << tag.meta(property: "twitter:label#{i + 1}", content: pair[0])
      tags << tag.meta(property: "twitter:data#{i + 1}",  content: pair[1])
    end

    tags.join.html_safe
  end

  def header_title(title = nil, title_url = nil)
    return @header_title unless title

    @header_title     = title
    @header_title_url = title_url
  end

  def sidebar(name = nil)
    if name
      @sidebar = name
    else
      @sidebar
    end
  end

  def nav(name = nil)
    if name
      @nav = name
    else
      @nav
    end
  end

  # This helper ensures there is always a default `Gitlab::SearchContext` available
  # to all controller that use the application layout.
  def search_context
    strong_memoize(:search_context) do
      next super if defined?(super)

      Gitlab::SearchContext::Builder.new(controller.view_context).build!
    end
==== app/helpers/projects_helper.rb ====
# frozen_string_literal: true

module ProjectsHelper
  include Gitlab::Utils::StrongMemoize
  include CompareHelper
  include Gitlab::Allowable

  def project_incident_management_setting
    @project_incident_management_setting ||= @project.incident_management_setting ||
      @project.build_incident_management_setting
  end

  def link_to_project(project)
    link_to namespace_project_path(namespace_id: project.namespace, id: project),
      title: h(project.name),
      class: 'gl-link' do
      title = content_tag(:span, project.name, class: 'project-name')

      if project.namespace
        namespace = content_tag(:span, "#{project.namespace.human_name} / ", class: 'namespace-name')
        title = namespace + title
      end

      title
    end
  end

  def link_to_member_avatar(author, opts = {})
    default_opts = { size: 16 }
    opts = default_opts.merge(opts)

    classes = %W[avatar avatar-inline s#{opts[:size]}]
    classes << opts[:avatar_class] if opts[:avatar_class]

    avatar = avatar_icon_for_user(author, opts[:size])

    image_tag(avatar, width: opts[:size], class: classes, alt: '')
  end

  def author_content_tag(author, opts = {})
    default_opts = { author_class: 'author', tooltip: false, by_username: false }
    opts = default_opts.merge(opts)

    has_tooltip = !opts[:by_username] && opts[:tooltip]

    username = opts[:by_username] ? author.to_reference : author.name
    name_tag_options = { class: [opts[:author_class]] }

    if has_tooltip
      name_tag_options[:title] = author.to_reference
      name_tag_options[:data] = { placement: 'top' }
      name_tag_options[:class] << 'has-tooltip'
    end

    # NOTE: ActionView::Helpers::TagHelper#content_tag HTML escapes username
    content_tag(:span, username, name_tag_options)
  end

  def link_to_member(author, opts = {}, &block)
    default_opts = { avatar: true, name: true, title: ":name" }
    opts = default_opts.merge(opts)

    return "(deleted)" unless author

    data_attrs = {
      user_id: author.id,
      username: author.username,
      name: author.name,
      testid: "author-link"
    }

    inject_classes = ["author-link gl-text-link", opts[:extra_class]]

    if opts[:name]
      inject_classes.concat(["js-user-link", opts[:mobile_classes]])
    else
      inject_classes.append("has-tooltip")
    end

    inject_classes = inject_classes.compact.join(" ")

    author_html = []
    # Build avatar image tag
    author_html << link_to_member_avatar(author, opts) if opts[:avatar]
    # Build name span tag
    author_html << author_content_tag(author, opts) if opts[:name]
    author_html << capture(&block) if block
    author_html = author_html.join.html_safe

    if opts[:name]
      link_to(author_html, user_path(author), class: inject_classes, data: data_attrs).html_safe
    else
      title = opts[:title].sub(":name", sanitize(author.name))
      link_to(
        author_html,
        user_path(author),
        class: inject_classes,
        title: title,
        data: { container: 'body' }
      ).html_safe
    end
  end

  def push_project_breadcrumbs(project)
    if project.group
      push_group_breadcrumbs(project.group)
    else
      owner = project.namespace.owner
      name = sanitize(owner.name, tags: [])
      url = user_path(owner)

      push_to_schema_breadcrumb(name, url)
    end

    push_to_schema_breadcrumb(simple_sanitize(project.name), project_path(project), project.try(:avatar_url))
  end

  def remove_project_message
    format(
      _("Deleting a project places it into a read-only state until %{date}, " \
==== app/helpers/projects/project_members_helper.rb ====
# frozen_string_literal: true

module Projects::ProjectMembersHelper
  def project_members_app_data_json(...)
    project_members_app_data(...).to_json
  end

  def project_member_header_subtext(project)
    if can?(current_user, :admin_project_member, project)
      share_project_description(project)
    else
      ERB::Util.html_escape(_("Members can be added by project " \
        "%{i_open}Maintainers%{i_close} or %{i_open}Owners%{i_close}")) % {
          i_open: '<i>'.html_safe, i_close: '</i>'.html_safe
        }
    end
  end

  private

  def project_members_app_data(
    project, members:, invited:, access_requests:, include_relations:, search:, pending_members_count: # rubocop:disable Lint/UnusedMethodArgument -- Argument used in EE
  )
    {
      user: project_members_list_data(project, members, { param_name: :page, params: { search_groups: nil } }),
      group: project_group_links_list_data(project, include_relations, search),
      invite: project_members_list_data(project, invited.nil? ? [] : invited),
      access_request: project_members_list_data(project, access_requests.nil? ? [] : access_requests),
      source_id: project.id,
      can_manage_members: Ability.allowed?(current_user, :admin_project_member, project),
      can_manage_access_requests: Ability.allowed?(current_user, :admin_member_access_request, project),
      group_name: project.group&.name,
      group_path: project.group&.full_path,
      project_path: project.full_path,
      can_approve_access_requests: true, # true for CE, overridden in EE
      available_roles: available_project_roles(project)
    }
  end

  def share_project_description(project)
    share_with_group   = project.allowed_to_share_with_group?
    share_with_members = !membership_locked?

    description =
      if share_with_group && share_with_members
        _("You can invite a new member to %{project_name} or invite another group.")
      elsif share_with_group
        _("You can invite another group to %{project_name}.")
      elsif share_with_members
        _("You can invite a new member to %{project_name}.")
      end

    ERB::Util.html_escape(description) % { project_name: tag.strong(project.name) }
  end

  def project_members_serialized(project, members)
    MemberSerializer.new.represent(members, { current_user: current_user, group: project.group, source: project })
  end

  def project_group_links_serialized(project, group_links)
    GroupLink::ProjectGroupLinkSerializer.new.represent(group_links, { current_user: current_user, source: project })
  end

  def project_members_list_data(project, members, pagination = {})
    {
      members: project_members_serialized(project, members),
      pagination: members_pagination_data(members, pagination),
      member_path: project_project_member_path(project, ':id')
    }
  end

  def project_group_links_list_data(project, include_relations, search)
    members = []

    if include_relations.include?(:direct)
      project_group_links = project.project_group_links
      project_group_links = project_group_links.search(search) if search
      members += project_group_links_serialized(project, project_group_links)
    end

    if include_relations.include?(:inherited)
      group_group_links = project.group_group_links.distinct_on_shared_with_group_id_with_group_access
      group_group_links = group_group_links.search(search, include_parents: true) if search
      members += group_group_links_serialized(project, group_group_links)
    end

    if project_group_links.present? && group_group_links.present?
      members = members.sort_by { |m| -m.dig(:access_level, :integer_value).to_i }
                       .uniq { |m| m.dig(:shared_with_group, :id) }
    end

    {
      members: members,
      pagination: members_pagination_data(members),
      member_path: project_group_link_path(project, ':id')
    }
  end

  # Overridden in `ee/app/helpers/ee/projects/project_members_helper.rb`
  def available_project_roles(_)
    Gitlab::Access.options_with_owner.map do |name, access_level|
      { title: name, value: "static-#{access_level}" }
    end
  end
end

Projects::ProjectMembersHelper.prepend_mod_with('Projects::ProjectMembersHelper')
==== app/helpers/safe_format_helper.rb ====
# frozen_string_literal: true

module SafeFormatHelper
  # Returns a HTML-safe String.
  #
  # @param [String] format is escaped via `ERB::Util.html_escape_once`
  # @param [Array<Hash>] args are escaped via `ERB::Util.html_escape` if they are not marked as HTML-safe
  #
  # @example
  #   safe_format('See %{user_input}', user_input: '<b>bold</b>')
  #   # => "See &lt;b&gt;bold&lt;/b&gt"
  #
  #   safe_format('In &lt; hour & more')
  #   # => "In &lt; hour &amp; more"
  #
  # @example With +tag_pair+ support
  #   safe_format('Some %{open}bold%{close} text.', tag_pair(tag.strong, :open, :close))
  #   # => "Some <strong>bold</strong> text."
  #   safe_format('Some %{open}bold%{close} %{italicStart}text%{italicEnd}.',
  #     tag_pair(tag.strong, :open, :close),
  #     tag_pair(tag.i, :italicStart, :italicEnd))
  #   # => "Some <strong>bold</strong> <i>text</i>.
  def safe_format(format, *args)
    args = args.inject({}, &:merge)

    # Use `Kernel.format` to avoid conflicts with ViewComponent's `format`.
    Kernel.format(
      ERB::Util.html_escape_once(format),
      args.transform_values { |value| ERB::Util.html_escape(value) }
    ).html_safe
  end

  # Returns a Hash containing a pair of +open+ and +close+ tag parts extracted
  # from HTML-safe +tag+. The values are HTML-safe.
  #
  # Returns an empty Hash if +tag+ is not a valid paired tag (e.g. <p>foo</p>).
  # an empty Hash is returned.
  #
  # @param [String] html_tag is a HTML-safe output from tag helper
  # @param [Symbol,Object] open_name name of opening tag
  # @param [Symbol,Object] close_name name of closing tag
  # @raise [ArgumentError] if +tag+ is not HTML-safe
  #
  # @example
  #   tag_pair(tag.strong, :open, :close)
  #   # => { open: '<strong>', close: '</strong>' }
  #   tag_pair(link_to('', '/'), :open, :close)
  #   # => { open: '<a href="/">', close: '</a>' }
  def tag_pair(html_tag, open_name, close_name)
    raise ArgumentError, 'Argument `tag` must be `html_safe`!' unless html_tag.html_safe?
    return {} unless html_tag.start_with?('<')

    # end of opening tag: <p>foo</p>
    #                       ^
    open_index = html_tag.index('>')
    # start of closing tag: <p>foo</p>
    #                             ^^
    close_index = html_tag.rindex('</')

    return {} unless open_index && close_index

    {
      open_name => html_tag[0, open_index + 1],
      close_name => html_tag[close_index, html_tag.size]
    }
  end
end
==== app/helpers/search_helper.rb ====
# frozen_string_literal: true

module SearchHelper
  # params which should persist when a new tab is selected
  SEARCH_GENERIC_PARAMS = [
    :search,
    :scope,
    :project_id,
    :group_id,
    :repository_ref,
    :snippets,
    :sort,
    :force_search_results,
    :type
  ].freeze

  def search_autocomplete_opts(term, filter: nil, scope: nil)
    return unless current_user

    results = case filter&.to_sym
              when :search
                resource_results(term, scope: scope)
              when :generic
                [
                  recent_items_autocomplete(term),
                  generic_results(term)
                ]
              else
                [
                  recent_items_autocomplete(term),
                  resource_results(term),
                  generic_results(term)
                ]
              end

    results.flatten { |item| item[:label] }
  end

  def resource_results(term, scope: nil)
    return [] if term.length < Gitlab::Search::Params::MIN_TERM_LENGTH
    return scope_specific_results(term, scope) if scope.present?

    [
      groups_autocomplete(term),
      projects_autocomplete(term),
      users_autocomplete(term),
      issue_autocomplete(term)
    ].flatten
  end

  def scope_specific_results(term, scope)
    case scope&.to_sym
    when :projects
      projects_autocomplete(term)
    when :users
      users_autocomplete(term)
    when :issues
      recent_issues_autocomplete(term)
    else
      []
    end
  end

  def generic_results(term)
    search_pattern = Regexp.new(Regexp.escape(term), "i")

    generic_results = project_autocomplete + default_autocomplete + help_autocomplete
    generic_results.concat(default_autocomplete_admin) if current_user.can_read_all_resources?
    generic_results.select { |result| result[:label] =~ search_pattern }
  end

  def recent_items_autocomplete(term)
    recent_merge_requests_autocomplete(term) + recent_issues_autocomplete(term)
  end

  def search_entries_info(collection, scope, term)
    return if collection.to_a.empty?

    from = collection.offset_value + 1
    to = collection.offset_value + collection.to_a.size
    count = collection.total_count
    term_element = "<span>&nbsp;<code>#{h(term)}</code>&nbsp;</span>".html_safe

    search_entries_info_template(collection) % {
      from: from,
      to: to,
      count: count,
      scope: search_entries_scope_label(scope, count),
      term_element: term_element
    }
  end

  def search_entries_scope_label(scope, count)
    case scope
    when 'blobs'
      ns_('SearchResults|code result', 'SearchResults|code results', count)
    when 'commits'
      ns_('SearchResults|commit', 'SearchResults|commits', count)
    when 'issues'
      ns_('SearchResults|issue', 'SearchResults|issues', count)
    when 'merge_requests'
      ns_('SearchResults|merge request', 'SearchResults|merge requests', count)
    when 'milestones'
      ns_('SearchResults|milestone', 'SearchResults|milestones', count)
    when 'notes'
      ns_('SearchResults|comment', 'SearchResults|comments', count)
    when 'projects'
      ns_('SearchResults|project', 'SearchResults|projects', count)
    when 'snippet_titles'
      ns_('SearchResults|snippet', 'SearchResults|snippets', count)
    when 'users'
      ns_('SearchResults|user', 'SearchResults|users', count)
    when 'wiki_blobs'
      ns_('SearchResults|wiki result', 'SearchResults|wiki results', count)
    else
      raise "Unrecognized search scope '#{scope}'"
    end
  end

  def search_entries_info_template(collection)
